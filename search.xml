<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>搭建github pages</title>
    <url>/2021/01/24/BuildBlog/</url>
    <content><![CDATA[<blockquote>
<p>因为之前的腾讯云新用户优惠的服务器到期了，续费的话还需要原价购买，如果使用学生优惠的话又需要重新部署一遍。最后想了一想还是决定去<code>gitee</code>或者<code>github</code>白嫖。开始的时候准备使用<code>gitee</code>的，但是部署完以后发现自己的域名解析不了，折腾了许久才发现这是<code>gitee pages pro</code>的功能，而且现在不知道为什么已经消失不见了。最后还是无奈选择<code>github pages</code>。</p>
</blockquote>
<h3 id="github访问速度"><a href="#github访问速度" class="headerlink" title="github访问速度"></a>github访问速度</h3><p>我不想用<code>github pages</code>最主要的原因还是因为这网速实在是太堪忧了，经常就直接原地去世。为了改善一下<code>github</code>的速度，可以上<a href="https://www.ipaddress.com/">ipaddress.com</a>查询一下<code>github.com</code>和<code>github.global.ssl.fastly.net</code>的IP地址，接着添加到本地的host文件<code>C:\Windows\System32\drivers\etc\hosts</code>中便可，亲测有些许效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">140.82.114.3	github.com</span><br><span class="line">199.232.69.194	github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure>


<h3 id="github-pages搭建前的工作"><a href="#github-pages搭建前的工作" class="headerlink" title="github pages搭建前的工作"></a>github pages搭建前的工作</h3><ul>
<li><p>安装<code>node.js</code> </p>
<ul>
<li><a href="https://nodejs.org/en/download/">官方网址传送门</a></li>
<li><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">环境配置教程</a></li>
</ul>
</li>
<li><p>安装<code>git</code></p>
<ul>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496">安装教程</a></li>
</ul>
</li>
<li><p>安装cnpm(不是必须过程，只是使用国内源，速度能快得一批)</p>
<p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
</li>
</ul>
<h3 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h3><ul>
<li>安装Hexo</li>
</ul>
<p><code>npm install -g hexo</code>或者<code>cnpm install -g hexo</code></p>
<ul>
<li>创建Hexo项目</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd Hexo //跳转到目标文件夹</span><br><span class="line">Hexo init //在目标文件夹创建Hexo项目</span><br></pre></td></tr></table></figure>
<ul>
<li>安装主题样式解析</li>
</ul>
<p><code>npm install hexo-renderer-scss --save</code></p>
<ul>
<li>安装主题</li>
</ul>
<p>我的主题是github上的<a href="https://github.com/Fechin/hexo-theme-diaspora">diaspora</a>,教程上面也有，代码核心代码就也就下面这句:</p>
<p><code>git clone https://github.com/Fechin/hexo-theme-diaspora.git themes/diaspora</code></p>
<ul>
<li>启用主题</li>
</ul>
<p>在<code>hexo项目的根目录 -&gt; _config.yml配置文件</code>中，修改theme为theme: diaspora</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">theme: diaspora</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<h3 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h3><ol>
<li><p>编译Hexo项目：<code>hexo g</code> </p>
</li>
<li><p>本地运行Hexo项目：<code>hexo s</code></p>
</li>
<li><p>预览：浏览器输入<code>http://localhost:4000/</code>即可</p>
</li>
</ol>
<h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><ol>
<li><p><code>注册</code>-&gt;<code>登录</code>-&gt;<code>右上角“+”</code>-&gt;<code>New repository</code></p>
</li>
<li><p>仓库名为<code>username.github.io</code>,这个以后就是未来你博客的域名了</p>
</li>
<li><p>在<code>hexo项目的根目录 -&gt; _config.yml配置文件</code>中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: 复制你的仓库的https链接即可</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li>
<li><p>安装自动部署发布工具</p>
<p><code>npm install hexo-deployer-git --save</code></p>
</li>
<li><p>发布到github上</p>
<p>部署项目：<code>hexo d</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><ul>
<li><p>在<code>购买域名的控制台</code>-&gt;<code>域名-</code>&gt;<code>域名列表</code>-&gt;<code>解析</code>时</p>
<p>​    域名记录选择<code>CNAME</code></p>
<p>​    解析路线填写<code>username.github.io.</code></p>
</li>
<li><p>在<code>hexo项目的根目录 -&gt; source文件夹</code>中，新建一个名字叫CANME的文件(不带后缀名),在里面写上你的域名</p>
</li>
<li><p>重新部署一下项目，然后等个10分钟就完事鸟</p>
</li>
</ul>
<h3 id="github图床"><a href="#github图床" class="headerlink" title="github图床"></a>github图床</h3><blockquote>
<p>都白都白嫖了github一个博客了，也不差着再薅一个图床了，对吧!</p>
</blockquote>
<ol>
<li>首先，在<code>hexo项目的根目录 -&gt; _config.yml配置文件</code>中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">post_asset_folder: true &#x2F;&#x2F;设为true以后，每创建一篇文章都会同时创建一个同名文件夹，用来装相对应的图片</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>​    图片路径名<code>https://github用户名.github.io/存储库名/你的图片名.后缀名</code></li>
</ol>
<p><img src="https://jiajuu.top/2021/01/24/BuildBlog/dancing.gif"></p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>C++多态的实现</title>
    <url>/2021/03/30/C%E8%89%B9%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>昨天被面试官的一个问题面懵逼了(((φ(◎ロ◎;)φ)))！！</p>
<p>大概的问题就是如果不用指针或者引用，那么还能实现多态吗？</p>
<p>平时都是使用指针的方式实现多态，真没注意这些小细节，所以一被细问就直接凉透了。</p>
<p>这也怪不得谁，只能怪自己的确是有些菜，所以只能记录一波。</p>
</blockquote>
<p>我们平时都是用指针的方式实现多态的。按照惯例，我们举个最最最简单的栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void func()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;这是A Class&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B  : public B&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void func()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;这是B Class&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	B b;</span><br><span class="line">	A* a1 &#x3D; new B();</span><br><span class="line">	A* a2 &#x3D; &amp;b;</span><br><span class="line">	a1-&gt;func();</span><br><span class="line">	a2-&gt;func();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出：这是B Class</span><br></pre></td></tr></table></figure>
<p>我们也可以使用引用来实现多态。我们继续举栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void func()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;这是A Class&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B  : public B&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void func()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;这是B Class&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	B b;</span><br><span class="line">	A&amp; a &#x3D; b;</span><br><span class="line">	a.func();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出：这是B Class</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面两种方式都理所当然的能实现多态。</p>
</blockquote>
<p>但是如果我们不用指针也不用引用呢？会肾么事呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void func()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;这是A Class&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B  : public B&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void func()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;这是B Class&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	B b;</span><br><span class="line">	A a &#x3D; b;</span><br><span class="line">	a.func();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出：这是A Class</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是为肾么呢？</p>
<p>面试完后我自己仔细回想了一番，给一个解释说服自己。</p>
<p>答：</p>
<ol>
<li>因为引用<code>A&amp; a</code> 的本质其实也是<code>A* const a</code>，所以我们可以把指针和引用都当作指针。</li>
<li>指针的赋值其实就是把指向内存中的地址，不涉及拷贝构造函数和<code>=</code>运算符重载函数</li>
<li>但是如果我们不使用指针和引用 ，我们直接使用赋值，那么这个过程会调用拷贝构造函数或者<code>=</code>运算符重载函数</li>
<li>相当于以子类对象来初始化父类对象，这过程并不会改变虚指针<code>vptr</code>的指向。</li>
</ol>
</blockquote>
<p>上面仅仅是我个人的看法，所以并不保证正确。所以我又找度娘找了找权威的解释：</p>
<p>《深度探索C++对象模型》：</p>
<blockquote>
<p>“一个pointer或一个reference之所以支持多态，是因为它们并不引发内存任何“与类型有关的内存委托操作； 会受到改变的。只有它们所指向内存的大小和解释方式而已”</p>
<p>对这句话的解释就是:</p>
<ul>
<li>指针和引用类型只是要求了基地址和这种指针所指对象的内存大小，与对象的类型无关，相当于把指向的内存解释成指针或引用的类型。</li>
<li>而把一个派生类对象直接赋值给基类对象，就牵扯到对象的类型问题，编译器就会回避之前的的虚机制。从而无法实现多态。</li>
</ul>
<p>转载自<a href="https://blog.csdn.net/shichao1470/article/details/89893508">LupinLeo大佬的CSDN博客</a></p>
</blockquote>
<p>这个博文后续我还会记录C++多态的底层原理…未完待续…</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++知识点整理第一弹-基础篇</title>
    <url>/2021/03/09/C%E8%89%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%E7%AC%AC%E4%B8%80%E5%BC%B9-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="在main-执行前后的操作"><a href="#在main-执行前后的操作" class="headerlink" title="在main()执行前后的操作"></a>在main()执行前后的操作</h1><ul>
<li><p><code>main()</code>函数执行之前（主要是初始化系统相关资源）</p>
<ul>
<li>设置栈指针</li>
<li>初始化静态变量<code>static</code>以及全局变量<code>global</code>，也就是我们C++内存分区中的全局静态区区中的数据段</li>
<li>对未初始化的部分全局变量赋初值，即数值型赋值为<code>0</code>，布尔型赋值为<code>false</code>，指针赋值为<code>NULL</code>，也就是全局区中的BSS段</li>
<li>全局对象的初始化，调用其构造函数</li>
<li>将<code>main()</code>函数的参数传入<code>main()</code>函数中</li>
</ul>
</li>
<li><p><code>main()</code>函数执行之后</p>
<ul>
<li><p>全局对象的析构函数</p>
</li>
<li><p>用<code>atexit()</code>函数注册的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void func()&#123;</span><br><span class="line">	cout&lt;&lt;&quot;我在main()函数后才执行嗷嗷嗷！！&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	atexit(func);&#x2F;&#x2F;注册程序正常终止时被调用的函数</span><br><span class="line">	cout&lt;&lt;&quot;main exit&quot;;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><ul>
<li>类/结构体中的成员是按照声明顺序存储的，即第一个成员的地址和整个类/结构体的地址相同</li>
<li>类/结构体的字节大小是其最大的成员的整数倍，也就是说若有double成员，按8字节对齐</li>
</ul>
<h1 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><ul>
<li>指针是一个变量，存储着一个地址；引用是变量的一个别名，实质上是同一个东西。</li>
<li>指针可以多级（例如：<code>int** p</code>）；引用只有一级。</li>
<li>指针初始化时可以为空；引用在初始化时不能为空。</li>
<li>指针初始化后可以改变指向；引用在初始化后便不能再改变。</li>
<li>指针传入<code>sizeof()</code>函数得到的是指针的大小（64系统8字节，32位系统4字节）；引用传入<code>sizeof()</code>函数得到所指变量的大小。</li>
<li>指针作为参数传入函数时，也是把实参拷贝到形参（两者不是同一个变量），只不过两者指向的地址相同；引用作为参数传入函数时，是作为一个别名的存在（两者是同一个变量）。</li>
<li>指针的自增（++）是地址自增；引用的自增是变量的自增</li>
<li>指针作为函数返回，返回的是地址（指针常用来指向堆中的变量，函数结束时不会释放堆中的数据）；引用作为函数的返回，若返回局部变量的引用会报错（局部变量在函数结束时被释放了）</li>
</ul>
<h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><ul>
<li>申请方式：<ul>
<li>栈是系统自动分配的</li>
<li>堆是程序员自行申请和释放的</li>
</ul>
</li>
<li>申请大小限制：<ul>
<li>栈的大小都是操作系统设置好的，可以通过<code>ulimit -a</code>查看以及<code>ulimit -s</code>修改</li>
<li>堆是不连续的内存区域，大小可以灵活调整</li>
</ul>
</li>
<li>扩展方向：<ul>
<li>栈的扩展方向是从栈顶向栈底扩展</li>
<li>堆是向高地址扩展，是不连续的内存区域</li>
</ul>
</li>
<li>申请效率：<ul>
<li>栈由系统分配，速度快，没有碎片</li>
<li>堆由程序员分配，速度满而且由碎片</li>
</ul>
</li>
</ul>
<h1 id="区别指针类型"><a href="#区别指针类型" class="headerlink" title="区别指针类型"></a>区别指针类型</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p[10];</span><br><span class="line">int (*p)[10];</span><br><span class="line">int *p(int);</span><br><span class="line">int (*p)(int);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>int *p[10]</code>表示指针数组，我们可以看作是<code>int* p[10]</code>，表示10个整型指针数组</li>
<li><code>int (*p)[10]</code>表示数组指针，表示一个指针变量，指向一个元素个数为10的整型数组</li>
<li><code>int *p(int)</code>表示函数声明，我们可以看作是<code>int* p(int)</code>，表示函数名为p，参数为int类型，返回值为int*类型</li>
<li><code>int (*p)(int)</code>表示函数指针，表示指针指向一个函数，这个函数参数为int类型，返回值为int类型</li>
</ul>
<h1 id="C-的内存内存模型"><a href="#C-的内存内存模型" class="headerlink" title="C++的内存内存模型"></a>C++的内存内存模型</h1><ul>
<li>栈区</li>
<li>堆区</li>
<li>函数区</li>
<li>全局静态区</li>
<li>常量区</li>
</ul>
<h1 id="虚函数表存放的内存分区，虚表指针vptr的初始化时间"><a href="#虚函数表存放的内存分区，虚表指针vptr的初始化时间" class="headerlink" title="虚函数表存放的内存分区，虚表指针vptr的初始化时间"></a>虚函数表存放的内存分区，虚表指针vptr的初始化时间</h1><ul>
<li>虚函数表存放的内存分区：<ul>
<li>虚函数表是一个全局共享的元素，也就是说每个类全局只有一个虚函数表，在编译时便构造完毕</li>
<li>虚函数表类似一个数组，类对象存储的vptr指针指向虚函数表指针</li>
<li>虚函数表不是函数也不是程序代码，所以不可能存储在代码段</li>
<li>虚函数表存储着虚函数的地址，即虚函数表的元素指向类成员函数的地址，而类中虚函数的个数在编译时期就已经确定下来了，所以其不是动态分配内存空间存储虚函数表，也就是说不在堆区中</li>
<li>虚函数表类似于类中的静态成员变量（静态成员变量也是全局共享的，大小也是确定的），所以最有可能存放在全局数据区</li>
</ul>
</li>
</ul>
<blockquote>
<p>实际上，虚函数表vtable在Linux/Unix存放在可执行文件的只读数据段（也就是C++内存模型中的常量区）中；而微软的编译器将虚函数表存放在常量段。虚函数则存放在代码段（也就是C++内存模型中的函数区中）</p>
</blockquote>
<ul>
<li><p>虚表指针的初始化时间：</p>
<p>由于虚表指针和虚函数密切相关，对于有虚函数或继承于拥有虚函数基类的类的实例化时，在构造函数执行时便对虚表指针进行了初始化，并存放在对象内存布局的最前面</p>
</li>
</ul>
<h1 id="new-delete与malloc-free的异同"><a href="#new-delete与malloc-free的异同" class="headerlink" title="new/delete与malloc/free的异同"></a>new/delete与malloc/free的异同</h1><ul>
<li><p>相同点：</p>
<ul>
<li>用于内存的动态申请和释放</li>
</ul>
</li>
<li><p>不同点：</p>
<ul>
<li><p>new/delete是C++的运算符；malloc/free是C/C++语言标准库函数</p>
</li>
<li><p>new能自动计算需要分配的空间大小，无需程序员指定；malloc需要程序员指定大小</p>
</li>
<li><p>new是类型安全的；malloc则不是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int* p &#x3D; new float[2];&#x2F;&#x2F;分配失败时，编译会报错</span><br><span class="line">int* p &#x3D; (int*)malloc(2*sizeof(float));&#x2F;&#x2F;分配失败时，编译不会报错</span><br></pre></td></tr></table></figure></li>
<li><p>new运算符会调用<code>operator new()</code>标准库函数分配足够空间并调用相关对象的构造函数，<br>delete运算符会调用<code>operator delete()</code>标准库函数释放该对象所用内存；<br>malloc/free却没有相关调用</p>
</li>
<li><p>new/delete不需要库文件支持；malloc/free需要库文件的支持</p>
</li>
<li><p>new/delete除了分配释放内存外，还会调用构造和析构函数；malloc/free仅仅进行分配释放内存，不做其他操作</p>
<blockquote>
<p>new的底层封装了malloc，直接free不会报错，但仅仅释放了内存，对象并不会析构。</p>
</blockquote>
</li>
<li><p>new/delete支持<code>operator new()</code>/<code>operator delete()</code>函数的运算符重载以及函数覆写；malloc/free仅支持覆盖</p>
</li>
<li><p>new/delete返回的是具体类型的指针；malloc/free返回类型是void类型指针（必须进行类型转换）</p>
</li>
</ul>
</li>
</ul>
<h1 id="new和delete的实现过程"><a href="#new和delete的实现过程" class="headerlink" title="new和delete的实现过程"></a>new和delete的实现过程</h1><ul>
<li>new的实现过程：<ol>
<li>调用<code>operator new()</code>标准库函数，分配足够大的内存</li>
<li>运行构造函数</li>
<li>返回新分配内存并构造后的对象指针</li>
</ol>
</li>
<li>delete的实现过程<ol>
<li>对指针指向的对象运行析构函数</li>
<li>调用<code>operator delete()</code>标准库函数释放该对象所用内存</li>
</ol>
</li>
</ul>
<h1 id="delete和delete-的区别"><a href="#delete和delete-的区别" class="headerlink" title="delete和delete[]的区别"></a>delete和delete[]的区别</h1><ul>
<li>delete只会调用一次析构函数</li>
<li>delete[]会调用数组中每个元素的析构函数。</li>
</ul>
<h1 id="宏定义和函数的区别"><a href="#宏定义和函数的区别" class="headerlink" title="宏定义和函数的区别"></a>宏定义和函数的区别</h1><ul>
<li>宏函数在编译时完成替换，被替换的文本参与编译。相当于对代码进行直接文本替换，运行时不存在函数调用，执行更快；函数的调用需要在运行时跳转到具体的函数代码段，涉及到压栈出栈</li>
<li>宏定义属于在代码中直接替换文本，没有返回值；函数调用具有返回值</li>
<li>宏定义参数没有类型，不会进行类型检查；函数参数具有类型，需要检查类型</li>
<li>宏定义不要在最后加分号</li>
</ul>
<h1 id="宏定义和typedef区别"><a href="#宏定义和typedef区别" class="headerlink" title="宏定义和typedef区别"></a>宏定义和typedef区别</h1><ul>
<li>宏定义主要用于定义常量以及书写复杂的内容；typedef主要用于定义类型的别名</li>
<li>宏定义替换发生在编译阶段之前，属于对代码进行文本替换；typedef属于编译的一部分</li>
<li>宏定义不检查类型；typedef会检查数据类型</li>
<li>宏定义不是语句，最后不添加分号；typedef时语句，结束需要添加分号</li>
</ul>
<blockquote>
<p>注意对指针的操作：</p>
<ul>
<li><p>typedef char* p_char，例如：</p>
<ul>
<li>p_char c1,c2</li>
<li>效果等同于char* c1,char* c2,表示定义了两个字符型指针变量</li>
</ul>
</li>
<li><p>#define p_char char*，例如：</p>
<ul>
<li>p_char  c1,c2</li>
<li>效果等同于char* c1,c2,，表示定义了一个字符型指针变量和一个字符型变量</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="变量声明和定义的区别"><a href="#变量声明和定义的区别" class="headerlink" title="变量声明和定义的区别"></a>变量声明和定义的区别</h1><ul>
<li>声明仅仅是把变量声明的位置以及类型提供给编译器，并不会分配内存空间</li>
<li>定义会在定义的地方为其分配存储空间</li>
<li>相同变量可以在多处声明（外部变量extern）；但相同变量只能在一处定义</li>
</ul>
<h1 id="必须使用初始化成员列表的情况"><a href="#必须使用初始化成员列表的情况" class="headerlink" title="必须使用初始化成员列表的情况"></a>必须使用初始化成员列表的情况</h1><ul>
<li>初始化一个const成员</li>
<li>初始化一个reference成员</li>
<li>初始化基类的私有变量（调用基类的构造函数，而该函数有一组参数）</li>
<li>初始化数据成员对象的私有变量（调用数据成员对象的构造函数，而该函数有一组参数）</li>
</ul>
<h2 id="strlen-和sizeof-区别"><a href="#strlen-和sizeof-区别" class="headerlink" title="strlen()和sizeof()区别"></a>strlen()和sizeof()区别</h2><ul>
<li><code>sizeof()</code>是运算符，而非函数，结果在编译时得到而非在运行中获得；<code>strlen()</code>是字符处理的库函数</li>
<li><code>sizeof()</code>的参数可以是任何的数据类型或着数据；<code>strlen()</code>的参数只能是字符指针且结尾是<code>\0</code>的字符串</li>
</ul>
<blockquote>
<p>注意：因为<code>sizeof()</code>的值在编译时已确定，所以无法用来得到动态分配（运行时分配）存储空间的大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">	const char* str &#x3D; &quot;name&quot;;</span><br><span class="line">	sizeof(str);&#x2F;&#x2F;取的是指针的长度，大小为4</span><br><span class="line">	strlen(str);&#x2F;&#x2F;取的是字符串的长度，不包含结尾的&#39;\0&#39;，大小为4</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h1><ul>
<li>常量指针是一个指针，指向一个只读变量。<code>int const *p</code>或者<code>const int* p</code></li>
<li>指针常量是一个不能中途改变指向的指针，该指针是一个常量。<code>int* const p</code></li>
</ul>
<h1 id="a和-amp-a的区别"><a href="#a和-amp-a的区别" class="headerlink" title="a和&amp;a的区别"></a>a和&amp;a的区别</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">	int a[10];</span><br><span class="line">	int (*p)[10] &#x3D; &amp;a;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>a</code>是数组名，也是数组首元素的地址，<code>a+1</code>表示在地址值加上int类型的大小（即a = 0x00000001,a+1 = 0x00000005，<code>*(a+1)</code> == <code>a[1]</code>）</li>
<li><code>&amp;a</code>是数组的指针，其类型为<code>int (*)[10]</code>，<code>p+1</code>时，编译器会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素的后一个元素地址</li>
<li>若<code>(int*)p</code>，此时输出<code>*p</code>，值为a[0]的值，因为被转为<code>int *</code>类型，解引用时按照int类型大小来读取</li>
</ul>
<h1 id="数组名和指针的区别"><a href="#数组名和指针的区别" class="headerlink" title="数组名和指针的区别"></a>数组名和指针的区别</h1><ul>
<li>二者均可通过增减偏移量来访问数组中的元素</li>
<li>数组名不是真正意义上的指针，可以理解为指针常量，数组名无法自增、自减操作</li>
<li>当数组名当作形参传递给函数后，就失去了原有的特性，退化成一般指针，可以自增、自减的操作，而<code>sizeof()</code>运算符不能再得到原数组的大小了</li>
</ul>
<h1 id="野指针和悬空指针"><a href="#野指针和悬空指针" class="headerlink" title="野指针和悬空指针"></a>野指针和悬空指针</h1><blockquote>
<p>两者都是指向不安全不可控的内存区域。</p>
</blockquote>
<ul>
<li>野指针，指的是没有被初始化过的指针</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">	int* p;</span><br><span class="line">	&#x2F;&#x2F;为了防止出错，初始化时把指针赋值为nullptr，当我们误用时，编译器会直接报错</span><br><span class="line">	&#x2F;&#x2F;int* p &#x3D; nullptr;</span><br><span class="line">	cout&lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>悬空指针，指的是开始指向内存已被释放的指针</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">	int* p1 &#x3D; nullptr;</span><br><span class="line">	int* p2 &#x3D; new int(1);</span><br><span class="line">	p1 &#x3D; p2;</span><br><span class="line">	delete p2;</span><br><span class="line">	&#x2F;&#x2F;此时，p1和p2都是悬空指针，指向的内存已被释放，误用该两个指针，会产生不可控的现象。</span><br><span class="line">	&#x2F;&#x2F;为防止出现上述情况，在释放完内存空间后，手动将指针置为nullptr，当产生误用时，编译器会直接报错。</span><br><span class="line">	&#x2F;&#x2F;避免野指针比较简单，在C++11后，引入智能指针，能够比较简单容易的避免悬空指针的产生。</span><br><span class="line">	cout&lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：</p>
<p>野指针：</p>
<ul>
<li>产生原因：指针变量未及时初始化</li>
<li>解决方法：定义指针变量及时初始化或者置空</li>
</ul>
<p><br>悬空指针：</p>
<ul>
<li>产生原因：指针free获得delete后没有及时置空</li>
<li>解决方法：释放操作后立刻置空</li>
</ul>
</blockquote>
<h1 id="迭代器失效的情况"><a href="#迭代器失效的情况" class="headerlink" title="迭代器失效的情况"></a>迭代器失效的情况</h1><h2 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h2><blockquote>
<p>针对的是vector，deque</p>
</blockquote>
<ul>
<li><code>insert()</code>和<code>erase()</code>操作都会使迭代器失效</li>
</ul>
<h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><blockquote>
<p>针对的是map, set,multimap,multiset</p>
</blockquote>
<ul>
<li><code>insert()</code>不会使任何迭代器失效</li>
<li><code>erase()</code>会使指向删除位置的迭代器失效。但是不会使其他迭代器失效</li>
</ul>
<h2 id="链表式容器"><a href="#链表式容器" class="headerlink" title="链表式容器"></a>链表式容器</h2><blockquote>
<p>针对的是list</p>
</blockquote>
<ul>
<li><p><code>insert()</code>不会使任何迭代器失效</p>
</li>
<li><p><code>erase()</code>会使指向删除位置的迭代器失效。但是不会使其他迭代器失效</p>
</li>
</ul>
<h1 id="C-和C的区别"><a href="#C-和C的区别" class="headerlink" title="C++和C的区别"></a>C++和C的区别</h1><ul>
<li>C++中的new和delete是对内存分配的运算符，取代了C中的malloc和free</li>
<li>标准C++中的字符串类取代了标准C函数库头文件中的字符串处理函数（C中没有字符串类型）</li>
<li>C++中用来左控制台输入输出的iostream类库取代了标准C中的stdio函数库</li>
<li>C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数</li>
<li>C++允许有相同的函数名，不过它们的参数个数以及类型不能完全相同以便区分；C语言中不允许。换句话说，C++支持函数重载，C语言不支持函数重载</li>
<li>C++语言中，允许变量定义语句在程序中的任何地方，只要使用它之前都可以；而C语言必须在函数开头部分</li>
<li>C++中允许重复定义变量，而C语言做不到这一点</li>
<li>C++出了值和指针外还新增了引用；C语言中没有这个概念</li>
<li>C++相对于C新增了一些关键字（例如bool、using、dynamic_cast、namespace）</li>
</ul>
<h1 id="C-和Java的区别"><a href="#C-和Java的区别" class="headerlink" title="C++和Java的区别"></a>C++和Java的区别</h1><ul>
<li><p>语言特性</p>
<ul>
<li><p>Java语言给开发人员提供了更为简洁的语法；完全面向对象，由于JVM可以安装到任何操作系统上，所以它的可移植性非常强</p>
</li>
<li><p>Java语言中没有指针的概念，引入了真正的数组。不同于C++中利用指针实现的“伪数组”。同时Java把容易造成麻烦的指针从语言中去掉，这有利于预防C++程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题</p>
<blockquote>
<p>指针对于C++是一个优势也是一个劣势：</p>
<p>因为指针的存在可以直接对内存进行操作。</p>
<p>但是在带来便利的同时，也给程序带来的危害性以及复杂性。</p>
</blockquote>
</li>
<li><p>C++也可以在其他系统上运行，但是需要不同的编码，可移植性性和Java程序还是有差距的（例如：一个数字在windows下是大端存储，在unix中是小端存储。而Java程序生成字节码，在JVM里面运行得到结果）</p>
</li>
<li><p>Java用接口（interface）技术取代C++程序中的多继承性。接口和多继承有同样的功能，但是省却了多继承在实现和维护上复杂性。</p>
</li>
</ul>
</li>
<li><p>垃圾回收</p>
<ul>
<li>C++用析构函数回收垃圾，所以写C++程序时一定要注意内存的申请和释放</li>
<li>Java语言不使用指针，内存的分配和回收都是自动进行的，程序员无需考虑内存碎片的问题</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>Java在桌面程序上不如C++使用，因为C++可以直接编译成exe文件</li>
<li>Java在Web应用上具有C++无可比拟的优势，具有丰富多样的框架</li>
<li>对于底层程序的编程以及控制方面的编程，C++很灵活，因为有句柄的存在</li>
</ul>
</li>
</ul>
<h1 id="C-中struct和class的区别"><a href="#C-中struct和class的区别" class="headerlink" title="C++中struct和class的区别"></a>C++中struct和class的区别</h1><ul>
<li>相同点<ul>
<li>两者都拥有成员函数和公有、私有部分</li>
<li>任何可以在class完成的工作，同样可以使用struct完成</li>
</ul>
</li>
<li>不同点<ul>
<li>struct默认的访问权限是公有，class默认是私有</li>
<li>struct默认是public继承，class默认是private继承</li>
<li>class关键字可以作为模板类型，struct不行</li>
</ul>
</li>
</ul>
<h1 id="C-和C的struct区别"><a href="#C-和C的struct区别" class="headerlink" title="C++和C的struct区别"></a>C++和C的struct区别</h1><ul>
<li>C语言中的struct是用户自定义数据类型；C++中struct是抽象数据类型</li>
<li>C语言中的struct没有访问权限的设定，struct只能是多个变量的集合体，可以封装数据却不可以隐藏数据，而且成员不能是函数</li>
<li>C++中的struct增加了访问权限，可以和类一样有成员函数，成员默认访问权限是public（为了与C兼容）</li>
<li>C语言中，结构体的声明必须在结构体前加上struct，才能做结构体类型名；而C++可以直接使用结构体名作为结构体类型名</li>
</ul>
<h1 id="define和const的区别"><a href="#define和const的区别" class="headerlink" title="define和const的区别"></a>define和const的区别</h1><ul>
<li>define在编译之前的预处理阶段起作用，而const在编译、运行的时候起作用</li>
<li>define对代码做文本替代，不做类型检查和计算，也不求解，容易产生错误；而const常量有数据类型，编译器会对其进行类型安全检查</li>
<li>define只是对宏名称进行替换，在内存中会产生多份相同的备份；const在程序运行时只有一份备份</li>
<li>define定义的数据不会分配内存空间，而const定义的变量只是值不能改变，但会分配内存空间</li>
</ul>
<h1 id="const和static的作用"><a href="#const和static的作用" class="headerlink" title="const和static的作用"></a>const和static的作用</h1><ul>
<li><p>static</p>
<ul>
<li>不考虑类的情况<ul>
<li>隐藏。所有不加static的全局变量和函数都具有全局可见性，能够在其他文件中使用，static修饰以后只能在该文件的所有编译模块中使用</li>
<li>默认初始化为0，包括未初始化的全局静态变量和局部静态变量，都存在全局未初始化区</li>
<li>静态变量在函数内定义，始终存在，且只能初始化一次，具有记忆性，其作用范围与局部变量相同，但是函数退出后仍然存在，只是不可以使用而已</li>
</ul>
</li>
<li>考虑类的情况<ul>
<li>static成员变量<ul>
<li>只与类关联，不与类的对象关联</li>
<li>定义时要分配空间，不能在类中声明初始化，必须在类定义体外部初始化，初始化时不需要标记为static</li>
<li>可以被非static成员函数任意访问。</li>
</ul>
</li>
<li>static成员函数<ul>
<li>不具有this指针</li>
<li>无法访问类对象的非static成员变量和非static成员函数</li>
<li>不能被声明为const、虚函数和volatile</li>
<li>可以被非static成员函数任意访问</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>const</p>
<ul>
<li><p>不考虑类的情况</p>
<ul>
<li><p>const常量必须在定义时初始化，之后便无法修改</p>
</li>
<li><p>const形参可以接受const和非const类型的实参</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void func(const int&amp; i)&#123;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	const int num1 &#x3D; 1;</span><br><span class="line">	int num2 &#x3D; 2;</span><br><span class="line">	</span><br><span class="line">	func(num1);</span><br><span class="line">	func(num2);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>考虑类的情况</p>
<ul>
<li><p>const成员变量</p>
<ul>
<li>不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，所以必须有构造函数</li>
<li>不同类对const数据成员的数值可以不一样，所以不能在类中声明初始化</li>
</ul>
</li>
<li><p>const成员函数</p>
<ul>
<li><p>const修饰的成员函数表明该函数不会修改对象的数据成员</p>
</li>
<li><p>const对象不可以调用非const成员函数。非const对象则没有限制</p>
</li>
<li><p>不可以改变非mutable关键字修饰的成员变量的值</p>
<blockquote>
<p>mutable关键字：该关键字声明的变量表示可以在const成员函数中被修改</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h1><h2 id="概念区分"><a href="#概念区分" class="headerlink" title="概念区分"></a>概念区分</h2><ul>
<li>顶层const：表示const修饰的变量本身时一个常量，无法修改</li>
<li>底层const：表示const修饰得变量所指向的数据是一个常量</li>
</ul>
<h2 id="举栗"><a href="#举栗" class="headerlink" title="举栗"></a>举栗</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 10;</span><br><span class="line">int* const b1 &#x3D; &amp;a;&#x2F;&#x2F;顶层const，b1本身是一个常量</span><br><span class="line">const int* b2 &#x3D; &amp;a;&#x2F;&#x2F;底层const，b2所指的数据是一个常量</span><br><span class="line">const int b3 &#x3D; 20;&#x2F;&#x2F;顶层const，b3是常量不可变</span><br><span class="line">const int* const b4 &#x3D; &amp;a;&#x2F;&#x2F;前一个const是底层，后一个const是顶层，b4和b4指向的数据均不可变</span><br><span class="line">const int&amp; b5 &#x3D; a;&#x2F;&#x2F;用于声明引用变量，都是底层const。int&amp; b5本质其实就是int* const b5,指向均不能被改变</span><br></pre></td></tr></table></figure>
<h2 id="区分作用"><a href="#区分作用" class="headerlink" title="区分作用"></a>区分作用</h2><ul>
<li><p>执行对象拷贝时，底层const不能赋值给非底层const</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int num &#x3D; 3;</span><br><span class="line">const int* p1 &#x3D; &amp;num;</span><br><span class="line">&#x2F;&#x2F;int* p2 &#x3D; p1;  &#x2F;&#x2F;编译报错，不能将底层const指针赋值给非底层const的指针，如果能修改的话，以后不就可以通过该变量来修改数值了吗？</span><br><span class="line">const int* p3 &#x3D; p1;</span><br></pre></td></tr></table></figure></li>
<li><p>使用强制类型转换函数<code>const_cast()</code>时，需要能够分辨底层const和顶层const，因为<code>const_cast()</code>只能修改运算对象的底层const</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int num &#x3D; 4;</span><br><span class="line">const int* p1 &#x3D; &amp;num;</span><br><span class="line">&#x2F;&#x2F;*p1 &#x3D; 5;  &#x2F;&#x2F;编译报错，不能改变底层const指针指向的内容</span><br><span class="line">int* p2 &#x3D; const_cast&lt;int*&gt;(p1);&#x2F;&#x2F;正确，const_cast可以改变运算对象的底层const，但是使用时需要知道num不是const修饰</span><br><span class="line">*p1 &#x3D; 5;&#x2F;&#x2F;类型转换以后，非顶层const指针可以改变指向数据的内容了</span><br></pre></td></tr></table></figure></li>
<li><p><code>int const a</code>和<code>const int a</code>均表示定义整型常量a</p>
</li>
<li><p><code>const int* a</code>，可以看作<code>const</code>修饰的是<code>*a</code>，<code>*a</code>不能改变</p>
</li>
<li><p><code>int* const a</code>，可以看作<code>const</code>修饰的是<code>a</code>，<code>a</code>不能改变</p>
</li>
</ul>
<h1 id="类的对象存储空间"><a href="#类的对象存储空间" class="headerlink" title="类的对象存储空间"></a>类的对象存储空间</h1><ul>
<li>非静态成员的数据类型大小之和</li>
<li>编译器加入的额外成员变量（例如：指向虚函数表的指针）</li>
<li>为了边缘对齐优化加入的padding</li>
</ul>
<h1 id="override和final关键字"><a href="#override和final关键字" class="headerlink" title="override和final关键字"></a>override和final关键字</h1><ul>
<li><p>override<br>在父类中使用虚函数时，你可能需要在子类中对该虚函数进行重写，以下方面都可以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">	virtual void func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B : public A&#123;</span><br><span class="line">	void func();&#x2F;&#x2F;ok</span><br><span class="line">	virtual void func();&#x2F;&#x2F;ok</span><br><span class="line">	void func() override;&#x2F;&#x2F;ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果不适用overide关键字，当你的突然帕金森病发了，手不自觉抖了一抖，把<code>func()</code>写成了<code>fun()</code>会发生什么呢？结果编译器并不报错，因为它并不清楚你的目的是重写虚函数还是把它当作一个新函数。如果这个虚函数很重要的话，那就应该对整个程序不利。所以，override的作用就出来了，它指定的子类的这个虚函数就是重写父类的，如果你名字打错了，编译器就会给你报错提醒。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">	virtual void func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B : public A&#123;</span><br><span class="line">	virtual void fun();&#x2F;&#x2F;ok，这是B新增的函数，并不是继承的</span><br><span class="line">	void fun() override;&#x2F;&#x2F;报错，override修饰以后，这个函数必须继承自A，A找不到就报错给你看</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>final<br>当不希望某个类被继承时，或不希望某个虚函数被重写，可以在类名或虚函数后面添加final关键字，添加final关键字后被继承或者重写，编译器会报错。<br>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">    virtual void func();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class A : public Base</span><br><span class="line">&#123;</span><br><span class="line">    void func() final; &#x2F;&#x2F; foo 被override并且是最后一个override，在其子类中不可以重写</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class B final : public A &#x2F;&#x2F; 指明B是不可以被继承的</span><br><span class="line">&#123;</span><br><span class="line">    void func() override; &#x2F;&#x2F; Error: 在A中已经被final了</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class C : B &#x2F;&#x2F; Error: B is final</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="拷贝初始化和直接初始化"><a href="#拷贝初始化和直接初始化" class="headerlink" title="拷贝初始化和直接初始化"></a>拷贝初始化和直接初始化</h1><ul>
<li>当用类类型对象时，初始化的拷贝形式和直接形式有所不同<ul>
<li>直接初始化直接调用与实参匹配的构造函数，拷贝构造总是调用拷贝构造函数</li>
<li>拷贝初始化首先使用指定构造函数创建一个临时变量，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象中。</li>
</ul>
</li>
</ul>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string str1(&quot;I am a string&quot;);  &#x2F;&#x2F;直接初始化</span><br><span class="line">string str2(str1）; &#x2F;&#x2F;直接初始化，str1是已存在的对象，直接调用拷贝构造函数对str2进行初始化</span><br><span class="line">string str3 &#x3D; &quot;I am a string&quot;; &#x2F;&#x2F;拷贝初始化，先将字符串创建一个临时变量，在把临时对象作为参数，使用拷贝构造函数构造str3</span><br><span class="line">string str3 &#x3D; str1;  &#x2F;&#x2F;拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数</span><br></pre></td></tr></table></figure>
<ul>
<li>为了提升效率，允许编译器跳过创建临时对象这一步<ul>
<li>直接调用构造函数构造要创建的对象</li>
<li>这样就等价于直接初始化，不需要创建临时对象</li>
<li>但是需要辨别两种情况<ul>
<li>当拷贝函数为<code>private</code>时，使用拷贝初始化会编译报错</li>
<li>使用<code>explicit</code>修饰构造函数时，如果构造函数存在隐式转换，编译会报错</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="初始化和赋值的区别"><a href="#初始化和赋值的区别" class="headerlink" title="初始化和赋值的区别"></a>初始化和赋值的区别</h1><ul>
<li><p>对于基本类型来说，初始化和赋值没什么区别</p>
</li>
<li><p>对于类和复杂数据类型来说，这两者区别就来了，我们举一下栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    int num1;</span><br><span class="line">    int num2;</span><br><span class="line">public:</span><br><span class="line">    A(int a&#x3D;0, int b&#x3D;0):num1(a),num2(b)&#123;&#125;;</span><br><span class="line">    A(const A&amp; a)&#123;&#125;;</span><br><span class="line">    &#x2F;&#x2F;重载 &#x3D; 号操作符函数</span><br><span class="line">    A&amp; operator&#x3D;(const A&amp; a)&#123;</span><br><span class="line">        num1 &#x3D; a.num1 + 1;</span><br><span class="line">        num2 &#x3D; a.num2 + 1;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    A a(1,1);</span><br><span class="line">    A a1 &#x3D; a; &#x2F;&#x2F;拷贝初始化操作，调用拷贝构造函数</span><br><span class="line">    A b;</span><br><span class="line">    b &#x3D; a;&#x2F;&#x2F;赋值操作，对象a中，num1 &#x3D; 1，num2 &#x3D; 1；对象b中，num1 &#x3D; 2，num2 &#x3D; 2</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="extern”C“用法"><a href="#extern”C“用法" class="headerlink" title="extern”C“用法"></a>extern”C“用法</h1><ul>
<li><p>为了能够在C++代码中正确调用C语言的代码：在程序中加上extern ”C“后，相当于告诉编译器这部分代码是C语言进行编译，而非C++。哪些情况使用extern ”C“：</p>
<ul>
<li>C++代码中调用C语言代码</li>
<li>在C++中的头文件使用</li>
<li>带多个人协同开发，可能有人擅长C语言，而有人擅长C++</li>
</ul>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">    typedef unsigned int uint;</span><br><span class="line">    typedef void* void_s;</span><br><span class="line"> </span><br><span class="line">    void_s create_handle(const char* name);</span><br><span class="line">    uint operate_on_handle(void_s handle);</span><br><span class="line">    void close_handle(void_s handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern ”C“声明，在.c文件中包含extern ”C“时会出现编译语法错误。所以使用extern ”C“全部都放在cpp程序相关文件或头文件中。</p>
<ul>
<li>C++调用C函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;cfun.h,头文件声明</span><br><span class="line">int cfunc();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;cfun.c，c代码中定义</span><br><span class="line">int cfunc()&#123;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;xx.cpp，cpp代码中使用</span><br><span class="line">extern &quot;C&quot;	&#123;</span><br><span class="line">	#include &quot;cfun.h&quot;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cfunc();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>C调用C++函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;cppfun.h</span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">	int cppfun();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;cppfun.cpp</span><br><span class="line">int add()&#123;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;xx.c</span><br><span class="line">#include &quot;cfun.h&quot;</span><br><span class="line">extern int cppfun();</span><br><span class="line">int main()&#123;</span><br><span class="line">	cppfun();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="模板函数和模板类的特例化"><a href="#模板函数和模板类的特例化" class="headerlink" title="模板函数和模板类的特例化"></a>模板函数和模板类的特例化</h1><h2 id="引入原因"><a href="#引入原因" class="headerlink" title="引入原因"></a>引入原因</h2><p>编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时便需要模板特例化</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对单一模板提供的特殊实例，它将一个或多个模板参数绑定到特定的类型或值上</p>
<h2 id="模板函数特例化"><a href="#模板函数特例化" class="headerlink" title="模板函数特例化"></a>模板函数特例化</h2><p>必须为原函数模板中的每个模板参数都提供一个实参，且使用关键字<code>template&lt;&gt;</code>表明将原模板的所有模板参数提供实参<br>下面举栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">int compare(const T&amp; v1,const T&amp; v2)&#123;</span><br><span class="line">	if(v1&gt;v2) return -1;</span><br><span class="line">	if(v2&gt;v1) return 1;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">int compare(const char* const &amp;v1,const char* const &amp;v2)&#123;</span><br><span class="line">	return strcmp(v1,v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类模板特例化"><a href="#类模板特例化" class="headerlink" title="类模板特例化"></a>类模板特例化</h2><p>原理类似于函数模板，不是是在类中，我们可以对模板进行特例化，也可以对类进行部分特例。对类进行特例化时，仍然可以用<code>template&lt;&gt;</code>表示这是一个特例化版本<br>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Test&#123;</span><br><span class="line">public:</span><br><span class="line">	void print()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;General template object&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;   &#x2F;&#x2F; 对int型特例化</span><br><span class="line">class Test&lt;int&gt;&#123;</span><br><span class="line">public:</span><br><span class="line">	void print()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Specialized template object&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="类模板的部分特例化"><a href="#类模板的部分特例化" class="headerlink" title="类模板的部分特例化"></a>类模板的部分特例化</h3><p>不必为所有的模板参数提供实参，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参（特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配就用相应的模板）<br>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;&#x2F;general template</span><br><span class="line">template&lt;class T1, class T2&gt; </span><br><span class="line">class Test &#123;</span><br><span class="line">public:</span><br><span class="line">	void print()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;General template object&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;specialization with T2 set to int</span><br><span class="line">template&lt;class T1&gt;</span><br><span class="line">class Test&lt;T1, int&gt;  &#123;</span><br><span class="line">public:</span><br><span class="line">	void print()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Specialized template object&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<h3 id="特例化类的部分成员"><a href="#特例化类的部分成员" class="headerlink" title="特例化类的部分成员"></a>特例化类的部分成员</h3><p>可以特例化类中的部分成员函数而非整个类<br>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    void func();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">template&lt;&gt;</span><br><span class="line">void A&lt;int&gt;::func()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;进行int类型的特例化处理</span><br><span class="line">    cout &lt;&lt; &quot;我是int型特例化&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">A&lt;string&gt; a1;</span><br><span class="line">A&lt;int&gt; a2;&#x2F;&#x2F;使用特例化</span><br><span class="line">a1.func();&#x2F;&#x2F;使用的是普通模板，即A&lt;string&gt;::func()</span><br><span class="line">a2.func();&#x2F;&#x2F;特例化版本，执行A&lt;int&gt;::func()</span><br><span class="line">&#x2F;&#x2F;A&lt;string&gt;::func()A&lt;int&gt;::func()功能不同</span><br></pre></td></tr></table></figure>
<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><ul>
<li>特例化的本质就是实例化一个模板，而非重载它</li>
<li>特例化不影响参数匹配。参数匹配都是以最佳匹配为原则</li>
<li>举个栗子：compare(3,5)，调用普通的模板，若compare(“hello”,”jiajuu”)则调用特例化版本，因为<code>const char*</code>相对于T更匹配实参类型</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>模板和特例化版本都应该声明在同一个头文件中，且所有同名模板的声明都应该放在前面，后面放特例化版本</p>
<h1 id="C和C-的类型安全"><a href="#C和C-的类型安全" class="headerlink" title="C和C++的类型安全"></a>C和C++的类型安全</h1><h2 id="什么是类型安全"><a href="#什么是类型安全" class="headerlink" title="什么是类型安全"></a>什么是类型安全</h2><ul>
<li><p>类型安全很大程度上可以可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域</p>
</li>
<li><p>“类型安全”常被用来形容编程语言，其根据在于该编程语言是否提供保障类型安全的机制</p>
</li>
<li><p>有的时候也用”类型安全“形容某个程序，判断的标准在于该程序是否隐含类型错误</p>
</li>
<li><p>类型安全的编程语言与类型安全的程序之间没有必然的联系</p>
</li>
<li><p>好的程序员可以使用类型不那么安全的语言写出类型相当安全的程序</p>
</li>
<li><p>相反的，差的程序员可能使用类型相当安全的语言写出类型不太安全的程序</p>
</li>
<li><p>绝对类型安全的编程语言现在还暂时没有出现</p>
</li>
</ul>
<h2 id="C的类型安全"><a href="#C的类型安全" class="headerlink" title="C的类型安全"></a>C的类型安全</h2><ul>
<li><p>C只在局部上下文表现出类型安全</p>
</li>
<li><p>栗子：试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报错，除非使用显示类型转换</p>
</li>
<li><p>然而C语言中相当多的操作是不安全的，下面我们再举两个栗子：</p>
<ul>
<li><p>printf格式输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">	printf(&quot;整型输出：%d\n&quot;,10);  &#x2F;&#x2F;输出10</span><br><span class="line">	printf(&quot;符点型输出：%f\n&quot;,10);  &#x2F;&#x2F;输出0.000000</span><br><span class="line">	printf(&quot;字符型输出：%s\n&quot;,10);  &#x2F;&#x2F;运行时直接报错</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>malloc函数的返回值</p>
<ul>
<li><code>malloc()</code>是C中进行内存分配的函数，它的返回类型是<code>void *</code>空类型指针</li>
<li>所以我们经常需要这么使用<code>char* pStr=(char*)malloc(100*sizeof(char))</code>，我们可以看出明显做了显式的类型转换，类型匹配尚且没有问题</li>
<li>但是如果我们捣蛋地这么使用<code>int* pInt=(int*)malloc(100*sizeof(char))</code>，运行时可能会带来意想不到的后果，但这样的操作在C语言中并不会提醒你</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="C-的类型安全"><a href="#C-的类型安全" class="headerlink" title="C++的类型安全"></a>C++的类型安全</h2><p>如果C++使用得当，将远比C语言更有类型安全性。相比于C语言，C++提供了一些新的机制保障类型安全：</p>
<ul>
<li>操作符<code>new</code>返回的指针类型严格与对象匹配，而不是<code>void*</code></li>
<li>C语言中很多以<code>void *</code>为参数的函数可以改写为C++模板函数，而模板是支持类型检查的</li>
<li>引入<code>const</code>关键字代替<code>#define constants</code>，它是有类型、有作用域的，而<code>#define constants</code>只是简单的文本替换</li>
<li>一些#define宏可被改写为<code>inline</code>函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全</li>
<li>C++提供了<code>dynamic_cast</code>关键字，使得转换过程更加安全，因为<code>dynamic_cast</code>比<code>static_cast</code>涉及更多具体的类型检查。</li>
</ul>
<blockquote>
<p>若程序员使用不得当，也会引起类型不安全的问题，因此想保证程序的类型安全性，应该尽量避免使用空类型指针<code>void*</code>和不对两种类型指针做强制转换</p>
</blockquote>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;用空类型指针void*</span><br><span class="line">int main()&#123;</span><br><span class="line">	int i &#x3D; 5;</span><br><span class="line">	void* i_p &#x3D; &amp;5;</span><br><span class="line">	double d &#x3D; (*(double*)i_p);</span><br><span class="line">	cout&lt;&lt;d&lt;&lt;endl;&#x2F;&#x2F;输出1.78416e-307</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还不够，还来一个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Parent&#123;&#125;;</span><br><span class="line">class Child1 : public Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int i;</span><br><span class="line">	Child1(int e):i(e)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Child2 : public Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	double d;</span><br><span class="line">	Child2(double e):d(e)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Child1 c1(5);</span><br><span class="line">	Child2 c2(4.1);</span><br><span class="line">	Parent* pp;</span><br><span class="line">	Child1* pc1;</span><br><span class="line"> 	</span><br><span class="line">	pp&#x3D;&amp;c1; &#x2F;&#x2F;多态常进行的操作，没有问题！</span><br><span class="line">	pc1&#x3D;(Child1*)pp;  &#x2F;&#x2F; 类型向下转换 强制转换，由于类型仍然为Child1*，不造成错误</span><br><span class="line">	cout&lt;&lt;pc1-&gt;i&lt;&lt;endl; &#x2F;&#x2F;输出：5</span><br><span class="line">	&#x2F;&#x2F;child1 -&gt; parent -&gt; child1没问题</span><br><span class="line"> </span><br><span class="line">	pp&#x3D;&amp;c2;  &#x2F;&#x2F;多态常进行的操作，没有问题！</span><br><span class="line">	pc1&#x3D;(Child1*)pp;  &#x2F;&#x2F;强制转换，且类型发生变化，将造成错误</span><br><span class="line">	cout&lt;&lt;pc1-&gt;i&lt;&lt;endl;&#x2F;&#x2F; 输出：1717986918</span><br><span class="line">	&#x2F;&#x2F;child12 -&gt; parent -&gt; child1有问题</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="为什么析构函数一般写成虚函数"><a href="#为什么析构函数一般写成虚函数" class="headerlink" title="为什么析构函数一般写成虚函数"></a>为什么析构函数一般写成虚函数</h1><ul>
<li>由于类的多态性，基类指针可以指向派生类的对象</li>
<li>如果删除该基类的指针，就会调用该指针的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样下来整个派生类才完全被释放</li>
<li>如果析构函数不被声明成虚函数，则编译器只会静态绑定，在删除基类指针的时候，只会调用基类的析构函数，而不调用派生类的析构函数，进而造成派生类析构不完全造成内存泄漏。所以将析构函数声明成虚函数是非常必要的</li>
<li>在实现多态时，当用基类操作派生类，在析构时基类而不析构派生类的情况发生，要将基类的析构函数声明成虚函数</li>
</ul>
<p>举个没有写成虚函数的栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Parent&#123;</span><br><span class="line">public:</span><br><span class="line">	Parent()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Parent construct function&quot;  &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	~Parent()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Parent destructor function&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Son : public Parent&#123;</span><br><span class="line">public:</span><br><span class="line">	Son()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Son construct function&quot;  &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	~Son()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Son destructor function&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Parent* p &#x3D; new Son();</span><br><span class="line">	delete p;</span><br><span class="line">	p &#x3D; NULL;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;运行结果：</span><br><span class="line">&#x2F;&#x2F;Parent construct function</span><br><span class="line">&#x2F;&#x2F;Son construct function</span><br><span class="line">&#x2F;&#x2F;Parent destructor function</span><br></pre></td></tr></table></figure>
<p>举个写成虚函数的栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Parent&#123;</span><br><span class="line">public:</span><br><span class="line">	Parent()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Parent construct function&quot;  &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	virtual ~Parent()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Parent destructor function&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Son : public Parent&#123;</span><br><span class="line">public:</span><br><span class="line">	Son()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Son construct function&quot;  &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	~Son()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Son destructor function&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Parent* p &#x3D; new Son();</span><br><span class="line">	delete p;</span><br><span class="line">	p &#x3D; NULL;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;运行结果：</span><br><span class="line">&#x2F;&#x2F;Parent construct function</span><br><span class="line">&#x2F;&#x2F;Son construct function</span><br><span class="line">&#x2F;&#x2F;Son destructor function</span><br><span class="line">&#x2F;&#x2F;Parent destructor function</span><br></pre></td></tr></table></figure>


<h1 id="virtual能否声明构造和析构函数"><a href="#virtual能否声明构造和析构函数" class="headerlink" title="virtual能否声明构造和析构函数"></a>virtual能否声明构造和析构函数</h1><ul>
<li>析构函数<ul>
<li>析构函数必须可以声明为虚函数，不然虚析构函数怎么来的，一般情况下基类的析构析构函数都要定义成虚函数</li>
<li>只有在基类析构函数定义为虚函数时，调用操作符<code>delete</code>销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据</li>
<li>而且析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类可以根据需求重新改写基类的纯虚函数。</li>
</ul>
</li>
<li>构造函数<ul>
<li>构造函数不能定义为虚函数。因为虚函数需要vptr指针指向虚函数表，而vptr指针需要在构造函数被调用才会初始化，这就变成了一个死锁问题了呀(・∀・(・∀・(・∀・*)</li>
<li>构造函数能够调用虚函数，不过此时调用的虚函数是正在构造的类中的虚函数，而非子类的虚函数，因为此时子类尚未构造好</li>
</ul>
</li>
</ul>
<h1 id="重载、重写、隐藏的区别"><a href="#重载、重写、隐藏的区别" class="headerlink" title="重载、重写、隐藏的区别"></a>重载、重写、隐藏的区别</h1><ul>
<li><p>重载（overload）<br>重载是指同一范围定义的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和种类均相同，也不能仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关。举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual int fun();</span><br><span class="line">    void fun(int);</span><br><span class="line">    void fun(double, double);</span><br><span class="line">    static int fun(char);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>重写（override）<br>重写指的是在派生类中覆盖基类中的同名函数，重写就是重写函数体，而且要求：</p>
<ul>
<li>基类函数必须是虚函数</li>
<li>重写函数与基类的虚函数有相同的参数个数</li>
<li>重写函数与基类的虚函数有相同的参数类型</li>
<li>重写函数与基类的虚函数有相同的返回值类型</li>
</ul>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父类</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual int fun(int a)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;子类</span><br><span class="line">class B : public A&#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;重写,一般加override可以确保是重写父类的函数</span><br><span class="line">    virtual int fun(int a) override&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>重载和重写的区别：</p>
<ul>
<li>重载是不同函数之间的水平关系；重写是父类和子类的之间的垂直关系</li>
<li>重载要求参数列表不同，返回值不要求；重写要求参数列表相同</li>
<li>重载根据调用时实参表和形参表的对应关系来选择函数体；重写根据对象类型决定</li>
</ul>
</li>
<li><p>隐藏（hide）<br>隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：</p>
<ul>
<li><p>两个函数参数相同，但是基类函数不是虚函数（区别于重写时基类的函数是虚函数），举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父类</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    void fun(int a)&#123;</span><br><span class="line">		cout &lt;&lt; &quot;A中的fun函数&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;子类</span><br><span class="line">class B : public A&#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;隐藏父类的fun函数</span><br><span class="line">    void fun(int a)&#123;</span><br><span class="line">		cout &lt;&lt; &quot;B中的fun函数&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.fun(2); &#x2F;&#x2F;调用的是B中的fun函数</span><br><span class="line">    b.A::fun(2); &#x2F;&#x2F;调用A中fun函数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>两个函数的参数不同，无论基类函数是不是虚函数，都会被隐藏（区别于重载时两个函数在同一个类中），举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父类</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fun(int a)&#123;</span><br><span class="line">		cout &lt;&lt; &quot;A中的fun函数&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;子类</span><br><span class="line">class B : public A&#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;隐藏父类的fun函数</span><br><span class="line">   virtual void fun(char* a)&#123;</span><br><span class="line">	   cout &lt;&lt; &quot;A中的fun函数&quot; &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.fun(2); &#x2F;&#x2F;报错，调用的是B中的fun函数，参数类型不对</span><br><span class="line">    b.A::fun(2); &#x2F;&#x2F;调用A中fun函数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h1 id="C-多态的实现"><a href="#C-多态的实现" class="headerlink" title="C++多态的实现"></a>C++多态的实现</h1><ul>
<li>静态多态<ul>
<li>函数重载</li>
<li>运算符重载</li>
<li>复用函数名，编译阶段已确定了函数的地址，是编译时绑定，属于早绑定，。也叫编译时多态</li>
</ul>
</li>
<li>动态多态（我们常说的多态多指动态多态嗷！）<ul>
<li>派生类和虚函数共同实现的运行时多态</li>
<li>运行阶段才确定函数的地址，是运行时绑定，属于晚绑定，也叫运行时多态</li>
</ul>
</li>
</ul>
<blockquote>
<p>在基类的函数前加上<code>virtual</code>关键字，在派生类中重写该函数，运行时会根据所指对象的实际类型来调用相应的函数，如果对象是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。</p>
</blockquote>
<p>举个栗子吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void fun()&#123;</span><br><span class="line">		cout &lt;&lt; &quot; Base::func()&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Son1 : public Base&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void fun() override&#123;</span><br><span class="line">		cout &lt;&lt; &quot; Son1::func()&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Son2 : public Base&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Base* base &#x3D; new Son1;</span><br><span class="line">	base-&gt;fun();</span><br><span class="line">	base &#x3D; new Son2;</span><br><span class="line">	base-&gt;fun();</span><br><span class="line">	delete base;</span><br><span class="line">	base &#x3D; NULL;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 运行结果</span><br><span class="line">&#x2F;&#x2F; Son1::func()</span><br><span class="line">&#x2F;&#x2F; Base::func()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><ul>
<li><p>虚表：虚函数表的缩写，若类含有<code>virtual</code>关键字修饰的方法，编译器会全局生成一个虚函数表</p>
</li>
<li><p>虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的就是指向虚表的指针</p>
</li>
<li><p>基类对象的对象模型：</p>
<p><img src="http://jiajuu.top/2021/03/09/C%E8%89%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%E7%AC%AC%E4%B8%80%E5%BC%B9-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%9F%BA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png" alt="基类对象的对象模型"></p>
</li>
<li><p>派生类对象的对象模型：</p>
<p><img src="http://jiajuu.top/2021/03/09/C%E8%89%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%E7%AC%AC%E4%B8%80%E5%BC%B9-%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png" alt="派生类对象的对象模型"></p>
</li>
<li><p>实现多态的过程：</p>
<ol>
<li>编译器发现基类中含有虚函数时，自动为含有虚函数的类生成一个虚表，该表是一个一维数组，虚表里存储着虚函数的入口地址</li>
<li>编译器会为每个对象的前四个字节存储了一个虚表指针，即<code>vptr</code>，指向对象所属类的虚表<br>在构造时，会根据对象的类型区初始化虚表指针<code>vptr</code>，从而让<code>vptr</code>指向正确的虚表<br>从而在调用虚函数时，能够找到正确的函数</li>
<li>在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化<br>在构造子类对象时，会先调用父类的构造函数<br>此时编译器只”看到了“父类，并为父类对象初始化虚表指针，令其指向父类的虚表<br>当调用子类的构造函数时，为子类对象初始化虚表指针，令其指向子类虚表</li>
<li>当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的时基类的虚表<br>当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表<br>当派生类中有自己的虚函数时，在自己虚表中将此虚函数地址追加到虚表后面。</li>
</ol>
<blockquote>
<p>指向派生类的基类指针在运行时，就能够根据派生类对虚函数重写的情况动态进行调用了，从而实现多态。</p>
</blockquote>
</li>
</ul>
<h1 id="C-的构造函数"><a href="#C-的构造函数" class="headerlink" title="C++的构造函数"></a>C++的构造函数</h1><ul>
<li>默认构造函数</li>
<li>初始化构造函数（有参数）</li>
<li>拷贝构造函数</li>
<li>移动构造函数</li>
<li>委托构造函数</li>
<li>转换构造函数</li>
</ul>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Student&#123;</span><br><span class="line">public:</span><br><span class="line">    Student()&#123;&#x2F;&#x2F;默认构造函数，没有参数</span><br><span class="line">        this-&gt;age &#x3D; 20;</span><br><span class="line">        this-&gt;num &#x3D; 1000;</span><br><span class="line">    &#125;;  </span><br><span class="line">    Student(int a, int n):age(a), num(n)&#123;&#125;; &#x2F;&#x2F;初始化构造函数，有参数和参数列表</span><br><span class="line">    Student(const Student&amp; s)&#123;&#x2F;&#x2F;拷贝构造函数，这里与编译器生成的一致</span><br><span class="line">        this-&gt;age &#x3D; s.age;</span><br><span class="line">        this-&gt;num &#x3D; s.num;</span><br><span class="line">    &#125;; </span><br><span class="line">    &#x2F;&#x2F;一个构造函数接收一个不同于其类类型的形参，可以视为将其形参转换成类的一个对象。</span><br><span class="line">    Student(int r)&#123;   &#x2F;&#x2F;转换构造函数,形参是其他类型变量，且只有一个形参</span><br><span class="line">        this-&gt;age &#x3D; r;</span><br><span class="line">		this-&gt;num &#x3D; 1002;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Student()&#123;&#125;</span><br><span class="line">public:</span><br><span class="line">    int age;</span><br><span class="line">    int num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Student s1;</span><br><span class="line">    Student s2(18,1001);</span><br><span class="line">    int a &#x3D; 10;</span><br><span class="line">    Student s3(a);</span><br><span class="line">    Student s4(s3);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;s1 age:%d, num:%d\n&quot;, s1.age, s1.num);</span><br><span class="line">    printf(&quot;s2 age:%d, num:%d\n&quot;, s2.age, s2.num);</span><br><span class="line">    printf(&quot;s3 age:%d, num:%d\n&quot;, s3.age, s3.num);</span><br><span class="line">    printf(&quot;s2 age:%d, num:%d\n&quot;, s4.age, s4.num);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;运行结果</span><br><span class="line">&#x2F;&#x2F;s1 age:20, num:1000</span><br><span class="line">&#x2F;&#x2F;s2 age:18, num:1001</span><br><span class="line">&#x2F;&#x2F;s3 age:10, num:1002</span><br><span class="line">&#x2F;&#x2F;s2 age:10, num:1002</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作</li>
<li>复制构造函数用于复制本类的对象</li>
<li>转换构造函数用于将其他类型的变量，隐式转换为本类对象</li>
</ul>
</blockquote>
<h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><ul>
<li>浅拷贝</li>
</ul>
<p>浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。</p>
<ul>
<li>深拷贝</li>
</ul>
<p>深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。</p>
<ul>
<li>举个栗子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	int num;</span><br><span class="line">	char *name;</span><br><span class="line">public:</span><br><span class="line">	Student()&#123;</span><br><span class="line">        name &#x3D; new char(20);</span><br><span class="line">		cout &lt;&lt; &quot;Student&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">	~Student()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;~Student &quot; &lt;&lt; &amp;name &lt;&lt; endl;</span><br><span class="line">        delete name;</span><br><span class="line">        name &#x3D; NULL;</span><br><span class="line">    &#125;;</span><br><span class="line">	Student(const Student &amp;s)&#123;&#x2F;&#x2F;拷贝构造函数</span><br><span class="line">        &#x2F;&#x2F;浅拷贝，当对象的name和传入对象的name指向相同的地址</span><br><span class="line">        name &#x3D; s.name;</span><br><span class="line">        &#x2F;&#x2F;深拷贝</span><br><span class="line">        &#x2F;&#x2F;name &#x3D; new char(20);</span><br><span class="line">        &#x2F;&#x2F;memcpy(name, s.name, strlen(s.name));</span><br><span class="line">        cout &lt;&lt; &quot;copy Student&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#123;&#x2F;&#x2F; 花括号让s1和s2变成局部对象，方便测试</span><br><span class="line">		Student s1;</span><br><span class="line">		Student s2(s1);&#x2F;&#x2F; 复制对象</span><br><span class="line">	&#125;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;浅拷贝执行结果：</span><br><span class="line">&#x2F;&#x2F;Student</span><br><span class="line">&#x2F;&#x2F;copy Student</span><br><span class="line">&#x2F;&#x2F;~Student 0x7fffed0c3ec0</span><br><span class="line">&#x2F;&#x2F;~Student 0x7fffed0c3ed0</span><br><span class="line">&#x2F;&#x2F;*** Error in &#96;&#x2F;tmp&#x2F;815453382&#x2F;a.out&#39;: double free or corruption (fasttop): 0x0000000001c82c20 ***</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;深拷贝执行结果：</span><br><span class="line">&#x2F;&#x2F;Student</span><br><span class="line">&#x2F;&#x2F;copy Student</span><br><span class="line">&#x2F;&#x2F;~Student 0x7fffebca9fb0</span><br><span class="line">&#x2F;&#x2F;~Student 0x7fffebca9fc0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从执行结果可以看出，浅拷贝在对象的拷贝创建时存在风险，即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源，深拷贝的结果是两个对象之间没有任何关系，各自成员地址不同。</p>
</blockquote>
<h1 id="内联函数和宏定义"><a href="#内联函数和宏定义" class="headerlink" title="内联函数和宏定义"></a>内联函数和宏定义</h1><h2 id="内联函数介绍"><a href="#内联函数介绍" class="headerlink" title="内联函数介绍"></a>内联函数介绍</h2><p>内联(inline)函数和普通函数相比可以加快程序运行的速度，因为不需要中断调用，在编译的时候内联函数可以直接嵌入到目标代码中。</p>
<h2 id="内联函数适用场景"><a href="#内联函数适用场景" class="headerlink" title="内联函数适用场景"></a>内联函数适用场景</h2><ul>
<li>使用宏定义的地方都可以使用内联函数</li>
<li>作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率</li>
</ul>
<h2 id="为什么不能把所有函数都写成内联函数"><a href="#为什么不能把所有函数都写成内联函数" class="headerlink" title="为什么不能把所有函数都写成内联函数"></a>为什么不能把所有函数都写成内联函数</h2><ul>
<li>内联函数以代码复杂为代价，是空间换时间的手段，它以省去函数调用的开销来提高执行效率。</li>
<li>所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义了</li>
<li>另外一方面，每一处内联函数的调用都要复制代码，消耗更过的内存空间</li>
</ul>
<p>以下情况不适宜使用内联函数：</p>
<ul>
<li>函数体内的代码较长，将导致内存消耗代价</li>
<li>函数体内有循环，函数执行时间要比函数调用开销大</li>
</ul>
<h2 id="内联函数和宏定义区别"><a href="#内联函数和宏定义区别" class="headerlink" title="内联函数和宏定义区别"></a>内联函数和宏定义区别</h2><ul>
<li>内联函数在编译时展开；宏在预编译时展开</li>
<li>内联函数直接嵌入到目标代码中；宏是简单的做文本替换</li>
<li>内联函数有参数类型检测、语法判断等功能，且具有返回值；而宏没有</li>
<li>内联函数是函数，强调函数特性，具有重载等功能；宏不是函数</li>
<li>宏定义时要注意书写（参数要括起来）否则会出现歧义，内联函数不会产生歧义</li>
<li>内联函数代码是被放在符号表中，使用时像宏一样展开，没有调用的开销，效率很高</li>
<li>内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员，进而提效率；而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了</li>
</ul>
<h2 id="构造函数、析构函数、虚函数可否声明为内联函数"><a href="#构造函数、析构函数、虚函数可否声明为内联函数" class="headerlink" title="构造函数、析构函数、虚函数可否声明为内联函数"></a>构造函数、析构函数、虚函数可否声明为内联函数</h2><p>首先，需要表明的是将这些函数声明成内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联操作。</p>
<blockquote>
<p>register关键字：请求编译器尽可能的将变量存在CPU内部寄存器上，而不是通过内存寻址访问，以提高访问效率</p>
</blockquote>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    inline A() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;inline construct()&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">    inline ~A() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;inline destruct()&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">    inline virtual void  virtualFun() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;inline virtual function&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A a;</span><br><span class="line">	a.virtualFun();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">&#x2F;&#x2F;inline construct()</span><br><span class="line">&#x2F;&#x2F;inline virtual function</span><br><span class="line">&#x2F;&#x2F;inline destruct()</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数和析构函数声明为内联函数并没有意义</li>
</ul>
<p>《Effective C++》中阐述到：<strong>将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对函数声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象），导致构造函数/析构函数并不像看上去的那么精简。</strong>其次，class中函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数没有什么意义。</p>
<ul>
<li>虚函数声明为inline，需要分情况讨论</li>
</ul>
<p>有的人认为虚函数被声明为inline，但是编译器并没有对其内联，它们给出的理由是inline是编译时期决定的，但虚函数是运行期才决定的，所以编译时期并不知道运行时要调用哪条函数的情况下，虚函数声明inline并没有意义。</p>
<p>看似有点道理，其实并不全面。如果虚函数在编译器编译时期就能决定调用哪条函数的话，那么就能内联了，那什么情况下编译器在编译时期就能确定调用哪条函数呢？答案就是当用对象的指针指向本身调用虚函数（此时并不具有多态）时便可以内联展开</p>
<p>综上所述，得到的结论：</p>
<ol>
<li>当指向派生类的指针（具有多态性）调用声明为inline的虚函数，并不会内联展开</li>
<li>当指向本身类的指针（不具有多态性）调用声明inline的虚函数，可以内联展开，不过在这个函数并不复杂的前提下</li>
</ol>
<h1 id="auto、decltype和decltype-auto"><a href="#auto、decltype和decltype-auto" class="headerlink" title="auto、decltype和decltype(auto)"></a>auto、decltype和decltype(auto)</h1><ul>
<li>auto</li>
</ul>
<p>C++11标准引入的<code>auto</code>类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应某种特定的类型说明符不同，<b><code>auto</code>让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说<code>auto</code>定义的变量必须有初始值。</b></p>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;普通；类型</span><br><span class="line">int a &#x3D; 1, b &#x3D; 3;</span><br><span class="line">auto c &#x3D; a + b;&#x2F;&#x2F; c为int型</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;const类型</span><br><span class="line">const int i &#x3D; 5;</span><br><span class="line">auto j &#x3D; i; &#x2F;&#x2F; 变量i是顶层const, 会被忽略, 所以j的类型是int</span><br><span class="line">auto k &#x3D; &amp;i; &#x2F;&#x2F; 变量i是一个常量, 对常量取地址是一种底层const, 所以b的类型是const int*</span><br><span class="line">const auto l &#x3D; i; &#x2F;&#x2F;如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;引用和指针类型</span><br><span class="line">int x &#x3D; 2;</span><br><span class="line">int&amp; y &#x3D; x;</span><br><span class="line">auto z &#x3D; y; &#x2F;&#x2F;z是int型不是int&amp; 型</span><br><span class="line">auto&amp; p1 &#x3D; y; &#x2F;&#x2F;p1是int&amp;型</span><br><span class="line">auto p2 &#x3D; &amp;x; &#x2F;&#x2F;p2是指针类型int*</span><br></pre></td></tr></table></figure>
<ul>
<li>decltype</li>
</ul>
<p>有的时候我们还会遇到这种情况，<b>我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。</b>还有<b>可能是函数的返回类型是某表达式的值类型。</b>在这个时候<code>auto</code>就显得苍白无力，所以C++11又引入第二种类型说明<code>decltype</code>，<b>它可以选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值</b></p>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int func() &#123;return 0&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;普通类型</span><br><span class="line">decltype(func()) sum &#x3D; 5; &#x2F;&#x2F; sum的类型是函数func()的返回值的类型int, 但是这时不会实际调用函数func()</span><br><span class="line">int a &#x3D; 0;</span><br><span class="line">decltype(a) b &#x3D; 4; &#x2F;&#x2F; a的类型是int, 所以b的类型也是int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;不论是顶层const还是底层const, decltype都会保留   </span><br><span class="line">const int c &#x3D; 3;</span><br><span class="line">decltype(c) d &#x3D; c; &#x2F;&#x2F; d的类型和c是一样的, 都是顶层const</span><br><span class="line">int e &#x3D; 4;</span><br><span class="line">const int* f &#x3D; &amp;e; &#x2F;&#x2F; f是底层const</span><br><span class="line">decltype(f) g &#x3D; f; &#x2F;&#x2F; g也是底层const</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;引用与指针类型</span><br><span class="line">&#x2F;&#x2F;1. 如果表达式是引用类型, 那么decltype的类型也是引用</span><br><span class="line">const int i &#x3D; 3, &amp;j &#x3D; i;</span><br><span class="line">decltype(j) k &#x3D; 5; &#x2F;&#x2F; k的类型是 const int&amp;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:</span><br><span class="line">int i &#x3D; 3, &amp;r &#x3D; i;</span><br><span class="line">decltype(r + 0) t &#x3D; 5; &#x2F;&#x2F; 此时是int类型</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3. 对指针的解引用操作返回的是引用类型</span><br><span class="line">int i &#x3D; 3, j &#x3D; 6, *p &#x3D; &amp;i;</span><br><span class="line">decltype(*p) c &#x3D; j; &#x2F;&#x2F; c是int&amp;类型, c和j绑定在一起</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;4. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了</span><br><span class="line">int i &#x3D; 3;</span><br><span class="line">decltype((i)) j &#x3D; i; &#x2F;&#x2F; 此时j的类型是int&amp;类型, j和i绑定在了一起</span><br></pre></td></tr></table></figure>
<ul>
<li>decltype(auto)</li>
</ul>
<p><code>decltype(auto)</code>是C++14新增的类型指示符，可以用来声明变量以及指示函数返回类型。在使用时，又将等号左边的表达式替换掉<code>auto</code>，再根据<code>decltype</code>的语法规则来确定类型。</p>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int e &#x3D; 4;</span><br><span class="line">const int* f &#x3D; &amp;e; &#x2F;&#x2F; f是底层const</span><br><span class="line">decltype(auto) j &#x3D; f;&#x2F;&#x2F;j的类型是const int* 并且指向的是e</span><br></pre></td></tr></table></figure>


<h1 id="访问权限与继承权限"><a href="#访问权限与继承权限" class="headerlink" title="访问权限与继承权限"></a>访问权限与继承权限</h1><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><ul>
<li><code>public</code>修饰的变量和函数在类的内部外部都可以访问。</li>
<li><code>protected</code>修饰的变量和函数只能在类的内部和其派生类中访问。</li>
<li><code>private</code>修饰的元素只能在类内访问。</li>
</ul>
<p>派生类可以继承基类中除了构造/析构、赋值运算符重载函数之外的成员，但是这些成员的访问属性在派生过程中也是可以调整的。</p>
<p><img src="http://jiajuu.top/2021/03/09/C%E8%89%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%E7%AC%AC%E4%B8%80%E5%BC%B9-%E5%9F%BA%E7%A1%80%E7%AF%87/%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90.png" alt="访问权限"></p>
<blockquote>
<p>注意：外部访问并不是真正的外部访问，而是在通过派生类的对象对基类成员的访问。</p>
<ul>
<li>内部访问：由派生类中新增的成员函数对从基类继承来的成员的访问</li>
<li>外部访问：在派生类外部，通过派生类的对象对从基类继承来的成员的访问</li>
</ul>
</blockquote>
<h2 id="继承权限"><a href="#继承权限" class="headerlink" title="继承权限"></a>继承权限</h2><ul>
<li>public继承</li>
</ul>
<p>公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，都保持原有的状态，而基类的私有成员任然是私有的，不能被这个派生类的子类所访问</p>
<ul>
<li>protected继承</li>
</ul>
<p>保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元函数访问，基类的私有成员仍然是私有的</p>
<ul>
<li>private继承</li>
</ul>
<p>私有继承的特点是基类的所有公有成员和保护成员都成为派生类的私有成员，并不被它的派生类的子类所访问，基类的成员只能由自己派生类访问，无法再往下继承</p>
<h1 id="判断大小端存储"><a href="#判断大小端存储" class="headerlink" title="判断大小端存储"></a>判断大小端存储</h1><ul>
<li>大端存储：字数据的高字节存储在低地址</li>
<li>小段存储：字数据的低字节存储在低地址</li>
</ul>
<p>举个栗子：</p>
<p>我们有一个32位的数值——0x12345678</p>
<p>小端模式中的存储方式为：</p>
<p><img src="http://jiajuu.top/2021/03/09/C%E8%89%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%E7%AC%AC%E4%B8%80%E5%BC%B9-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.png" alt="小端模式存储方式"></p>
<p>大端模式中的存储方式为：</p>
<p><img src="http://jiajuu.top/2021/03/09/C%E8%89%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%E7%AC%AC%E4%B8%80%E5%BC%B9-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%A4%A7%E7%AB%AF%E6%A8%A1%E5%BC%8F%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.png" alt="大端模式存储方式"></p>
<p>判断方式：</p>
<ol>
<li>使用强制类型转换</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a &#x3D; 0x1234;</span><br><span class="line">    &#x2F;&#x2F;由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分</span><br><span class="line">    char c &#x3D; (char)(a);</span><br><span class="line">    if (c &#x3D;&#x3D; 0x12)</span><br><span class="line">        cout &lt;&lt; &quot;big endian&quot; &lt;&lt; endl;</span><br><span class="line">    else if(c &#x3D;&#x3D; 0x34)</span><br><span class="line">        cout &lt;&lt; &quot;little endian&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用union联合体</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值</span><br><span class="line">union endian</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char ch;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    endian value;</span><br><span class="line">    value.a &#x3D; 0x1234;</span><br><span class="line">    &#x2F;&#x2F;a和ch共用4字节的内存空间</span><br><span class="line">    if (value.ch &#x3D;&#x3D; 0x12)</span><br><span class="line">        cout &lt;&lt; &quot;big endian&quot;&lt;&lt;endl;</span><br><span class="line">    else if (value.ch &#x3D;&#x3D; 0x34)</span><br><span class="line">        cout &lt;&lt; &quot;little endian&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="volatile、mutable和explicit关键字"><a href="#volatile、mutable和explicit关键字" class="headerlink" title="volatile、mutable和explicit关键字"></a>volatile、mutable和explicit关键字</h1><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul>
<li><p><code>volatile</code>关键字是一种类型修饰符，<b>如果不用它声明的类型变量可以被某些编译器未知的元素更改</b>，例如：操作系统、硬件或者其他线程。如果变量经过<code>volatile</code>关键字修饰后，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p>
</li>
<li><p>当使用<code>volatile</code>关键字声明变量的值时，<b>系统总是重新从它所在的内存读取数据</b>，即便它前面的指令刚刚从该处读取过数据</p>
</li>
<li><p><b><code>volatile</code>关键字修饰的变量的值是易变的，每次用到这个变量的值时都要去内存重新读取该变量的值，而不是直接读寄存器内的备份。多线程中被几个任务共享的变量需要需要被修饰为<code>volatile</code></b></p>
</li>
<li><p>volatile指针</p>
<ul>
<li><p>volatile指针和const修饰词类似，const有常量指针和指针常量的说法，volatile也有类似的概率</p>
</li>
<li><p>修饰指针指向的对象、数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const char* cp;</span><br><span class="line">volatile char* vp;</span><br></pre></td></tr></table></figure></li>
<li><p>修饰指针自身</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char* const cp;</span><br><span class="line">char* volatile vp;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ol>
<li>可以把非volatile int赋值给volatile int，但是不能把非volatile对象赋给一个volatile对象。</li>
<li>除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。</li>
<li>C++中有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获取对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p>多线程下的volatile</p>
<p>部分变量使用volatile关键字声明的。当两个线程都要用到某个变量且该变量会被改变时，应该用volatile声明，<b>该关键字的作用是预防编译器把变量优化，从内存装入CPU寄存器中。</b>如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器的变量，这将造成程序的错误执行。<b>volatile的作用便是让编译器每次操作该变量都一定从内存中取出，而不是使用已经存在寄存器中的值。</b></p>
</li>
</ul>
<h2 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h2><ul>
<li><code>mutable</code>关键字和<code>const</code>关键字的意思正好相反，表示”可变的“</li>
<li>在C++中，<code>mutable</code>关键字是为了突破<code>const</code>的限制而设置的。被<code>mutable</code>关键字修饰的变量，将永远处于可变的状态，即使在一个const函数中</li>
<li>我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明<code>const</code></li>
<li>但有时候我们需要在<code>const</code>修饰的函数中修改一些和类状态的数据成员，那么这个就应该被<code>mutable</code>来修饰。</li>
</ul>
<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p><code>explicit</code>关键字用来修饰类的构造函数，被修饰构造函数的类，不能发生相应的隐式类型转换，只能以显式方式进行类型转换</p>
<p>注意：</p>
<ul>
<li><code>explicit</code>关键字只能用于类内部的构造函数声明上</li>
<li><code>explicit</code>关键字作用域单个参数的构造函数</li>
<li>被<code>explicit</code>修饰的构造函数的类，不能发生相应的隐式类型转换</li>
</ul>
<h1 id="调用拷贝构造函数的情况"><a href="#调用拷贝构造函数的情况" class="headerlink" title="调用拷贝构造函数的情况"></a>调用拷贝构造函数的情况</h1><ul>
<li><p>用类的实例化对象去初始化类的另一个对象</p>
</li>
<li><p>函数的参数是类的对象时（非引用传递）</p>
</li>
<li><p>函数的返回值是函数体内局部对象时，由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数</p>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	A() &#123;&#125;;</span><br><span class="line">	A(const A&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;copy constructor is called&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	~A() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void useClassA(A a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">A getClassA()&#x2F;&#x2F;此时会发生拷贝构造函数的调用，虽然发生NRV优化，但是依然调用拷贝构造函数</span><br><span class="line">&#123;</span><br><span class="line">	A a;</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;A&amp; getClassA2()  &#x2F;&#x2F;VS2019下，此时编辑器会进行（Named return Value优化）NRV优化,不调用拷贝构造函数 ，如果是引用传递的方式返回当前函数体内生成的对象时，并不发生拷贝构造函数的调用</span><br><span class="line">&#x2F;&#x2F;&#123;</span><br><span class="line">&#x2F;&#x2F;	A a;</span><br><span class="line">&#x2F;&#x2F;	return a;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A a1, a2,a3,a4;</span><br><span class="line">	A a2 &#x3D; a1;  &#x2F;&#x2F;调用拷贝构造函数,对应情况1</span><br><span class="line">	useClassA(a1);&#x2F;&#x2F;调用拷贝构造函数，对应情况2</span><br><span class="line">	a3 &#x3D; getClassA();&#x2F;&#x2F;发生NRV优化，但是值返回，依然会有拷贝构造函数的调用 情况3</span><br><span class="line">	a4 &#x3D; getClassA2(a1);&#x2F;&#x2F;发生NRV优化，且引用返回自身，不会调用拷贝构造函数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>情况1就直接调用拷贝构造函数</li>
<li>情况2的过程是调用函数时根据参入的实参生成一个临时对象，再用拷贝构造函数去初始化这个临时对象，函数调用结束后析构临时对象</li>
<li>情况3在执行return时，会首先生成一个临时对象，调用拷贝构造函数把返回对象拷贝给临时对象，函数执行完先析构局部变量，在析构临时变量，依然会调用拷贝构造函数</li>
</ol>
</blockquote>
</li>
</ul>
<h1 id="new的不同类型"><a href="#new的不同类型" class="headerlink" title="new的不同类型"></a>new的不同类型</h1><ul>
<li>plain new</li>
<li>nothrow new</li>
<li>placement new</li>
</ul>
<h2 id="plain-new"><a href="#plain-new" class="headerlink" title="plain new"></a>plain new</h2><p>其实就是我们常用的new，我们最普通的new</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void* operator new(std::size_t) throw(std::bad_alloc);</span><br><span class="line">void operator delete(void *) throw();</span><br></pre></td></tr></table></figure>
<p>因此plain new在空间分配失败的情况下，会抛出std::bad_alloc异常，而非返回NULL，因此不能通过返回值是否为NULL来判断是否分配成功，我们举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	try</span><br><span class="line">	&#123;</span><br><span class="line">		char *p &#x3D; new char[10e11];</span><br><span class="line">		delete p;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (const std::bad_alloc &amp;ex)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; ex.what() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;执行结果：bad allocation</span><br></pre></td></tr></table></figure>
<h2 id="nothrow-new"><a href="#nothrow-new" class="headerlink" title="nothrow new"></a>nothrow new</h2><p>nothrow new在空间分配失败时不会抛出异常，而是返回NULL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void * operator new(std::size_t,const std::nothrow_t&amp;) throw();</span><br><span class="line">void operator delete(void*) throw();</span><br></pre></td></tr></table></figure>
<p>所以可以通过返回值是否为NULL来判断是否分配成功，我们举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char *p &#x3D; new(nothrow) char[10e11];</span><br><span class="line">	if (p &#x3D;&#x3D; NULL) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;alloc failed&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	delete p;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;运行结果：alloc failed</span><br></pre></td></tr></table></figure>
<h2 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h2><p>允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void* operator new(size_t,void*);</span><br><span class="line">void operator delete(void*,void*);</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>主要作用就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组</li>
<li>placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。</li>
</ul>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class ADT&#123;</span><br><span class="line">	int i;</span><br><span class="line">	int j;</span><br><span class="line">public:</span><br><span class="line">	ADT()&#123;</span><br><span class="line">		i &#x3D; 10;</span><br><span class="line">		j &#x3D; 100;</span><br><span class="line">		cout &lt;&lt; &quot;ADT construct i&#x3D;&quot; &lt;&lt; i &lt;&lt; &quot;j&#x3D;&quot;&lt;&lt;j &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~ADT()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;ADT destruct&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char *p &#x3D; new(nothrow) char[sizeof ADT + 1];</span><br><span class="line">	if (p &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;alloc failed&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	ADT *q &#x3D; new(p) ADT;  &#x2F;&#x2F;placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可</span><br><span class="line">	&#x2F;&#x2F;delete q;&#x2F;&#x2F;错误!不能在此处调用delete q;</span><br><span class="line">	q-&gt;ADT::~ADT();&#x2F;&#x2F;显示调用析构函数</span><br><span class="line">	delete[] p;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">&#x2F;&#x2F;ADT construct i&#x3D;10j&#x3D;100</span><br><span class="line">&#x2F;&#x2F;ADT destruct</span><br></pre></td></tr></table></figure>




<h1 id="NULL和nullptr的区别"><a href="#NULL和nullptr的区别" class="headerlink" title="NULL和nullptr的区别"></a>NULL和nullptr的区别</h1><ul>
<li>NULL来自于C语言，一般由宏定义实现，而nullptr则是C++11新增的关键字</li>
<li>C语言中，NULL被定义为(void*)0，而在C++中NULL被定义为整型0</li>
</ul>
<blockquote>
<p>可能有同学会问：为什么C++不能把NULL也定义成(void*)0呢？</p>
<p><br>首先我们了解背景故事：</p>
<ol>
<li>在C和C++中，特定指针可以赋值给通用指针，用于临时储存地址，但缺点是：<ol>
<li>因为没有类型，无法确定内存发小，所以不能解引用</li>
<li>无法调整权重，所以不能进行算数运算（例如：p++）</li>
</ol>
</li>
<li>在C中，通用指针可以赋值给特定指针；但在C++中通用指针不能赋值给特定指定，这是给了杜绝不同类型的指针相互赋值</li>
</ol>
<p>看完背景故事我们大概就清楚了！</p>
<p><br>答：我们假如C++NULL也是(void*)0，则<code>int* p = NULL</code>相当与<code>int* p = (void*) 0</code>，但是这会在C++中编译是无法通过的，因为C++中通用指针不可以赋值给特定指针，所以为了兼容C语言，NULL被规定为0；</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifdef __cplusplus</span><br><span class="line">#define NULL 0</span><br><span class="line">#else</span><br><span class="line">#define NULL ((void *)0)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<ul>
<li>在C++中指针必须有明确的类型定义，因为C++允许有函数重载的特性，所以将NULL定义为整型0会带来一个无法与整数0区分的问题。举个栗子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void fun(char* p) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;char*&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun(int p) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;int&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	fun(NULL);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果：int</span><br></pre></td></tr></table></figure>
<ul>
<li>为了解决这个问题，C++11引入了nullptr关键字，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。nullptr的实现方式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const class nullptr_t&#123;</span><br><span class="line">public:</span><br><span class="line">    template&lt;class T&gt;  inline operator T*() const&#123; return 0; &#125;</span><br><span class="line">    template&lt;class C, class T&gt; inline operator T C::*() const &#123; return 0; &#125;</span><br><span class="line">private:</span><br><span class="line">    void operator&amp;() const;</span><br><span class="line">&#125; nullptr &#x3D; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过模板类和运算符重载对不同类型的指针进行实例化，从而解决了(void*)指针带来参数类型不明的问题<br>且由于nullptr明确了指针类型，所以不会与整型变量相混淆</p>
</blockquote>
<ul>
<li>但是nullptr仍然存在一定的问题，我们再举出一个栗子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void fun(char* p)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt; &quot;char* p&quot; &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void fun(int* p)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt; &quot;int* p&quot; &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun(int p)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt; &quot;int p&quot; &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    fun((char*)nullptr);&#x2F;&#x2F;语句1</span><br><span class="line">	fun(nullptr);&#x2F;&#x2F;语句2</span><br><span class="line">    fun(NULL);&#x2F;&#x2F;语句3</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;运行结果：</span><br><span class="line">&#x2F;&#x2F;语句1：char* p</span><br><span class="line">&#x2F;&#x2F;语句2:报错，有多个匹配</span><br><span class="line">&#x2F;&#x2F;3：int p</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这种情况下存在对不同指针类型的函数重载，此时如果传入nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的指明参数类型。</p>
</blockquote>
<h1 id="C-内存分区"><a href="#C-内存分区" class="headerlink" title="C++内存分区"></a>C++内存分区</h1><ul>
<li>堆</li>
</ul>
<p>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时，这些存储单元自动被释放，栈内存分配运行内置于处理器的指令集中，所以效率很高，但分配的内存容量有限</p>
<ul>
<li>栈</li>
</ul>
<p>就是那些由new分配的内存块，编译器不需要管这块内存块的释放，由程序员手动释放，所以一般一个new便对应一个delete。如果程序员没有释放，那么在程序结束后，操作系统会自动回收</p>
<ul>
<li>全局/静态存储区</li>
</ul>
<p>全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分，它们共同占用同一块内存区，在该区定义的变量若没有初始化也会被自动初始化（例如：int型会被初始化为0）。</p>
<ul>
<li>常量存储区</li>
</ul>
<p>这是一块比较特殊的存储区，里面存放着常量，不允许修改</p>
<ul>
<li>代码区</li>
</ul>
<p>存放函数体的二进制代码</p>
<p><img src="http://jiajuu.top/2021/03/09/C%E8%89%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%E7%AC%AC%E4%B8%80%E5%BC%B9-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png" alt="内存分区"></p>
<h1 id="异常处理的方法"><a href="#异常处理的方法" class="headerlink" title="异常处理的方法"></a>异常处理的方法</h1><h2 id="try、throw和catch关键字"><a href="#try、throw和catch关键字" class="headerlink" title="try、throw和catch关键字"></a>try、throw和catch关键字</h2><ul>
<li>程序的执行流程是先执行try包裹的语句块</li>
<li>如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块</li>
<li>如果发生异常，则使用throw进行异常抛出，再由catch进行捕获</li>
<li>throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class</li>
<li><b>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(…)的方式捕获任何异常（不推荐）</b></li>
<li>如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。</li>
</ul>
<p>我们举一个主要用法的栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    double m &#x3D; 1, n &#x3D; 0;</span><br><span class="line">    try &#123;</span><br><span class="line">        cout &lt;&lt; &quot;before dividing.&quot; &lt;&lt; endl;</span><br><span class="line">        if (n &#x3D;&#x3D; 0)</span><br><span class="line">            throw - 1;  &#x2F;&#x2F;抛出int型异常</span><br><span class="line">        else if (m &#x3D;&#x3D; 0)</span><br><span class="line">            throw - 1.0;  &#x2F;&#x2F;拋出 double 型异常</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; m &#x2F; n &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;after dividing.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (double d) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;catch (double)&quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (...) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;catch (...)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;finished&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;运行结果</span><br><span class="line">&#x2F;&#x2F;before dividing.</span><br><span class="line">&#x2F;&#x2F;catch (...)</span><br><span class="line">&#x2F;&#x2F;finished</span><br></pre></td></tr></table></figure>
<h2 id="函数的异常声明列表"><a href="#函数的异常声明列表" class="headerlink" title="函数的异常声明列表"></a>函数的异常声明列表</h2><p>有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，举栗：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int fun() throw(int,double,A,B,C)&#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>这种写法表明函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常</p>
<h2 id="C-标准异常类"><a href="#C-标准异常类" class="headerlink" title="C++标准异常类"></a>C++标准异常类</h2><p>C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的</p>
<p><img src="http://jiajuu.top/2021/03/09/C%E8%89%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%E7%AC%AC%E4%B8%80%E5%BC%B9-%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8%E7%B1%BB.jpg" alt="标准异常类"></p>
<ul>
<li>bad_typeid</li>
</ul>
<p>使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常，我们拿出栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">  virtual ~A();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	A* a &#x3D; NULL;</span><br><span class="line">	try &#123;</span><br><span class="line">  		cout &lt;&lt; typeid(*a).name() &lt;&lt; endl; &#x2F;&#x2F; Error condition</span><br><span class="line">  	&#125;</span><br><span class="line">	catch (bad_typeid)&#123;</span><br><span class="line">  		cout &lt;&lt; &quot;Object is NULL&quot; &lt;&lt; endl;</span><br><span class="line">  	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;运行结果：bject is NULL</span><br></pre></td></tr></table></figure>
<ul>
<li>bad_cast</li>
</ul>
<p>在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常，拿出栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;typeinfo.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">class Shape &#123;</span><br><span class="line">public:</span><br><span class="line">   virtual void virtualfunc() const &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class Circle: public Shape &#123;</span><br><span class="line">public:</span><br><span class="line">   virtual void virtualfunc() const &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">   Shape shape_instance;</span><br><span class="line">   Shape&amp; ref_shape &#x3D; shape_instance;</span><br><span class="line">   try &#123;</span><br><span class="line">      Circle&amp; ref_circle &#x3D; dynamic_cast&lt;Circle&amp;&gt;(ref_shape); </span><br><span class="line">   &#125;</span><br><span class="line">   catch (bad_cast b) &#123;</span><br><span class="line">      cout &lt;&lt; &quot;Caught: &quot; &lt;&lt; b.what();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>bad_alloc</li>
</ul>
<p>在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常</p>
<ul>
<li>out_of_range</li>
</ul>
<p>用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote>
<p>转载自<a href="https://github.com/forthespada/InterviewGuide">https://github.com/forthespada/InterviewGuide</a>，感激大佬的整理和分享！</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++知识点整理第三弹-提高篇</title>
    <url>/2021/03/25/C%E8%89%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%E7%AC%AC%E4%B8%89%E5%BC%B9-%E6%8F%90%E9%AB%98%E7%AF%87/</url>
    <content><![CDATA[<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>抽象类是一种特殊的类，为了抽象以及设计的目的而引入，处于继承层次结构的较上层</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>带有纯虚函数的类为抽象类</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>将相关的操作作为接口组织在继承层次结构中</li>
<li>能为派生类提供一个公共的根，派生类需要将具体的实现其基类中作为接口的操作</li>
<li>抽象类为派生类刻画了一系列的操作结构通用语义</li>
<li>派生类需要按照语义具体实现，也可再将这些语义传给自己的子类</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。</li>
<li>如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。</li>
<li>如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</li>
<li>抽象类是不能定义对象的。一个纯虚函数不需要（但是可以）被定义。</li>
</ul>
<h1 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtual void func() &#x3D; 0;</span><br></pre></td></tr></table></figure>
<ul>
<li>在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</li>
<li>纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。</li>
<li>凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。</li>
<li>除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。</li>
</ul>
<h2 id="引入原因"><a href="#引入原因" class="headerlink" title="引入原因"></a>引入原因</h2><ul>
<li>为了方便使用多态特性，我们常常需要在基类中定义虚函数。</li>
<li>在很多情况下，基类本身生成对象是不合情理的。<br>例如，动物作为一个基类可以派生出老虎、孔 雀等子类，但动物本身生成对象明显不合常理。<br>为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数。</li>
<li>若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。</li>
<li>同时含有纯虚函数的类称为抽象类，它不能生成对象。</li>
</ul>
<h1 id="继承机制中对象间转换"><a href="#继承机制中对象间转换" class="headerlink" title="继承机制中对象间转换"></a>继承机制中对象间转换</h1><h2 id="向上类型转换"><a href="#向上类型转换" class="headerlink" title="向上类型转换"></a>向上类型转换</h2><ul>
<li>将派生类指针或引用转换为基类的指针或引用被称为向上类型转换</li>
<li>向上类型转换会自动进行</li>
<li>而且向上类型转换是安全的。</li>
</ul>
<h2 id="向下类型转换"><a href="#向下类型转换" class="headerlink" title="向下类型转换"></a>向下类型转换</h2><ul>
<li>将基类指针或引用转换为派生类指针或引用被称为向下类型转换</li>
<li>向下类型转换不会自动进行</li>
<li>因为一个基类对应几个派生类，向下类型转换时不知道对应哪个派生类</li>
<li>所以在向下类型转换时必须加动态类型识别技术（RTTI技术），用dynamic_cast进行向下类型转换。</li>
</ul>
<h1 id="组合和继承"><a href="#组合和继承" class="headerlink" title="组合和继承"></a>组合和继承</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li><p>继承是Is a 的关系</p>
</li>
<li><p>比如说Student继承Person,则说明Student is a Person。</p>
</li>
<li><p>继承的优点是子类可以重写父类的方法来方便地实现对父类的扩展。</p>
</li>
</ul>
<p><b>缺点：</b></p>
<ol>
<li>父类的内部细节对子类是可见的。</li>
<li>子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。</li>
<li>如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。</li>
</ol>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><ul>
<li>组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。</li>
</ul>
<p><b>优点：</b></p>
<ol>
<li>当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。</li>
<li>当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。</li>
<li>当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。</li>
</ol>
<p><b>缺点：</b></p>
<ol>
<li>容易产生过多的对象。</li>
<li>为了能组合多个对象，必须仔细对接口进行定义。</li>
</ol>
<h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><p>函数指针指向的是特殊的数据类型，函数的类型是由其返回的数据类型和其参数列表共同决定的，而函数的名称则不是其类型的一部分。</p>
<h2 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int (*pf)(const int&amp;, const int&amp;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的pf就是一个函数指针，指向所有返回类型为int，并带有两个const int&amp;参数的函数。注意*pf两边的括号是必须的</p>
</blockquote>
<p>注意区分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *pf(const int&amp;, const int&amp;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>声明了一个函数pf，其返回类型为int *， 带有两个const int&amp;参数。</p>
</blockquote>
<h2 id="引入原因-1"><a href="#引入原因-1" class="headerlink" title="引入原因"></a>引入原因</h2><ul>
<li>将函数作为参数传递给函数</li>
</ul>
<blockquote>
<p>函数名其实就是一个指针，它指向函数的代码，而函数地址就是该函数的入口。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。</p>
</blockquote>
<h2 id="赋值方式"><a href="#赋值方式" class="headerlink" title="赋值方式"></a>赋值方式</h2><ul>
<li>指针名 = 函数名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int Max_Int(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	return (a&gt;b)?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int (*pFun)(int a, int b);  &#x2F;&#x2F;声明函数指针，此时函数指针没有指向任何函数</span><br><span class="line">	pFun &#x3D; Max_Int;  &#x2F;&#x2F;函数指针指向Max_Int函数</span><br><span class="line">	int max1 &#x3D; (*pFun)(5,8);  &#x2F;&#x2F;使用函数指针引用Max_Int函数</span><br><span class="line">	int max2 &#x3D; pFun(5,8);  &#x2F;&#x2F;与上面一句完全一致</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>指针名 = &amp;函数名</li>
</ul>
<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>内存泄露是指由于疏忽或错误造成程序未能释放掉不再使用的内存的情况。大多是应用程序分配某段内存后，由于设计的错误，失去了对该内存段的再次使用的控制。</p>
<h2 id="后果"><a href="#后果" class="headerlink" title="后果"></a>后果</h2><p>只发生一次小的内存泄露可能不会引发重大错误甚至可以不被察觉到，但泄露大量的内存会导致程序出现各种问题，可能内存逐渐减少导致性能下降最后导致本程序甚至其他程序崩溃。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>使用智能指针</p>
<h2 id="检查定位内存泄露"><a href="#检查定位内存泄露" class="headerlink" title="检查定位内存泄露"></a>检查定位内存泄露</h2><ul>
<li>在main函数最后面一行，加上一句<code>_CrtDumpMemoryLeaks()</code>。</li>
<li>调试程序，自然关闭程序让其退出，查看输出。</li>
<li>输出这样的格式：<code>&#123;453&#125;normal block at 0x02432CA8,868 bytes long</code></li>
<li>被{}包围的453就是我们需要的内存泄漏定位值，868 bytes long就是说这个地方有868比特内存没有释放。</li>
<li>接着定位代码位置。</li>
<li>在main函数第一行加上<code>_CrtSetBreakAlloc(453);</code>意思就是在申请453这块内存的位置中断。然后调试程序，程序中断了，查看调用堆栈。需要导入头文件<code>#include &lt;crtdbg.h&gt;</code></li>
</ul>
<h1 id="智能指针和RAII"><a href="#智能指针和RAII" class="headerlink" title="智能指针和RAII"></a>智能指针和RAII</h1><h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><ul>
<li>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”。</li>
<li>也就是说在构造函数中申请分配资源，在析构函数中释放资源。</li>
</ul>
<h2 id="RAII引出智能指针"><a href="#RAII引出智能指针" class="headerlink" title="RAII引出智能指针"></a>RAII引出智能指针</h2><ul>
<li>C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。</li>
<li>所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。</li>
</ul>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><ul>
<li>智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现。</li>
<li>使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。</li>
<li>毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。</li>
</ul>
<h1 id="智能指针的实现"><a href="#智能指针的实现" class="headerlink" title="智能指针的实现"></a>智能指针的实现</h1><ul>
<li>智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。</li>
<li>它会自动记录SmartPointer&lt;T*&gt;对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象。</li>
<li>除了指针对象外，我们需要一个引用计数的指针记录指向对象的数量，并将引用计数计为1。</li>
<li>还需要一个构造析构函数。新增对象调用构造函数，析构函数负责引用计数减少和释放内存。</li>
<li>通过重写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1。</li>
<li>还需要拷贝构造函数、复制构造函数、析构函数、移走函数。</li>
</ul>
<h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><ul>
<li>分配内存的顺序的按照声明的顺序</li>
<li>每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止。</li>
<li>结构体的大小必须是其中变量类型最大值的整数倍</li>
<li>添加了<code>#pragma pack(n)</code>后规则就变成了下面这样：<ul>
<li>偏移量取n和当前变量大小两者中取较小值的整数倍</li>
<li>结构体整体大小取n和最大变量大小两者中取较小值的整数倍</li>
<li>n值必须为1,2,4,8…，为其他值时就按照默认的分配规则</li>
</ul>
</li>
</ul>
<h1 id="结构体变量比较"><a href="#结构体变量比较" class="headerlink" title="结构体变量比较"></a>结构体变量比较</h1><ul>
<li>重载<code>==</code>操作符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct foo &#123;</span><br><span class="line">  int a;</span><br><span class="line">  int b;</span><br><span class="line">  bool operator&#x3D;&#x3D;(const foo&amp; rhs) &#x2F;&#x2F;操作运算符重载</span><br><span class="line">  &#123;</span><br><span class="line">    return( a &#x3D;&#x3D; rhs.a) &amp;&amp; (b &#x3D;&#x3D; rhs.b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真；</li>
<li>逐个比对元素</li>
</ul>
<h1 id="函数调用时栈的变化"><a href="#函数调用时栈的变化" class="headerlink" title="函数调用时栈的变化"></a>函数调用时栈的变化</h1><ol>
<li>调用者会把被调用的函数所需要的参数会按照形参顺序相反的顺序压入栈中（由右至左）</li>
<li>调用者会使用call指令调用函数，并把call指令的下一条指令作为返回地址压入栈中</li>
<li>被调用的函数会依次保存调用者的栈底地址以及栈顶地址</li>
<li>在被调用的函数中，栈指针的位置开始存放被调函数的局部变量以及临时变量</li>
<li>并且这些变量的地址会按照定义的顺序依次减少（栈的增长方向是由上至下）</li>
</ol>
<h1 id="define-const-typedef-inline"><a href="#define-const-typedef-inline" class="headerlink" title="define/const/typedef/inline"></a>define/const/typedef/inline</h1><h2 id="define-amp-const的区别"><a href="#define-amp-const的区别" class="headerlink" title="define&amp;const的区别"></a>define&amp;const的区别</h2><ul>
<li>const定义的常量是带变量类型的；而define定义的只是一个常数，并不带有类型</li>
<li>const在编译、链接的过程中起作用；define仅在预编译的阶段起作用</li>
<li>const是有数据类型的，是要进行类型判断的，可以避免低级错误；define仅在文本的层面上进行字符串替换，没有类型的检测</li>
<li>const编译后，占用数据段空间；define预处理后，占用代码段空间</li>
<li>const不能重定义；define可以通过<code>#undef</code>取消某个符号的定义，进行重定义</li>
<li>使用<code>#ifndef``#define``#endif</code>能够用来防止文件的重复引用</li>
</ul>
<h2 id="define和typedef的区别"><a href="#define和typedef的区别" class="headerlink" title="define和typedef的区别"></a>define和typedef的区别</h2><ul>
<li>执行时间不同。define是宏定义，发生在预编译阶段，不会进行类型检测；typedef在编译阶段有效，会进行类型检测</li>
<li>功能不同。define不只是可以为类型取别名，还能定义常量、变量等；typedef用来定义类型的别名，定义与平台无关的数据类型，常与struct结合使用</li>
<li>作用域不同。define没有作用域的限制，只要在之前预定义过的宏以后的程序都能使用；typedef有自己的作用域。</li>
</ul>
<h2 id="define和inline的区别"><a href="#define和inline的区别" class="headerlink" title="define和inline的区别"></a>define和inline的区别</h2><ul>
<li>define是关键字；inline是函数</li>
<li>define在预编译阶段进行文本替换；inline在编译阶段进行替换</li>
<li>define没有类型检查；inline函数有类型检测，相比来说更加的安全。</li>
</ul>
<h1 id="printf函数的实现"><a href="#printf函数的实现" class="headerlink" title="printf函数的实现"></a>printf函数的实现</h1><ol>
<li>函数参数由右至左压入栈中</li>
<li><code>printf()</code>函数最后压入栈中的是字符串，也就是说字符串在函数中最先被找到</li>
<li>函数通过判断字符串里面的控制参数来判断参数的个数以及数据的类型</li>
<li>通过参数的个数以及类型便可以算出需要栈指针的偏移量了。</li>
</ol>
<h1 id="lambda函数的了解"><a href="#lambda函数的了解" class="headerlink" title="lambda函数的了解"></a>lambda函数的了解</h1><ul>
<li>lambda表达式常用于编写内嵌的匿名函数，用以替换独立函数或者函数对象</li>
<li>当程序员定义一个lambda表达式后，编译器会自动生产一个匿名类（这个类重载了()运算符），我们称它为闭包类型</li>
<li>在运行时，这个lambda表达式就会返回一个匿名的闭包实例，实质上是一个右值</li>
<li>所以lambda表达式的结果就是一个闭包，闭包可以通过传值或引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们称它为lambda捕捉块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[]() int -&gt; &#123;cout &lt;&lt; &quot;hello World&quot;;return 0;&#125;;</span><br><span class="line">&#x2F;&#x2F;lambda可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；</span><br><span class="line">&#x2F;&#x2F;[] &#123; cout &lt;&lt; &quot;Hello, World!&quot;&lt;&lt;endl; &#125;();</span><br></pre></td></tr></table></figure>


<h1 id="字符串打印到屏幕的过程"><a href="#字符串打印到屏幕的过程" class="headerlink" title="字符串打印到屏幕的过程"></a>字符串打印到屏幕的过程</h1><ol>
<li>用户告知OS执行打印程序</li>
<li>OS会找到程序的相关信息，例如：检查其文件类型是否为可执行文件、通过程序首部信息确定代码和数据在可执行文件的位置并计算出对应的磁盘块地址。</li>
<li>OS创建一个新进程，将可执行文件映射到PCB中</li>
<li>OS为程序设置CPU执行的上下文，并跳转到程序的开始处</li>
<li>执行程序的第一行指令，若发生缺页异常</li>
<li>OS会分配一页物理内存，并把代码从磁盘读入内存，然后继续执行程序</li>
<li>程序会执行一个<code>puts()</code>的系统调用，在显示器上打印一段字符串</li>
<li>OS会找到字符串需要送往的显示设备中，通常设备是由一个进程控制，所以OS会将该字符串送往负责显示器打印的进程中去。</li>
<li>控制设备的进程会告诉显卡，我现在需要显示该字符串，显卡确定这是一个合法操作后，就会将该字符串转换成像素点并写入显卡的存储映像去中</li>
<li>显卡将像素转换成显示器可接受和控制的数据信号后，传给显示器</li>
<li>显示器会解释信号并激发液晶屏</li>
<li>大功告成！我们看到的我们需要打印的字符串</li>
</ol>
<h1 id="模板类和模板函数"><a href="#模板类和模板函数" class="headerlink" title="模板类和模板函数"></a>模板类和模板函数</h1><ul>
<li>函数模板的实例化是由编译程序在处理函数调用时自动完成的。</li>
<li>类模板的实例化必须由程序员在程序中显式地指定。</li>
<li>函数模板允许隐式调用和显式调用。</li>
<li>类模板只能显示调用，使用时必须添加<code>&lt;&gt;</code>。</li>
</ul>
<h1 id="类成员的访问-继承权限"><a href="#类成员的访问-继承权限" class="headerlink" title="类成员的访问/继承权限"></a>类成员的访问/继承权限</h1><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><ul>
<li><code>public</code>:用该关键字修饰的成员表示公有成员，该成员不仅可以在类内可以被 访问，在类外也是可以被访问的，是类对外提供的可访问接口；</li>
<li><code>private</code>:用该关键字修饰的成员表示私有成员，该成员仅在类内可以被访问，在类体外是隐藏状态；</li>
<li><code>protected</code>:用该关键字修饰的成员表示保护成员，保护成员在类体外同样是隐藏状态，但是对于该类的派生类来说，相当于公有成员，在派生类中可以被访问。</li>
</ul>
<h2 id="继承权限"><a href="#继承权限" class="headerlink" title="继承权限"></a>继承权限</h2><ul>
<li>若继承方式是<code>public</code>，基类成员在派生类中的访问权限保持不变，也就是说，基类中的成员访问权限，在派生类中仍然保持原来的访问权限；</li>
<li>若继承方式是<code>private</code>，基类所有成员在派生类中的访问权限都会变为私有(private)权限；</li>
<li>若继承方式是<code>protected</code>，基类的共有成员和保护成员在派生类中的访问权限都会变为保护(protected)权限，私有成员在派生类中的访问权限仍然是私有(private)权限。</li>
</ul>
<h1 id="cout和printf的区别"><a href="#cout和printf的区别" class="headerlink" title="cout和printf的区别"></a>cout和printf的区别</h1><ul>
<li><code>cout&lt;&lt;</code> 是一个函数，函数后面可以跟不同类型是因为<code>cout&lt;&lt;</code>已经存在针对各种类型的数据重载</li>
<li>所以会自动识别数据的类型。</li>
<li>输出过程会首先将输出字符放入缓存区，然后输出到屏幕中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; &quot;abc &quot; &lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;相当于cout &lt;&lt; &quot;abc\n &quot;;cout &lt;&lt;flush; 这两个才是一样的</span><br><span class="line">&#x2F;&#x2F;cout是有缓冲输出</span><br><span class="line">&#x2F;&#x2F;flush立即强迫缓冲输出。 </span><br><span class="line">&#x2F;&#x2F;printf是无缓冲输出。有输出时立即输出</span><br></pre></td></tr></table></figure>


<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><ul>
<li>我们只能重载已有的运算符，而无权发明新的运算符；</li>
<li>对于一个重载的运算符，其优先级和结合律与内置类型一致才可以；</li>
<li>不能改变运算符操作数个数；</li>
<li>两种重载方式：成员运算符和非成员运算符，下标运算符、箭头运算符必须是成员运算符；</li>
<li>成员运算符比非成员运算符少一个参数；</li>
<li>引入运算符重载，是为了实现类的多态性；</li>
<li>当重载的运算符是成员函数时，this绑定到左侧运算符对象。</li>
<li>下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；</li>
<li>箭头运算符必须是类的成员，解引用通常也是类的成员；重载的箭头运算符必须返回类的指针；</li>
</ul>
<h1 id="函数重载的匹配原则和顺序"><a href="#函数重载的匹配原则和顺序" class="headerlink" title="函数重载的匹配原则和顺序"></a>函数重载的匹配原则和顺序</h1><ol>
<li>名字查找</li>
<li>确定候选函数</li>
<li>寻找最佳匹配</li>
</ol>
<h1 id="定义和声明的区别"><a href="#定义和声明的区别" class="headerlink" title="定义和声明的区别"></a>定义和声明的区别</h1><ul>
<li>变量的声明和定义<ul>
<li>从编译原理上来说</li>
<li>声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。</li>
<li>而定义就是分配了内存。</li>
</ul>
</li>
<li>函数的声明和定义<ul>
<li>声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在。</li>
<li>定义：一般在源文件里，具体就是函数的实现过程 写明函数体。</li>
</ul>
</li>
</ul>
<h1 id="全局变量和静态变量的区别"><a href="#全局变量和静态变量的区别" class="headerlink" title="全局变量和静态变量的区别"></a>全局变量和静态变量的区别</h1><blockquote>
<p>注意：全局变量之前再冠以static就构成了静态的全局变量。</p>
</blockquote>
<ul>
<li>全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。</li>
<li>非静态全局变量的作用域是整个源程序，当一个源程序由多个原文件组成时，非静态的全局变量在各个源文件中都是有效的。</li>
<li>静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。</li>
</ul>
<h1 id="普通函数和静态函数的区别"><a href="#普通函数和静态函数的区别" class="headerlink" title="普通函数和静态函数的区别"></a>普通函数和静态函数的区别</h1><ul>
<li> 静态函数的作用域不同。仅在本文件中。只在当前源文件中使用的函数应该说明为静态函数</li>
<li>对于可在当前源文件以外使用的函数应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。 </li>
</ul>
<h1 id="静态成员和普通成员的区别"><a href="#静态成员和普通成员的区别" class="headerlink" title="静态成员和普通成员的区别"></a>静态成员和普通成员的区别</h1><ul>
<li>声明周期<ul>
<li>静态成员变量从类被加载开始到类被释放，一直存在；</li>
<li>普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束；</li>
</ul>
</li>
<li>共享方式<ul>
<li>静态成员变量是全类共享；</li>
<li>普通成员变量是每个对象单独享用的；</li>
</ul>
</li>
<li>定义位置<ul>
<li>普通成员变量存储在栈或堆中；</li>
<li>静态成员变量存储在静态全局区；</li>
</ul>
</li>
<li>初始化位置<ul>
<li>普通成员变量在类中初始化；</li>
<li>静态成员变量在类外初始化；</li>
</ul>
</li>
<li>默认实参<ul>
<li>可以使用静态成员变量作为默认实参</li>
<li>而普通成员变量却不行</li>
</ul>
</li>
</ul>
<h1 id="ifdef-endif"><a href="#ifdef-endif" class="headerlink" title="#ifdef/#endif"></a>#ifdef/#endif</h1><ul>
<li>一般情况下，源代码的所有行都会参与到编译中，但如果有些情况我们希望对其中的一部分内容选择性的编译（例如：满足一定条件才进行编译，对一部分内容指定编译条件，也就是条件编译）。希望满足某条件时对一组语句进行编译，否则编译另外一组语句。</li>
<li>常见形式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifdef 标识符</span><br><span class="line">程序段1</span><br><span class="line">#else</span><br><span class="line">程序段2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当标识符已被定义过（一般是用#define命令定义）时，则对程序段1进行编译，否则对程序段2进行编译</p>
</blockquote>
<ul>
<li>没有<code>#else</code>的形式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifdef 标识符</span><br><span class="line">程序段1</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<ul>
<li>一般在大型的软件工程里面，可能会有多个文件包含同一个头文件，当这些文件编译链接成一个可执行文件时，就会出现大量的”重定义”错误。所以我们在头文件中常使用<code>#define</code>、<code>#ifdef</code>、<code>#else</code>、<code>#endif</code>来避免头文件重定义。</li>
</ul>
<h1 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h1><ul>
<li>C++的基本类型并非完全对立的，部分数据类型之间是可以进行隐式转换。隐式转换指的就是不需要用户干预，编译器会自动进行的类型转换的行为。</li>
<li>C++面向对象的多态特性，通过父类的类型实现子类的封装。通过隐式转换可以将一个子类对象以父类类型返回。</li>
<li>基本数据类型的转换是以取值范围作为转换基础（为了保证精度不丢失）。隐式转换是从小变大的转换（例如：char可以转换为int，int可以转换为long）。</li>
<li>自定义对可以隐式的转换为父类对象</li>
<li><code>explicit</code>关键字，在构造函数声明的时候加上<code>explicit</code>关键字，能够禁止隐式转换。</li>
<li>若构造函数只接受一个参数，它实际上定义了转换为此类类型的隐式转换机制。可以通过<code>explicit</code>关键字禁止隐式转换的操作。</li>
<li><code>explicit</code>关键字仅对一个实参的构造函数有效，需要多个实参的构造函数不能执行隐式转换，所以无需多参构造函数指定为<code>explicit</code>。</li>
</ul>
<h1 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h1><ul>
<li>两个子类继承同一个父类，而子类又同时继承该两个子类。</li>
<li>若没有使用虚继承的话会产生重复的数据成员</li>
<li>若涉及到菱形继承需要使用虚继承</li>
</ul>
<h1 id="如何看待多继承"><a href="#如何看待多继承" class="headerlink" title="如何看待多继承"></a>如何看待多继承</h1><ul>
<li>C++允许为一个派生类指定多个基类，这样的继承结构被称做多重继承。</li>
<li>多重继承的优点很明显，就是对象可以调用多个基类中的接口；</li>
<li>如果派生类所继承的多个基类有相同的基类，而派生类对象需要调用这个祖先类的接口方法，就会容易出现二义性</li>
<li>需要加上全局符确定调用哪一份拷贝。</li>
<li>使用虚拟继承，使得多重继承类只拥有父类的一份拷贝。</li>
</ul>
<h1 id="it和it"><a href="#it和it" class="headerlink" title="++it和it++"></a>++it和it++</h1><ul>
<li><code>++it</code>前置自加返回一个引用，不会产生临时对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int&amp; operator++()&#123;</span><br><span class="line">  *this +&#x3D; 1;</span><br><span class="line">  return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>it++</code>后置自加返回一个对象，会产生临时对象，会导致效率降低</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int operator++(int)&#123;</span><br><span class="line">  int temp &#x3D; *this;</span><br><span class="line">  ++*this;</span><br><span class="line">  return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="处理多个异常"><a href="#处理多个异常" class="headerlink" title="处理多个异常"></a>处理多个异常</h1><ul>
<li>C++中的异常情况： <ul>
<li>语法错误（编译错误）：比如变量未定义、括号不匹配、关键字拼写错误等等编译器在编译时能发现的错误，这类错误可以及时被编译器发现，而且可以及时知道出错的位置及原因，方便改正。</li>
<li> 运行时错误：比如数组下标越界、系统内存不足等等。这类错误不易被程序员发现，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃。</li>
<li>为了有效处理程序运行时错误，C++中引入异常处理机制来解决此问题。</li>
</ul>
</li>
<li>C++异常处理机制： <ul>
<li>异常处理基本思想：执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题。 </li>
<li>C++异常处理机制由3个模块组成：try(检查)、throw(抛出)、catch(捕获) 抛出异常的语句格式为：throw 表达式；如果try块中程序段发现了异常则抛出异常。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123; </span><br><span class="line">  可能抛出异常的语句；（检查）</span><br><span class="line">&#125; </span><br><span class="line">catch（类型名[形参名]）&#x2F;&#x2F;捕获特定类型的异常 </span><br><span class="line">&#123; </span><br><span class="line">  &#x2F;&#x2F;处理1；</span><br><span class="line">&#125; </span><br><span class="line">catch（类型名[形参名]）&#x2F;&#x2F;捕获特定类型的异常 </span><br><span class="line">&#123; </span><br><span class="line">  &#x2F;&#x2F;处理2；</span><br><span class="line">&#125; </span><br><span class="line">catch（…）&#x2F;&#x2F;捕获所有类型的异常 </span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;处理3；</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h1 id="模板和实现能否分开"><a href="#模板和实现能否分开" class="headerlink" title="模板和实现能否分开"></a>模板和实现能否分开</h1><ul>
<li>因为在编译时模板并不能生成真正的二进制代码</li>
<li>而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现，</li>
<li>在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在</li>
<li>所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。</li>
<li>但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。 </li>
<li>《C++编程思想》第15章(第300页)说明了原因：模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间</li>
<li>它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。</li>
<li>所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</li>
</ul>
<h1 id="成员函数调用delete-this"><a href="#成员函数调用delete-this" class="headerlink" title="成员函数调用delete this"></a>成员函数调用delete this</h1><ul>
<li>出现问题：<ul>
<li>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容</li>
<li>类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个<code>this</code>指针，让成员函数知道当前是哪个对象在调用它。</li>
<li>当调用<code>delete this</code>时，类对象的内存空间被释放。</li>
<li>在<code>delete this</code>之后进行的其他任何函数调用，只要不涉及到<code>this</code>指针的内容，都能够正常运行。一旦涉及到<code>this</code>指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。</li>
</ul>
</li>
<li>原因：<ul>
<li><code>delete this</code>之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？</li>
<li>这个问题牵涉到操作系统的内存管理策略。<code>delete this</code>释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。</li>
<li>此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。</li>
</ul>
</li>
<li>析构函数调用<code>delete this</code><ul>
<li>会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后释放内存”。</li>
<li>显然，<code>delete this</code>会去调用本对象的析构函数，而析构函数中又调用<code>delete this</code>，形成无限递归，造成堆栈溢出，系统崩溃。</li>
</ul>
</li>
</ul>
<h1 id="两数交换"><a href="#两数交换" class="headerlink" title="两数交换"></a>两数交换</h1><ul>
<li>平平无奇的交换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp &#x3D; x;</span><br><span class="line">x &#x3D; y;</span><br><span class="line">y &#x3D; temp;</span><br></pre></td></tr></table></figure>
<ul>
<li>算术交换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; x + y;</span><br><span class="line">y &#x3D; x - y;</span><br><span class="line">x &#x3D; x - y;</span><br></pre></td></tr></table></figure>
<ul>
<li>异或交换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; x ^ y;</span><br><span class="line">y &#x3D; x ^ y;</span><br><span class="line">x &#x3D; x ^ y;</span><br><span class="line">&#x2F;&#x2F;等效于x ^&#x3D; y ^&#x3D; x;</span><br><span class="line">&#x2F;&#x2F;仅适用于int，char</span><br></pre></td></tr></table></figure>


<h1 id="strcpy和memcpy"><a href="#strcpy和memcpy" class="headerlink" title="strcpy和memcpy"></a>strcpy和memcpy</h1><ul>
<li>复制的内容不同：<ul>
<li>strcpy只能复制字符串</li>
<li>memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</li>
</ul>
</li>
<li>复制的方法不同：<ul>
<li>strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。</li>
<li>memcpy则是根据其第3个参数决定复制的长度。</li>
</ul>
</li>
<li>用途不同：<ul>
<li>通常在复制字符串时用strcpy。</li>
<li>而需要复制其他类型数据时则一般用memcpy。</li>
</ul>
</li>
</ul>
<h1 id="执行int-main-的内存结构"><a href="#执行int-main-的内存结构" class="headerlink" title="执行int main()的内存结构"></a>执行int main()的内存结构</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char *argv[])</span><br></pre></td></tr></table></figure>
<ul>
<li>参数的含义是程序在命令行下运行的时候</li>
<li>需要输入argc 个参数</li>
<li>每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]</li>
<li>所有的参数在指针char * 指向的内存中，数组的中元素的个数为 argc 个。</li>
</ul>
<h1 id="volatile关键字的作用"><a href="#volatile关键字的作用" class="headerlink" title="volatile关键字的作用"></a>volatile关键字的作用</h1><ul>
<li>volatile关键字是一种类型修饰符</li>
<li>不用它声明的类型变量表示可以被某些编译器未知的因素更改（例如：操作系统、硬件或者其它线程等）</li>
<li>遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化</li>
<li>从而可以提供对特殊地址的稳定访问。</li>
<li>声明时语法：int volatile vInt; </li>
<li>当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</li>
</ul>
<p>使用场景：</p>
<ol>
<li>中断服务程序中修改的供其它程序检测的变量需要加volatile</li>
<li>多任务环境下各任务间共享的标志应该加volatile</li>
<li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义</li>
</ol>
<h1 id="空类包含的函数"><a href="#空类包含的函数" class="headerlink" title="空类包含的函数"></a>空类包含的函数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Empty(); &#x2F;&#x2F;缺省构造函数</span><br><span class="line">Empty(const Empty&amp;); &#x2F;&#x2F;拷贝构造函数</span><br><span class="line">~Empty(); &#x2F;&#x2F;析构函数</span><br><span class="line">Empty&amp; operator&#x3D;(const Empty&amp;); &#x2F;&#x2F;赋值运算符</span><br></pre></td></tr></table></figure>


<h1 id="C-的标准库"><a href="#C-的标准库" class="headerlink" title="C++的标准库"></a>C++的标准库</h1><ul>
<li>标准函数库：这个库由通用的、独立的、不属于任何类的函数组成。函数库继承自C语言。<ul>
<li>输入输出IO</li>
<li>字符串和字符处理</li>
<li>数学</li>
<li>时间</li>
<li>日期和本地化</li>
<li>动态分配</li>
<li>宽字符函数</li>
</ul>
</li>
<li>面向对象类库：这个库是类及其相关函数的集合。<ul>
<li>标准C++IO类</li>
<li>String类</li>
<li>数值类</li>
<li>STL容器类</li>
<li>STL算法</li>
<li>STL函数对象</li>
<li>STL迭代器</li>
<li>STL分配器</li>
<li>本地化库</li>
<li>异常处理类</li>
</ul>
</li>
</ul>
<h1 id="const-char-和string"><a href="#const-char-和string" class="headerlink" title="const char*和string"></a>const char*和string</h1><ul>
<li><p>string是C++标准库中的其中一种，封装了对字符串的操作</p>
</li>
<li><p>日常操作中，我们可以用<code>const char*</code>来初始化string类</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;string 转 const char*</span><br><span class="line">string &#x3D; “hello”;</span><br><span class="line">const char* c_s &#x3D; s.c_str();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;const char* 转 string</span><br><span class="line">const char* c_s&#x3D; “abc”;</span><br><span class="line">string s(c_s);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;string 转 char*</span><br><span class="line">string s &#x3D; “abc”; </span><br><span class="line">char* c; </span><br><span class="line">const int len &#x3D; s.length(); </span><br><span class="line">c &#x3D; new char[len+1]; </span><br><span class="line">strcpy(c,s.c_str());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;char* 转 string</span><br><span class="line">char* c &#x3D; “abc”; </span><br><span class="line">string s(c);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;const char* 转 char*</span><br><span class="line">const char* cpc &#x3D; “abc”; </span><br><span class="line">char* pc &#x3D; new char[strlen(cpc)+1]; </span><br><span class="line">strcpy(pc,cpc);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;char* 转 const char*,直接赋值即可</span><br><span class="line">char* pc &#x3D; “abc”; </span><br><span class="line">const char* cpc &#x3D; pc;</span><br></pre></td></tr></table></figure>


<h1 id="拷贝构造函数必须传引用"><a href="#拷贝构造函数必须传引用" class="headerlink" title="拷贝构造函数必须传引用"></a>拷贝构造函数必须传引用</h1><ul>
<li>拷贝构造函数的作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。</li>
<li>参数传递过程到底发生了什么？ <ul>
<li>将地址传递和值传递统一起来，归根结底还是传递的是”值”(地址也是值，只不过通过它可以找到另一个值)</li>
<li>值传递: 对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)； 对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；</li>
<li>引用传递: 无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用。</li>
</ul>
</li>
<li>拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归。</li>
<li>这就是为什么拷贝构造函数使用值传递会产生无限递归调用，内存溢出。</li>
</ul>
<h1 id="空类的大小"><a href="#空类的大小" class="headerlink" title="空类的大小"></a>空类的大小</h1><ul>
<li>空类的大小不为0，不同编译器设置不一样，vs为1；</li>
<li>C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；</li>
<li>C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。</li>
<li>带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；</li>
</ul>
<h1 id="指针-amp-引用作为参数的情况"><a href="#指针-amp-引用作为参数的情况" class="headerlink" title="指针&amp;引用作为参数的情况"></a>指针&amp;引用作为参数的情况</h1><ul>
<li>使用引用参数的主要原因：<ul>
<li>程序员希望能修改调用函数中数据对象的内容</li>
<li>通过传递引用可以提高程序的运行速度</li>
</ul>
</li>
<li>对于仅使用参数值而不做修改的函数：<ul>
<li>如果数据对象很小，如内置数据类型或者小型结构，则按照值传递</li>
<li>如果数据对象是数组，则使用指针（唯一的选择），并且指针声明为指向<code>const</code>的指针</li>
<li>如果数据对象是较大的结构，则使用<code>const</code>指针或者引用，以提高程序的效率。这样可以节省结构所需的时间和空间</li>
<li>如果数据对象是类对象，则使用<code>const</code>引用（传递类对象参数的标准方式是按照引用传递）</li>
</ul>
</li>
<li>对于需要修改函数中数据的函数：<ul>
<li>如果数据是内置数据类型，则使用指针</li>
<li>如果数据对象是数组，则只能使用指针</li>
<li>如果数据对象是结构，则使用引用或者指针</li>
<li>如果数据是类对象，则使用引用</li>
</ul>
</li>
</ul>
<h1 id="静态函数不能定义为虚函数"><a href="#静态函数不能定义为虚函数" class="headerlink" title="静态函数不能定义为虚函数"></a>静态函数不能定义为虚函数</h1><ul>
<li>静态成员不数据任何对象，所以定义为虚函数没有任何意义</li>
<li>静态与非静态成员函数之间最主要的区别，那就是静态函数没有<code>this</code>指针</li>
<li>虚函数依靠<code>vptr</code>和<code>vtable</code>处理，<code>vptr</code>是一个指针，在类的构造函数中生成，并且只能用<code>this</code>指针来访问它</li>
<li><code>vptr</code>是类的一个成员，并且<code>vptr</code>指向保存虚函数地址的<code>vtable</code>。</li>
<li>对于静态成员函数，它没有this指针，所以无法访问<code>vptr</code>。</li>
<li>虚函数的调用关系：<code>this</code> -&gt; <code>vptr</code> -&gt; <code>vtable</code> -&gt;<code>virtual function</code>，所以这就是为何静态函数不能为<code>virtual</code></li>
</ul>
<h1 id="this调用成员变量时的堆栈"><a href="#this调用成员变量时的堆栈" class="headerlink" title="this调用成员变量时的堆栈"></a>this调用成员变量时的堆栈</h1><ul>
<li>当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。</li>
<li>即使你并没有写this指针，编译器在链接时也会加上this的，对各成员的访问都是通过this的。</li>
<li>例如你建立了类的多个对象时，在调用类的成员函数时，你并不知道具体是哪个对象在调用，此时你可以通过查看this指针来查看具体是哪个对象在调用。This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。</li>
</ul>
<h1 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h1><ul>
<li>对象的静态类型：采用声明时的类型，编译器便确定类型。</li>
<li>对象的动态类型：对象的类型在运行期才决定。</li>
<li>静态绑定：绑定的是对象的静态类型和特性在编译期确定。</li>
<li>动态绑定：绑定的是对象的动态类型和特性在运行期确定。</li>
</ul>
<h1 id="计算子类的个数"><a href="#计算子类的个数" class="headerlink" title="计算子类的个数"></a>计算子类的个数</h1><ol>
<li>为类设计一个static静态变量count作为计数器</li>
<li>类定义结束后初始化count</li>
<li>在构造函数中对count进行+1</li>
<li>设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作</li>
<li>设计复制构造函数，在进行复制函数中对count+1操作</li>
<li>在析构函数中对count进行-1</li>
</ol>
<h1 id="快速定位错误"><a href="#快速定位错误" class="headerlink" title="快速定位错误"></a>快速定位错误</h1><ul>
<li>简单错误：</li>
</ul>
<p>直接双击错误列表里的错误项或者生成输出的错误信息中带行号的地方就可以让编辑窗口定位到错误的位置上。</p>
<ul>
<li>复杂的模板错误，最好使用生成输出窗口：</li>
</ul>
<p>多数情况下出现错误的位置是最靠后的引用位置。如果这样确定不了错误，就需要先把自己写的代码里的引用位置找出来，然后逐个分析</p>
<h1 id="虚函数的代价"><a href="#虚函数的代价" class="headerlink" title="虚函数的代价"></a>虚函数的代价</h1><ul>
<li>带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，增大类</li>
<li>带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会增加对象的空间大小</li>
<li>不能再是内敛的函数，因为内敛函数在编译阶段进行替代，而虚函数表示等待，在运行阶段才能确定到低是采用哪种函数，虚函数不能是内敛函数</li>
</ul>
<h1 id="类对象大小影响因素"><a href="#类对象大小影响因素" class="headerlink" title="类对象大小影响因素"></a>类对象大小影响因素</h1><ul>
<li>类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小</li>
<li>内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的</li>
<li>虚函数的话，会在类对象插入<code>vptr</code>指针，加上指针大小</li>
<li>当该该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展</li>
</ul>
<h1 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h1><blockquote>
<p>有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</p>
</blockquote>
<ul>
<li>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制；</li>
<li>C++引入了移动构造函数，专门处理这种，用a初始化b后，就将a析构的情况；</li>
<li>与拷贝类似，移动也使用一个对象的值设置另一个对象的值。</li>
<li>但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。</li>
<li>移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。</li>
<li>典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用。</li>
<li>因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对象进行构造初始化的时候，调用移动构造函数。</li>
<li>类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example (Example&amp;&amp; x) : ptr(x.ptr)&#123;</span><br><span class="line">  x.ptr &#x3D; nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; move assignment</span><br><span class="line">Example&amp; operator&#x3D; (Example&amp;&amp; x)&#123;</span><br><span class="line">  delete ptr; </span><br><span class="line">  ptr &#x3D; x.ptr;</span><br><span class="line">  x.ptr&#x3D;nullptr;</span><br><span class="line">  return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="自动生成构造函数的条件"><a href="#自动生成构造函数的条件" class="headerlink" title="自动生成构造函数的条件"></a>自动生成构造函数的条件</h1><ul>
<li>如果一个类没有任何构造函数，但他含有一个成员对象，该成员对象含有默认构造函数，那么编译器就为该类合成一个默认构造函数，因为不合成一个默认构造函数那么该成员对象的构造函数不能调用；</li>
<li>没有任何构造函数的类派生自一个带有默认构造函数的基类，那么需要为该派生类合成一个构造函数，只有这样基类的构造函数才能被调用；</li>
<li>带有虚函数的类，虚函数的引入需要进入虚表，指向虚表的指针，该指针是在构造函数中初始化的，所以没有构造函数的话该指针无法被初始化；</li>
<li>带有一个虚基类的类</li>
</ul>
<p>注意：</p>
<ul>
<li>根据《深度探索C++对象模型》书上的说法，编译器只在一定需要默认构造函数时，才会创建默认构造函数</li>
<li>所以并不是任何没有构造函数的类都会合成一个构造函数</li>
<li>编译器合成出来的构造函数并不会显式设定类内的每一个成员变量</li>
</ul>
<h1 id="自动生成拷贝构造函数的条件"><a href="#自动生成拷贝构造函数的条件" class="headerlink" title="自动生成拷贝构造函数的条件"></a>自动生成拷贝构造函数的条件</h1><ul>
<li>对一个对象做显示的初始化操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person p1;</span><br><span class="line">Person p2 &#x3D; p1;</span><br></pre></td></tr></table></figure>
<ul>
<li>当对象被当做参数交给某个函数时</li>
<li>当函数传回一个类对象时</li>
<li>如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时编译器会为该类合成一个拷贝构造函数</li>
<li>如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数</li>
<li>如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝构造函数</li>
<li>如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数</li>
</ul>
<h1 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h1><ul>
<li>需要使用的情况：<ul>
<li>初始化一个应用成员变量</li>
<li>初始化一个const成员变量</li>
<li>调用一个基类的构造函数，而构造函数拥有一组参数</li>
<li>调用一个成员类的构造函数，而构造函数拥有一组参数</li>
</ul>
</li>
<li>调用过程：<ul>
<li>编译器会逐一操作初始化列表</li>
<li>在用户的代码前以适当的顺序在构造函数之内安插初始化操作</li>
<li>初始化的顺序时由类中的成员声明顺序决定的</li>
<li>而非初始化列表中的排列顺序决定的</li>
</ul>
</li>
</ul>
<h1 id="构造函数的执行顺序"><a href="#构造函数的执行顺序" class="headerlink" title="构造函数的执行顺序"></a>构造函数的执行顺序</h1><ul>
<li>派生类构造函数中，所有虚基类以及上层基类的构造函数调用</li>
<li>对象的<code>vptr</code>初始化</li>
<li>如果有成员初始化列表，将在构造函数体内扩展开，这步骤需要在<code>vptr</code>初始化完再进行</li>
<li>执行程序员提供的代码</li>
</ul>
<h1 id="构造函数的扩展过程"><a href="#构造函数的扩展过程" class="headerlink" title="构造函数的扩展过程"></a>构造函数的扩展过程</h1><ul>
<li>记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数体内，并与成员的声明顺序为顺序</li>
<li>如果一个成员并没有出现在成员初始化列表中，但它有一个默认构造函数，那么默认构造函数必须被调用</li>
<li>如果类有虚表，那么虚表指针必须被设定初值</li>
<li>所有上一层的基类构造函数必须被调用</li>
<li>所有虚基类的构造函数必须被调用</li>
</ul>
<blockquote>
<p>扩展顺序和执行顺序刚好时相反，栈的逻辑</p>
</blockquote>
<h1 id="不能为虚函数的函数"><a href="#不能为虚函数的函数" class="headerlink" title="不能为虚函数的函数"></a>不能为虚函数的函数</h1><ul>
<li>构造函数</li>
</ul>
<p>构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；</p>
<ul>
<li>内联函数</li>
</ul>
<p>内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；</p>
<ul>
<li>静态函数</li>
</ul>
<p>静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。</p>
<ul>
<li>友元函数</li>
</ul>
<p>友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。</p>
<ul>
<li>普通函数</li>
</ul>
<p>普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。</p>
<blockquote>
<p>我们说人话就是，使用虚函数前提就是必须是类的成员，但类的成员函数不一定可以是虚函数（例如：构造函数和静态成员函数）</p>
</blockquote>
<h1 id="strcpy、sprintf和memcpy的区别"><a href="#strcpy、sprintf和memcpy的区别" class="headerlink" title="strcpy、sprintf和memcpy的区别"></a>strcpy、sprintf和memcpy的区别</h1><ul>
<li><p>操作对象不同：</p>
<ul>
<li>strcpy的两个操作对象均为字符串。</li>
<li>sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串。</li>
<li>memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</li>
</ul>
</li>
<li><p>执行效率不同</p>
<ul>
<li>memcpy最高，strcpy次之，sprintf的效率最低。</li>
</ul>
</li>
<li><p>实现功能不同</p>
<ul>
<li>strcpy主要实现字符串变量间的拷贝</li>
<li>sprintf主要实现其他数据类型格式到字符串的转化</li>
<li>memcpy主要是内存块间的拷贝。</li>
</ul>
</li>
</ul>
<h1 id="引用作为参数的好处"><a href="#引用作为参数的好处" class="headerlink" title="引用作为参数的好处"></a>引用作为参数的好处</h1><ul>
<li><p>传递引用和传递指针的效果是一致的：</p>
<ul>
<li>这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，</li>
<li>所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。</li>
</ul>
</li>
<li><p>使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作：</p>
<ul>
<li>使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本。</li>
<li>如果传递的是对象，还将调用拷贝构造函数。</li>
<li>因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</li>
</ul>
</li>
<li><p>虽然使用指针作为函数的参数虽然也能达到与使用引用的效果，但是：</p>
<ul>
<li>在被调函数中同样要给形参分配存储单元，且需要重复使用<code>*指针变量名</code>的形式进行运算，这很容易产生错误且程序的阅读性较差。</li>
<li>另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</li>
</ul>
</li>
</ul>
<h1 id="数组和指针的区别"><a href="#数组和指针的区别" class="headerlink" title="数组和指针的区别"></a>数组和指针的区别</h1><ul>
<li>数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：<code>sizeof(数组名)</code>；数组大小：<code>sizeof(数组名)/sizeof(数组元素数据类型)</code></li>
<li>用运算符<code>sizeof</code> 可以计算出数组的容量（字节数）。<code>sizeof(p)</code>,其中p为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。</li>
<li>编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是将表达式中的数组元素引用转换为指针加偏移量的引用。</li>
<li>在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是传递过去是数组的首地址而不是整个数组，能够提高效率；</li>
<li>在使用下标的时候，两者的用法相同，都是原地址加上下标值，不过数组的原地址就是数组首元素的地址是固定的，指针的原地址就不是固定的。</li>
</ul>
<h1 id="如何阻止类被实例化"><a href="#如何阻止类被实例化" class="headerlink" title="如何阻止类被实例化"></a>如何阻止类被实例化</h1><ul>
<li>将类定义为抽象基类或者将构造函数声明为private</li>
<li>不允许类外部创建类对象，只能在类内部创建对象</li>
</ul>
<h1 id="禁止自动生成拷贝构造函数"><a href="#禁止自动生成拷贝构造函数" class="headerlink" title="禁止自动生成拷贝构造函数"></a>禁止自动生成拷贝构造函数</h1><ul>
<li>为了阻止编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况﻿下，为了避免调用拷贝构造函数和﻿拷贝赋值函数，我们需要将他们设置成private，防止被调用。</li>
<li>类的成员函数和friend函数还是可以调用private函数，如果这个private函数只声明不定义，则会产生一个连接错误；</li>
<li>针对上述两种情况，我们可以定一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成private,那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作。</li>
</ul>
<h1 id="debug和release的区别"><a href="#debug和release的区别" class="headerlink" title="debug和release的区别"></a>debug和release的区别</h1><ul>
<li>debug调试版本：<ul>
<li>包含调试信息，所以容量比Release大很多。</li>
<li>并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。</li>
<li>Debug模式下生成两个文件，除了.exe或.dll文件外，还有一个.pdb文件，该文件记录了代码中断点等调试信息；</li>
</ul>
</li>
<li>release发布版本：<ul>
<li>不对源代码进行调试</li>
<li>编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。（调试信息可在单独的PDB文件中生成）。</li>
<li>Release模式下生成一个文件.exe或.dll文件。</li>
</ul>
</li>
</ul>
<blockquote>
<p>实际上，Debug 和 Release 并没有本质的界限，他们只是一组编译选项的集合，编译器只是按照预定的选项行动。事实上，我们甚至可以修改这些选项，从而得到优化过的调试版本或是带跟踪语句的发布版本。</p>
</blockquote>
<h1 id="main函数的返回值"><a href="#main函数的返回值" class="headerlink" title="main函数的返回值"></a>main函数的返回值</h1><p>程序运行过程入口点<code>main()</code>函数，<code>main()</code>函数返回值类型必须是<code>int</code>，这样返回值才能传递给程序激活者（如操作系统）表示程序正常退出。</p>
<h1 id="简单的模板函数"><a href="#简单的模板函数" class="headerlink" title="简单的模板函数"></a>简单的模板函数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt; </span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">template&lt;typename type1,typename type2&gt;&#x2F;&#x2F;函数模板 </span><br><span class="line">type1 Max(type1 a,type2 b) </span><br><span class="line">&#123;</span><br><span class="line">  return a &gt; b ? a : b; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">  cout&lt;&lt;&quot;Max &#x3D; &quot;&lt;&lt;Max(5.5,&#39;a&#39;)&lt;&lt;endl; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h1 id="智能指针解决循环引用的问题"><a href="#智能指针解决循环引用的问题" class="headerlink" title="智能指针解决循环引用的问题"></a>智能指针解决循环引用的问题</h1><ul>
<li>弱指针用于专门解决<code>shared_ptr</code>循环引用的问题，<code>weak_ptr</code>不会修改引用计数，即其存在与否并不影响对象的引用计数器。</li>
<li>循环引用就是：两个对象互相使用一个<code>shared_ptr</code>成员变量指向对方。</li>
<li>弱引用并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。</li>
</ul>
<h1 id="strcpy函数和strncpy区别"><a href="#strcpy函数和strncpy区别" class="headerlink" title="strcpy函数和strncpy区别"></a>strcpy函数和strncpy区别</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char* strcpy(char* strDest, const char* strSrc)</span><br><span class="line">char* strncpy(char* strDest, const char* strSrc, int pos)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>strcpy()</code>函数：</li>
</ul>
<p>如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。</p>
<ul>
<li><code>strncpy()</code>函数：</li>
</ul>
<p>用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。</p>
<blockquote>
<ul>
<li>如果目标字符串长度&gt;指定字符串长度&gt;源字符串长度，则将源字符串全部拷贝到目标字符串，自动加上’\0’。</li>
<li>如果指定指定字符串长度&lt;源字符串长度，则将源字符串中按指定字符串长度拷贝到目标字符串，不包括’\0’。</li>
<li>如果指定字符串长度&gt;目标字符串长度，运行时错误。</li>
</ul>
</blockquote>
<h1 id="static-cast转换的优点"><a href="#static-cast转换的优点" class="headerlink" title="static_cast转换的优点"></a>static_cast转换的优点</h1><ul>
<li>更加安全</li>
<li>更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；可清楚地辨别代码中每个显式的强制转换；可读性更好，能体现程序员的意图。</li>
</ul>
<h1 id="成员函数调用memset-this-0-sizeof-this"><a href="#成员函数调用memset-this-0-sizeof-this" class="headerlink" title="成员函数调用memset(this,0,sizeof(*this))"></a>成员函数调用memset(this,0,sizeof(*this))</h1><ul>
<li>有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，</li>
<li>我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，</li>
<li>所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0。对于这种情形可以很好的工作。</li>
</ul>
<p>但是下面几种情形是不可以这么使用的：</p>
<ul>
<li>类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常；</li>
<li>类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。</li>
</ul>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><ul>
<li>当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；</li>
<li>回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此，你需要做三件事：<ul>
<li>声明</li>
<li>定义</li>
<li>设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用</li>
</ul>
</li>
<li>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；</li>
<li>因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。</li>
</ul>
<h1 id="纯虚函数和虚函数的区别"><a href="#纯虚函数和虚函数的区别" class="headerlink" title="纯虚函数和虚函数的区别"></a>纯虚函数和虚函数的区别</h1><ul>
<li>虚函数：<ul>
<li>虚函数是为了实现动态编联产生的</li>
<li>目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数。</li>
<li>虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。</li>
<li>当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。</li>
</ul>
</li>
<li>纯虚函数：<ul>
<li>纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。</li>
<li>纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用<code>=0</code>。</li>
<li>既然是虚函数，它的函数指针会被存在虚函数表中，由于纯虚函数并没有具体的函数体。因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址。</li>
<li>一个类中如果有纯虚函数的话，称其为抽象类。</li>
<li>抽象类不能用于实例化对象，否则会报错。</li>
<li>抽象类一般用于定义一些公有的方法。</li>
<li>子类继承抽象类也必须实现其中的纯虚函数才能实例化对象。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void fun1()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;普通虚函数&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void fun2() &#x3D; 0;</span><br><span class="line">	virtual ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Son : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void fun2() </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;子类实现的纯虚函数&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Base* b &#x3D; new Son;</span><br><span class="line">	b-&gt;fun1(); &#x2F;&#x2F;普通虚函数</span><br><span class="line">	b-&gt;fun2(); &#x2F;&#x2F;子类实现的纯虚函数</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="代码到可执行程序的过程"><a href="#代码到可执行程序的过程" class="headerlink" title="代码到可执行程序的过程"></a>代码到可执行程序的过程</h1><p><img src="https://jiajuu.top/2021/03/25/C%E8%89%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%E7%AC%AC%E4%B8%89%E5%BC%B9-%E6%8F%90%E9%AB%98%E7%AF%87/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png" alt="编译过程"></p>
<ul>
<li>预编译：处理<code>#</code>打头的预编译指令</li>
<li>编译：生成汇编代码</li>
<li>汇编：生成机器语言</li>
<li>链接<ul>
<li>静态链接<ul>
<li>空间浪费</li>
<li>更新困难</li>
<li>运行速度快</li>
</ul>
</li>
<li>动态链接<ul>
<li>共享库</li>
<li>更新方便</li>
<li>性能损耗</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="C语言实现继承"><a href="#C语言实现继承" class="headerlink" title="C语言实现继承"></a>C语言实现继承</h1><p>C++的继承：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++中的继承与多态</span><br><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">  virtual void fun()  &#x2F;&#x2F;C++中的多态:通过虚函数实现</span><br><span class="line">  &#123;</span><br><span class="line">    cout&lt;&lt;&quot;A:fun()&quot;&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  int a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct B:public A     &#x2F;&#x2F;C++中的继承:B类公有继承A类</span><br><span class="line">&#123;</span><br><span class="line">  virtual void fun()  &#x2F;&#x2F;C++中的多态:通过虚函数实现（子类的关键字virtual可加可不加）</span><br><span class="line">  &#123;</span><br><span class="line">   cout&lt;&lt;&quot;B:fun()&quot;&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  A a;  &#x2F;&#x2F;定义一个父类对象a</span><br><span class="line">  B b;  &#x2F;&#x2F;定义一个子类对象b</span><br><span class="line"></span><br><span class="line">  A* p1 &#x3D; &amp;a;  &#x2F;&#x2F;定义一个父类指针指向父类的对象</span><br><span class="line">  p1-&gt;fun();  &#x2F;&#x2F;调用父类的同名函数</span><br><span class="line">  p1 &#x3D; &amp;b;   &#x2F;&#x2F;让父类指针指向子类的对象</span><br><span class="line">  p1-&gt;fun();  &#x2F;&#x2F;调用子类的同名函数</span><br><span class="line">  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C语言实现继承与多态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">typedef void (*FUN)();   &#x2F;&#x2F;定义一个函数指针来实现对成员函数的继承</span><br><span class="line"></span><br><span class="line">struct _A    &#x2F;&#x2F;父类</span><br><span class="line">&#123;</span><br><span class="line">  FUN _fun;  &#x2F;&#x2F;由于C语言中结构体不能包含函数，故只能用函数指针在外面实现</span><br><span class="line">  int _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct _B     &#x2F;&#x2F;子类</span><br><span class="line">&#123;</span><br><span class="line">  _A _a_;   &#x2F;&#x2F;在子类中定义一个基类的对象即可实现对父类的继承</span><br><span class="line">  int _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void _fA()    &#x2F;&#x2F;父类的同名函数</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;_A:_fun()\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _fB()    &#x2F;&#x2F;子类的同名函数</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;_B:_fun()\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  _A _a;  &#x2F;&#x2F;定义一个父类对象_a</span><br><span class="line">  _B _b;  &#x2F;&#x2F;定义一个子类对象_b</span><br><span class="line">  </span><br><span class="line">  _a._fun &#x3D; _fA;    &#x2F;&#x2F;父类的对象调用父类的同名函数</span><br><span class="line">  _b._a_._fun &#x3D; _fB;  &#x2F;&#x2F;子类的对象调用子类的同名函数</span><br><span class="line"></span><br><span class="line">  _A* p2 &#x3D; &amp;_a;  &#x2F;&#x2F;定义一个父类指针指向父类的对象</span><br><span class="line">  p2-&gt;_fun();   &#x2F;&#x2F;调用父类的同名函数</span><br><span class="line">  p2 &#x3D; (_A*)&amp;_b; &#x2F;&#x2F;让父类指针指向子类的对象,由于类型不匹配所以要进行强转</span><br><span class="line">  p2-&gt;_fun();   &#x2F;&#x2F;调用子类的同名函数</span><br><span class="line">  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="动态编译与静态编译"><a href="#动态编译与静态编译" class="headerlink" title="动态编译与静态编译"></a>动态编译与静态编译</h1><ul>
<li>动态编译：<ul>
<li>动态编译的可执行文件需要附带一个动态链接库</li>
<li>在执行时，需要调用其对应动态链接库的命令。</li>
<li>所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。</li>
<li>缺点是哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</li>
</ul>
</li>
<li>静态编译：<ul>
<li>编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来</li>
<li>连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库；</li>
</ul>
</li>
</ul>
<h1 id="经典的锁"><a href="#经典的锁" class="headerlink" title="经典的锁"></a>经典的锁</h1><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><ul>
<li>多个读者可以同时进行读</li>
<li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li>
<li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li>
</ul>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><ul>
<li>一次只能一个线程拥有互斥锁，其他线程只有等待</li>
<li>互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒</li>
<li>而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。</li>
<li>互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右</li>
<li>而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</li>
</ul>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><ul>
<li>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。</li>
<li>而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，</li>
<li>他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。</li>
<li>一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。</li>
<li>总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。</li>
</ul>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><ul>
<li>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。</li>
<li>如果别的线程长时期占有锁那么自旋就是在浪费CPU做无用功</li>
<li>但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</li>
</ul>
<h1 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h1><p>C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去。</p>
<h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><ul>
<li>左值：</li>
</ul>
<p>表示的是可以获取地址的表达式，它能出现在赋值语句的左边，能对该表达式进行赋值。但是修饰符const的出现使得可以声明如下的标识符，它可以取得地址，但是没办法对其进行赋值。</p>
<ul>
<li>右值：</li>
</ul>
<p>表示无法获取地址的对象，有常量值、函数返回值、lambda表达式等。无法获取地址，但不表示其不可改变，当定义了右值的右值引用时就可以更改右值。</p>
<h2 id="左值引用和右值引用-1"><a href="#左值引用和右值引用-1" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h2><ul>
<li>左值引用：</li>
</ul>
<p>传统的C++中引用被称为左值引用</p>
<ul>
<li>右值引用：</li>
</ul>
<p>C++11中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置。</p>
<h3 id="右值引用的特点"><a href="#右值引用的特点" class="headerlink" title="右值引用的特点"></a>右值引用的特点</h3><ul>
<li>通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。</li>
<li>右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。</li>
<li>T&amp;&amp; t在发生自动类型推断的时候，它是左值还是右值取决于它的初始化。</li>
</ul>
<p>我们举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void fun(T&amp;&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getInt()</span><br><span class="line">&#123;</span><br><span class="line">	return 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int a &#x3D; 10;</span><br><span class="line">	int&amp; b &#x3D; a;  &#x2F;&#x2F;b是左值引用</span><br><span class="line">	int&amp; c &#x3D; 10;  &#x2F;&#x2F;错误，c是左值不能使用右值初始化</span><br><span class="line">	int&amp;&amp; d &#x3D; 10;  &#x2F;&#x2F;正确，右值引用用右值初始化</span><br><span class="line">	int&amp;&amp; e &#x3D; a;  &#x2F;&#x2F;错误，e是右值引用不能使用左值初始化</span><br><span class="line">	const int&amp; f &#x3D; a; &#x2F;&#x2F;正确，左值常引用相当于是万能型，可以用左值或者右值初始化</span><br><span class="line">	const int&amp; g &#x3D; 10;&#x2F;&#x2F;正确，左值常引用相当于是万能型，可以用左值或者右值初始化</span><br><span class="line">	const int&amp;&amp; h &#x3D; 10; &#x2F;&#x2F;正确，右值常引用</span><br><span class="line">	const int&amp; aa &#x3D; h;&#x2F;&#x2F;正确</span><br><span class="line">	int&amp; i &#x3D; getInt();  &#x2F;&#x2F;错误，i是左值引用不能使用临时变量（右值）初始化</span><br><span class="line">	int&amp;&amp; j &#x3D; getInt();  &#x2F;&#x2F;正确，函数返回值是右值</span><br><span class="line">	fun(10); &#x2F;&#x2F;此时fun函数的参数t是右值</span><br><span class="line">	fun(a); &#x2F;&#x2F;此时fun函数的参数t是左值</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote>
<p>转载自<a href="https://github.com/forthespada/InterviewGuide">https://github.com/forthespada/InterviewGuide</a>，感激大佬的整理和分享！</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++知识点整理第二弹-进阶篇</title>
    <url>/2021/03/12/C%E8%89%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%E7%AC%AC%E4%BA%8C%E5%BC%B9-%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
    <content><![CDATA[<h1 id="static的作用和用法"><a href="#static的作用和用法" class="headerlink" title="static的作用和用法"></a>static的作用和用法</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>最重要的作用：隐藏。（static函数、static变量均可）</li>
</ol>
<p>当同时编译多个文件时，所有未加<code>static</code>修饰的全局变量和函数都具有全局可见性。</p>
<ol start="2">
<li>保持变量内容的持久</li>
</ol>
<p><code>static</code>修饰的变量具有记忆功能和全局生存期</p>
<ol start="3">
<li>默认初始化</li>
</ol>
<p>存储在静态数据区的变量，内存中所有字节默认都是0x00，，会在程序刚开始运行时就完成初始化（也是唯一的一次初始化）。</p>
<ol start="4">
<li>为类成员声明静态属性</li>
</ol>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul>
<li><p>非类内使用：</p>
<ol>
<li>函数体内的static变量的作用范围为该函数体，该变量只有一次内存分配和初始化，因此其值在下次调用时仍然维持上一次的值</li>
<li>在模块内的static全局变量可以被同模块内的函数调用，但不能被模块外的函数访问</li>
<li>模块内的static函数可以被同模块内的其他函数调用，该函数的使用范围被限制在声明该变量的模块内</li>
</ol>
</li>
<li><p>类内使用：</p>
<ol>
<li><p>在类中的static成员变量属于整个类所拥有，对类的所有对象仅有一份拷贝</p>
</li>
<li><p>在类中的static成员函数数据整个类所拥有，该函数不接受this指针，因此只能访问类的static成员变量</p>
</li>
<li><p>static修饰的类变量/对象必须在类外进行初始化，static修饰的变量需要先于对象存在</p>
</li>
<li><p>static成员函数不能被<code>virtual</code>关键字修饰，因为static成员函数不属于任何对象，所以加上virtual没有任何实际意义</p>
<blockquote>
<p>因为静态成员函数没有this指针，虚函数的实现时为每一个对象分配一个vptr指针，而vptr是通过this指针调用的。</p>
<p>补充：虚函数的调用关系：<strong>this -&gt; vptr -&gt; vtable -&gt; virtual function</strong></p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h1 id="静态变量初始化的时机"><a href="#静态变量初始化的时机" class="headerlink" title="静态变量初始化的时机"></a>静态变量初始化的时机</h1><ol>
<li><p>初始化只有一次，但可以重复赋值，在主程序之前，编译器已经为其分配好内存</p>
</li>
<li><p>静态局部变量和全局变量一样，数据存放在全局数据区，在主程序之前编译器已为其分配空间</p>
</li>
<li><p>C和C++的静态局部变量初始化节点是不一样的</p>
<ul>
<li><p>C语言中，初始化发生在代码执行之前，编译分配内存之后，所以我们无法通过变量对静态局部变量进行初始化</p>
</li>
<li><p>C++中，在执行相关代码时才会进行初始化，所以我们可以通过变量对静态局部变量进行初始化</p>
<blockquote>
<p>因为C++中引入对象，要进行初始化必须执行相应的构造函数，在构造函数经常会需要通过变量进行特定操作，并非简单的分配内存。<br>所以C++标准定为全局或静态对象是在首次用到的时候才会构造，并通过<code>atexit()</code>来管理。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h1 id="const作用"><a href="#const作用" class="headerlink" title="const作用"></a>const作用</h1><ol>
<li><p>阻止变量被修改，用const定义变量时需要对其初始化，因为未来便没有机会再去改变它了。</p>
</li>
<li><p>可以指定指针本身为const，也可以指定指针指向的数据为const，又可以两者都指定为const。</p>
</li>
<li><p>在函数声明中，const可以修饰形参，表明输入的参数在函数中不能被更改。</p>
</li>
<li><p>对于类的成员函数，若指定为const，则表示这是一个常函数，不能改变类的成员变量。</p>
</li>
<li><p>对于类的对象，若指定为const，则表示这是一个常对象，只能访问类的常成员函数。</p>
</li>
<li><p>对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为”左值”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int&amp; min ( int &amp;i, int &amp;j);</span><br><span class="line">min(a,b) &#x3D; 4;&#x2F;&#x2F;返回一个引用，所以可以作为左值使用</span><br><span class="line"></span><br><span class="line">const int &amp; min ( int &amp; i, int &amp;j );</span><br><span class="line">&#x2F;&#x2F;min(a,b) &#x3D; 4; &#x2F;&#x2F;不能作为左值，会编译报错</span><br></pre></td></tr></table></figure></li>
<li><p>const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象的所有数据成员</p>
</li>
<li><p>非const成员可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据或函数</p>
<blockquote>
<p><strong>第7，8点：</strong></p>
<ul>
<li>没有明确声明为const的成员函数，编译器会认为是修改对象中的数据成员的函数，所以常对象只能调用常函数</li>
<li>const成员函数不允许修改数据成员，所以对任何对象的数据成员访问都没有冲突</li>
<li>但是非const成员函数允许修改数据成员，若其可以访问const对象的话，修改其成员数据便造成冲突</li>
</ul>
</blockquote>
</li>
<li><p>const类型变量可以通过类型转换符const_cast将const类型转换为非const类型</p>
</li>
<li><p>const类型变量在定义时进行初始化，所以类的成员变量被const所修饰，那么该变量必须在类的初始化列表中初始化；</p>
</li>
<li><p>对于函数的值传递，在形参用不用const修饰都没有影响，因为临时变量无法更改实参</p>
</li>
<li><p>对于函数的指针或引用传递，可以通过形参改变实参，所以const修饰形参能够起到保护实参的作用</p>
</li>
</ol>
<h1 id="指针和const的用法"><a href="#指针和const的用法" class="headerlink" title="指针和const的用法"></a>指针和const的用法</h1><ol>
<li>当const修饰指针时，由于const的位置不同，它的修饰对象也不一样</li>
<li>int* const p修饰的是<code>p</code>指针，这是一个顶层指针，表示p指针的指向不能改变，但是可以通过这个指针读写地址上的值</li>
<li><code>int const *p</code>或者<code>const int *p</code>修饰的<code>*p</code>，这是一个底层指针，表示指针指向的地址上的值不能硅钙，但可以改变<code>p</code>的指向。</li>
</ol>
<h1 id="形参和实参的区别"><a href="#形参和实参的区别" class="headerlink" title="形参和实参的区别"></a>形参和实参的区别</h1><ol>
<li>形参变量在被调用才会分配内存，在调用结束后，会立即释放掉所分配的内存。所以，形参只有在函数内部有效，函数调用结束返回主函数后便无法再使用该形参变量</li>
<li>实参可以是常量、变量、表达式、函数等，无论实参是什么类型，在调用函数时，它们都必须具有确定的值以便赋值给形参。</li>
<li>实参和形参在数量上，类型上，顺序上应该严格一直，否则会发生类型不匹配</li>
<li>函数调用中发生的数据传递是单向的，只能实参的值传给形参，因此函数调用中，形参的值发生改变，实参中的值并不会发生改变</li>
<li>但形参和实参不是指针类型时，在该函数运行时，形参和实参实质上是不同的变量，它们在内存中的不同位置，形参将实参的内容复制一份，在函数运行结束后形参会被释放，而实参的内容不会改变</li>
</ol>
<h1 id="值传递、指针传递、引用传递"><a href="#值传递、指针传递、引用传递" class="headerlink" title="值传递、指针传递、引用传递"></a>值传递、指针传递、引用传递</h1><h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><p>形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象或是一个大的结构体对象的话，将耗费一定的时间和空间。</p>
<h2 id="指针传递"><a href="#指针传递" class="headerlink" title="指针传递"></a>指针传递</h2><p>同样是形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定的4字节的地址。</p>
<h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><p>同样是形参向函数所述栈拷贝数据的过程，但针对的是地址的，相当于为该数据所在地址起别名</p>
<h2 id="效率比较"><a href="#效率比较" class="headerlink" title="效率比较"></a>效率比较</h2><p>指针和引用传递都比值传递效率高，但主张使用的还是应用传递，因为代码逻辑更加紧凑、清晰</p>
<h1 id="类的关系"><a href="#类的关系" class="headerlink" title="类的关系"></a>类的关系</h1><ul>
<li>has包含关系</li>
</ul>
<p>表示一个类由另一个类构成，即一个类的成员属性是另一个已定义好的类</p>
<ul>
<li>use使用关系</li>
</ul>
<p>一个类使用另一个类，通过类之间的成员函数相互联系，即定义友元或者传递参数的方式实现</p>
<ul>
<li>is继承关系</li>
</ul>
<p>一个类继承了另一个类的属性和方法，这个类包含被继承类的属性和方法，该类我们称作子类或者派生类</p>
<p>而被继承的类我们称为父类或者基类。且子类对象可以当作父类对象使用；</p>
<h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><ul>
<li>特点</li>
</ul>
<p>子类拥有父类的所有属性和方法（构造和析构除外）</p>
<ul>
<li>继承方式<ul>
<li>public</li>
<li>protected</li>
<li>private</li>
</ul>
</li>
<li>继承中的构造和析构<ul>
<li>构造顺序：父类构造函数 -&gt; 子类构造函数</li>
<li>析构顺序：子类构造函数 -&gt; 父类构造函数</li>
</ul>
</li>
<li>继承中的兼容性原则<ul>
<li>子类对象可以当作父类对象使用</li>
<li>父类指针可以指向子类对象</li>
<li>父类引用可以直接引用子类对象</li>
<li>子类对象可以直接初始化父类对象</li>
<li>子类对象可以直接赋值给父类对象</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    int m_a;</span><br><span class="line">    int m_b;</span><br><span class="line">public:</span><br><span class="line">    Parent()</span><br><span class="line">    &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Parent构造函数&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void setab(int a, int b)</span><br><span class="line">    &#123;</span><br><span class="line">    m_a &#x3D; a;</span><br><span class="line">    m_b &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line">    void show()</span><br><span class="line">    &#123;</span><br><span class="line">    cout &lt;&lt; &quot;m_a&#x3D;&quot; &lt;&lt; m_a &lt;&lt; &quot;  &quot; &lt;&lt; &quot;m_b&#x3D;&quot; &lt;&lt; m_b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Parent()</span><br><span class="line">    &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Parent析构函数&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Child : public Parent</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int m_c;</span><br><span class="line">public:</span><br><span class="line">    Child()</span><br><span class="line">    &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Child构造函数&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void setc(int c)</span><br><span class="line">    &#123;</span><br><span class="line">    m_c &#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">    cout &lt;&lt; &quot;m_c&#x3D;&quot; &lt;&lt; m_c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Child()</span><br><span class="line">    &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Child析构函数&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;*模块一：子类对象可当成父类对象使用*&#x2F;</span><br><span class="line">    &#x2F;*Child c;      &#x2F;&#x2F;检验 子类对象能否当成父类对象使用    结果可以</span><br><span class="line">    c.setc(3);</span><br><span class="line">    c.setab(1,2);</span><br><span class="line">    c.show();</span><br><span class="line">    c.print();*&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;*模块二：父类指针指向子类对象*&#x2F;</span><br><span class="line">    &#x2F;*Child c;</span><br><span class="line">    c.setc(3);</span><br><span class="line">    c.setab(1,2);</span><br><span class="line">    Child *pc &#x3D; &amp;c; &#x2F;&#x2F;子类指针指向子类对象    </span><br><span class="line">    pc-&gt;show();</span><br><span class="line">    pc-&gt;print();</span><br><span class="line"></span><br><span class="line">    Parent *p &#x3D; &amp;c; &#x2F;&#x2F;父类指针指向子类对象</span><br><span class="line">    p-&gt;setab(3,4);</span><br><span class="line">    p-&gt;show();</span><br><span class="line">    &#x2F;&#x2F;p-&gt;setc(5);   &#x2F;&#x2F;经检验 父类指针确实可以指向子类对象  但父类指针是Parent类型 它只能作用Parent成员对象和函数对子类的其他成员变量和函数不起作用</span><br><span class="line">    &#x2F;&#x2F;p-&gt;print();*&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;*模块三：基类的引用可直接引用派生类对象*&#x2F;</span><br><span class="line">    &#x2F;*Child c;</span><br><span class="line">    c.setc(6);</span><br><span class="line">    c.setab(7,8);</span><br><span class="line">    Parent &amp;p &#x3D; c;</span><br><span class="line"></span><br><span class="line">    p.show();       &#x2F;&#x2F;父类引用只能引用父类  子类不可以  （另外：引用是常指针  情况和模块二一样）</span><br><span class="line">    &#x2F;&#x2F;p.print();*&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;*模块四：子类对象可以直接初始化基类对象*&#x2F;</span><br><span class="line">    &#x2F;*Child c;</span><br><span class="line">    c.setc(10);</span><br><span class="line">    c.setab(11,12);</span><br><span class="line"></span><br><span class="line">    Parent p &#x3D; c;   &#x2F;&#x2F;c是子类对象，用子类对象直接对父类对象p进行初始化，这里会调用p的拷贝构造函数：Parent(const Parent &amp;obj) 拷贝构造函数形参是基类的引用  这就回到模块三 基类的引用可以直接引用派生类的对象</span><br><span class="line">    p.show();</span><br><span class="line">    &#x2F;&#x2F;p.print();*&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;*模块五：子类对象可直接赋值给父类对象*&#x2F;</span><br><span class="line">    Child c;</span><br><span class="line">    c.setc(13);</span><br><span class="line">    c.setab(14,15);</span><br><span class="line"></span><br><span class="line">    Parent p;</span><br><span class="line">    p &#x3D; c;  &#x2F;&#x2F;c是派生类对象，用派生类对象直接赋值给基类对象p，赋值操作不会调用对象的构造函数，但是会调用对象赋值运算符重载函数 Parent operator&#x3D;(const Parent &amp;obj)  赋值运算符重载函数的参数也是一个基类的引用</span><br><span class="line">    p.show();</span><br><span class="line">    &#x2F;&#x2F;p.print();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="内存池概念和实现"><a href="#内存池概念和实现" class="headerlink" title="内存池概念和实现"></a>内存池概念和实现</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>内存池是一种<strong>内存分配</strong>方式，通常我们习惯直接使用<code>new</code>、<code>malloc</code>申请内存</li>
<li>但这样的缺点在于：我们申请的内存块大小不定，当频繁使用时会造成大量的内存碎片而降低性能。</li>
<li>内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等的内存块留作备份。</li>
<li>当有新的内存需求时，就从内存池分出一部分内存块，</li>
<li>若内存块不够再继续申请新的内存</li>
<li>这样的作法可以显著减少了内存碎片，使得内存分配效率得到了很大的提升</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>使用allocate向内存池请求size大小的内存空间，如果需要请求的大小大于128bytes，直接malloc获得内存</li>
<li>如果需要的内存小于128bytes，allocate会根据size找到最合适的自由链表<ul>
<li>如果链表不为空，返回第一个node，链表头改为第二个node。</li>
<li>如果链表为空，使用blockAlloc请求分配node<ul>
<li>如果内存池中有大于一个node的空间，分配会尽可能多的node（最多20个），并将一个node返回，其他的node添加到链表中</li>
<li>如果内存池只有一个node的空间，直接返回给用户</li>
<li>如果连一个node都没有，再次向操作系统请求分配内存<ul>
<li>分配成功后再使用blockAlloc请求分配node</li>
<li>分配失败后，循环各个自由链表寻找空间<ul>
<li>找到空间，再使用blockAlloc请求分配node</li>
<li>找不到空间，抛出异常</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>用户调用deallocate释放内存空间，如果要求释放的内存空间大于128byte，直接调用free</li>
<li>否则按照其大小找到合适的自由链表并将其插入</li>
</ul>
<ul>
<li>STL的allocator比较好的实现规则<ul>
<li>分配器维护着一条0-15号的链表，其中第0号链表存储<code>1*8byte</code>大小的数据，第1号链表存储<code>2*8byte</code>大小的数据…直至第15号<code>16*8byte</code>大小的数据</li>
<li>如果申请的不是8的整数倍，那么就找到刚好满足内存大小的位置。（例如：申请12byte，我们就找到16byte的链表）</li>
</ul>
</li>
</ul>
<h1 id="汇编层解释引用"><a href="#汇编层解释引用" class="headerlink" title="汇编层解释引用"></a>汇编层解释引用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9:      int x &#x3D; 1; &#x2F;&#x2F;x的地址为ebp-4</span><br><span class="line">10:     int &amp;b &#x3D; x;  &#x2F;&#x2F;b的地址为ebp-8</span><br><span class="line">&#x2F;&#x2F;因为栈的变量是从内存的高往低进行分配的，所以b的地址比x的低</span><br><span class="line"></span><br><span class="line">00401048  mov     dword ptr [ebp-4],1</span><br><span class="line"></span><br><span class="line">0040104F   lea     eax,[ebp-4]  &#x2F;&#x2F;将x的地址放去eax寄存器</span><br><span class="line">00401052  mov     dword ptr [ebp-8],eax  &#x2F;&#x2F;将eax的值放入b的地址</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看出，这和将某个变量的地址存入指针变量是一样的，所以从汇编层次来看，引用的本质其实就是<code>int* const b</code></p>
</blockquote>
<h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><ul>
<li>浅拷贝</li>
</ul>
<p>仅拷贝了基本类型的数据，而引用类型数据在拷贝后会发生引用。换句话说，引用类型的浅拷贝只是指向被拷贝的内存地址，若原地址数据被改变了，那么浅拷贝出来的对象也会发生改变</p>
<ul>
<li>深拷贝</li>
</ul>
<p>在计算机中开辟了一块新的内存地址用于存放拷贝的对象</p>
<blockquote>
<p>在某些情况下，类内对象变量需要动态开辟堆内存，若实行的是浅拷贝，对象B的指针指向了对象A已经申请好的内存，那么当对象B把内存释放后，对象A的指针就是野指针，运行的时候会发生错误。</p>
</blockquote>
<h1 id="C-模板的底层实现"><a href="#C-模板的底层实现" class="headerlink" title="C++模板的底层实现"></a>C++模板的底层实现</h1><ul>
<li>编译器并不是把函数模板处理成能够处理任意类的函数</li>
<li>编译器从函数模板通过具体类型产生不同的函数</li>
<li>编译器会对函数模板进行两次编译</li>
<li>在声明的地方对模板代码本身进行编译</li>
<li>在调用的地方对参数替换后的代码在进行一遍编译</li>
</ul>
<blockquote>
<p>函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件只有声明没有定义，那编译器将无法实例化该模板，最终导致链接错误</p>
</blockquote>
<h1 id="new和malloc区别"><a href="#new和malloc区别" class="headerlink" title="new和malloc区别"></a>new和malloc区别</h1><ul>
<li>new/delete是C++关键字，需要编译器支持；malloc/free是库函数，需要头文件支持</li>
<li>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算；而malloc则需要显式地指出所需内存的尺寸</li>
<li>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符；而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型</li>
<li>new内存分配失败时，会抛出bac_alloc异常；malloc分配内存失败时返回NULL</li>
<li>new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）；malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作</li>
</ul>
<h1 id="new-delete-、allocator作用"><a href="#new-delete-、allocator作用" class="headerlink" title="new[]/delete[]、allocator作用"></a>new[]/delete[]、allocator作用</h1><ul>
<li>动态数组new[]一个数组时，[]中必须是一个整数，但是不一定是常量整数，普通数组必须是一个常量整数；</li>
<li>new[]动态数组返回的并不是数组类型，而是一个元素类型的指针；</li>
<li>delete[]时，数组中的元素按逆序的顺序进行销毁；</li>
<li>new在内存分配上面有一些局限性，new的机制是将内存分配和对象构造组合在一起，同样的，delete也是将对象析构和内存释放组合在一起的。</li>
<li>allocator将这两部分分开进行，allocator申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作。</li>
</ul>
<h1 id="new和delete的实现"><a href="#new和delete的实现" class="headerlink" title="new和delete的实现"></a>new和delete的实现</h1><h2 id="new的实现"><a href="#new的实现" class="headerlink" title="new的实现"></a>new的实现</h2><ul>
<li>new简单类型，直接调用<code>operator new()</code>分配内存；</li>
<li>new复杂类型，先调用<code>operator new()</code>分配内存，然后在分配的内存上调用构造函数；</li>
<li>new[]简单类型，计算好大小后调用<code>operator new()</code>分配内存；</li>
<li>new[]复杂类型，先调用operator new[]分配内存，然后在p的前四个字节写入数组大小n，然后调用n次构造函数，针对复杂类型，new[]会额外存储数组大小<ol>
<li>new表达式调用一个名为<code>operator new(operator new[])</code>函数，分配一块足够大的、原始的、未命名的内存空间</li>
<li>编译器运行相应的构造函数以构造这些对象，并为其传入初始值</li>
<li>对象被分配了空间并构造完成，返回一个指向该对象的指针</li>
</ol>
</li>
</ul>
<h2 id="delete的实现"><a href="#delete的实现" class="headerlink" title="delete的实现"></a>delete的实现</h2><ul>
<li>delete简单数据类型默认只是调用free函数</li>
<li>复杂数据类型先调用析构函数再调用operator delete</li>
<li>假设指针p指向new[]分配的内存。因为要4字节存储数组大小，实际分配的内存地址为[p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存。而delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。</li>
</ul>
<blockquote>
<p>delete是如何知道释放内存大小呢？</p>
<p>答：需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了，析构完后再调用operator delete函数释放空间</p>
</blockquote>
<h1 id="malloc申请的存储空间可以用delete释放吗"><a href="#malloc申请的存储空间可以用delete释放吗" class="headerlink" title="malloc申请的存储空间可以用delete释放吗"></a>malloc申请的存储空间可以用delete释放吗</h1><ul>
<li>不能，错配使用容易导致内存泄露。</li>
</ul>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    void * t;</span><br><span class="line">    public A()&#123;</span><br><span class="line">        t&#x3D;malloc(100);</span><br><span class="line">    &#125;</span><br><span class="line">    public ~A() &#123;</span><br><span class="line">        free(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">void main() &#123;</span><br><span class="line">A *n&#x3D;(A *)malloc(sizeof(A)); &#x2F;&#x2F;导致构造函数没执行</span><br><span class="line">delete n; &#x2F;&#x2F;因为没有执行构造函数，所以t没有分配到空间，但delete会执行析构函数，释放t的内存空间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。</p>
</blockquote>
<h1 id="malloc与free的实现"><a href="#malloc与free的实现" class="headerlink" title="malloc与free的实现"></a>malloc与free的实现</h1><ul>
<li>在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk、mmap、，munmap这些系统调用实现的</li>
<li>brk是将数据段(.data)的最高地址指针_edata往高地址推</li>
<li>mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存</li>
<li>这两种方式分配的都是虚拟内存，没有分配物理内存</li>
<li>在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系</li>
<li>malloc小于128k的内存，使用brk分配内存，将_edata往高地址推</li>
<li>malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配</li>
<li>brk分配的内存需要等到高地址内存释放以后才能释放</li>
<li>当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是进行一遍内存紧缩</li>
<li>而mmap分配的内存可以单独释放。</li>
<li>malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存</li>
<li>操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请内存时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</li>
</ul>
<h1 id="malloc、realloc、calloc区别"><a href="#malloc、realloc、calloc区别" class="headerlink" title="malloc、realloc、calloc区别"></a>malloc、realloc、calloc区别</h1><ul>
<li>malloc函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void* malloc(unsigned int num_size);</span><br><span class="line"></span><br><span class="line">int *p &#x3D; malloc(20*sizeof(int)); &#x2F;&#x2F;申请20个int类型的空间；</span><br></pre></td></tr></table></figure>
<ul>
<li>realloc函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void realloc(void *p, size_t new_size);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>给动态分配的空间分配额外的空间，用于扩充容量。</p>
</blockquote>
<ul>
<li>calloc函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void* calloc(size_t n,size_t size);</span><br><span class="line"></span><br><span class="line">int *p &#x3D; calloc(20, sizeof(int));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；</p>
</blockquote>
<h1 id="类成员的初始化方式"><a href="#类成员的初始化方式" class="headerlink" title="类成员的初始化方式"></a>类成员的初始化方式</h1><ul>
<li>赋值初始化（通过在函数体内进行赋值初始化）</li>
</ul>
<p>在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。</p>
<ul>
<li>列表初始化（在冒号后使用初始化列表进行初始化）</li>
</ul>
<p>给数据成员分配内存空间时就进行初始化，换句话说分配一个数据成员只要冒号后有此数据成员的赋值表达式（此表达式必须是括号赋值表达式），那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。</p>
<blockquote>
<p>为什么用成员初始化列表会快一些？</p>
<p>答：方法一是在构造函数当中做赋值的操作，而方法二是做纯粹的初始化操作。我们都知道，C++的赋值操作是会产生临时对象的。临时对象的出现会降低程序的效率。</p>
</blockquote>
<h1 id="构造函数的执行顺序"><a href="#构造函数的执行顺序" class="headerlink" title="构造函数的执行顺序"></a>构造函数的执行顺序</h1><ol>
<li>虚拟基类的构造函数（多个虚拟基类则按照继承表的出现顺序执行构造函数）。</li>
<li>基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。</li>
<li>类类型的成员对象的构造函数（按照初始化顺序）</li>
<li>派生类自己的构造函数。</li>
</ol>
<h1 id="成员列表初始化"><a href="#成员列表初始化" class="headerlink" title="成员列表初始化"></a>成员列表初始化</h1><ul>
<li>必须使用成员初始化的四种情况<ul>
<li>当初始化一个引用成员时</li>
<li>当初始化一个常量成员时</li>
<li>当调用一个基类的构造函数，而构造函数拥有一组参数时</li>
<li>当调用一个成员类的构造函数，而构造函数拥有一组参数时</li>
</ul>
</li>
<li>成员初始化列表做了什么<ul>
<li>编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，在构造函数中的用户代码之前</li>
<li>列表中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的</li>
</ul>
</li>
<li>效率的提升<ul>
<li>对于类类型，它少了一次调用构造函数，而在函数体中的赋值则会多一次调用</li>
<li>而对于基本数据类型则没有区别</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;默认构造函数A()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    A(int a)</span><br><span class="line">    &#123;</span><br><span class="line">        value &#x3D; a;</span><br><span class="line">        cout &lt;&lt; &quot;A(int &quot;&lt;&lt;value&lt;&lt;&quot;)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    A(const A&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        value &#x3D; a.value;</span><br><span class="line">        cout &lt;&lt; &quot;拷贝构造函数A(A&amp; a):  &quot;&lt;&lt;value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    int value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    B() : a(1)</span><br><span class="line">    &#123;</span><br><span class="line">        b &#x3D; A(2);</span><br><span class="line">    &#125;</span><br><span class="line">    A a;</span><br><span class="line">    A b;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">&#x2F;&#x2F;A(int 1)</span><br><span class="line">&#x2F;&#x2F;默认构造函数A()</span><br><span class="line">&#x2F;&#x2F;A(int 2)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从代码运行结果可以看出，初始化列表会比构造函数赋值多了一次构造函数的调用，但这是为什么呢？</p>
<p>答：这是因为对象成员变量的初始化动作发生在进入构造函数之前，对于内置类型没什么影响，但<strong>如果有些成员是类</strong>，那么在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是一次赋值操作(对象已存在)，所以<strong>如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋值，而初始化列表只做一次赋值操作。</strong></p>
</blockquote>
<h1 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h1><p>一般我们常说的内存泄漏是指<strong>堆内存的泄漏</strong>。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了</p>
<ul>
<li>避免内存泄露的方式<ul>
<li>使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</li>
<li>一定要将基类的析构函数声明为<strong>虚函数</strong></li>
<li>对象数组的释放一定要用<strong>delete []</strong></li>
<li>有new就有delete，有malloc就有free，保证它们一定成对出现</li>
</ul>
</li>
</ul>
<h1 id="对象复用和零拷贝"><a href="#对象复用和零拷贝" class="headerlink" title="对象复用和零拷贝"></a>对象复用和零拷贝</h1><ul>
<li>对象复用</li>
</ul>
<p>通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。</p>
<ul>
<li>零拷贝</li>
</ul>
<p>零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术，减少数据拷贝和共享总线操作的次数。</p>
<blockquote>
<p>在C++中，vector的一个成员函数<strong>emplace_back()**很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：</strong>使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造**，效率更高。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Person</span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    int age;</span><br><span class="line">    &#x2F;&#x2F;初始构造函数</span><br><span class="line">    Person(string p_name, int p_age): name(std::move(p_name)), age(p_age)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; &quot;I have been constructed&quot; &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">     &#x2F;&#x2F;拷贝构造函数</span><br><span class="line">     Person(const Person&amp; other): name(std::move(other.name)), age(other.age)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; &quot;I have been copy constructed&quot; &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">     &#x2F;&#x2F;转移构造函数</span><br><span class="line">     Person(Person&amp;&amp; other): name(std::move(other.name)), age(other.age)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; &quot;I have been moved&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;Person&gt; e;</span><br><span class="line">    cout &lt;&lt; &quot;emplace_back:&quot; &lt;&lt;endl;</span><br><span class="line">    e.emplace_back(&quot;Jane&quot;, 23); &#x2F;&#x2F;不用构造类对象</span><br><span class="line"></span><br><span class="line">    vector&lt;Person&gt; p;</span><br><span class="line">    cout &lt;&lt; &quot;push_back:&quot;&lt;&lt;endl;</span><br><span class="line">    p.push_back(Person(&quot;Mike&quot;,36));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">&#x2F;&#x2F;emplace_back:</span><br><span class="line">&#x2F;&#x2F;I have been constructed</span><br><span class="line">&#x2F;&#x2F;push_back:</span><br><span class="line">&#x2F;&#x2F;I have been constructed</span><br><span class="line">&#x2F;&#x2F;I am being moved.</span><br></pre></td></tr></table></figure>


<h1 id="trivial-destructor"><a href="#trivial-destructor" class="headerlink" title="trivial destructor"></a>trivial destructor</h1><ul>
<li>“trivial destructor”一般是指用户没有自定义析构函数，而由系统生成的，这种析构函数在《STL源码解析》中成为“无关痛痒”的析构函数。</li>
<li>反之，用户自定义了析构函数，则称之为“non-trivial destructor”，这种析构函数<strong>如果申请了新的空间一定要显式的释放，否则会造成内存泄露</strong></li>
<li>对于trivial destructor，如果每次都调用，显然会对效率是一种伤害，那么如何判断呢？</li>
</ul>
<blockquote>
<p>《STL源码解析》中给出了说明：</p>
<p>首先利用<code>value_type()</code>获取所指对象的型别，再利用<code>__type_traits</code>判断该型别的析构函数是否trivial，若是<code>__true_type</code>，则什么也不做，若为<code>__false_type</code>，则去调用destory()函数</p>
</blockquote>
<h1 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h1><ul>
<li>继承</li>
<li>封装</li>
<li>特性</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>以一个类为基础，获得其属性和方法，并在其基础上进行扩展和补充</p>
<ul>
<li>常见的继承方式<ul>
<li>实现继承：指使用基类的属性和方法而无需额外编码的能力</li>
<li>接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力</li>
<li>可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力</li>
</ul>
</li>
</ul>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>对不可信的外界进行信息隐藏，只允许外界通过接口修改内部数据。避免外界干扰和不确定性访问</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>向不同对象发送同一消息，不同对象在接受时产生不同的行为</p>
<ul>
<li>函数重载实现了编译时多态。实现方式：重载</li>
<li>虚函数实现了运行时多态。实现方式：重写</li>
</ul>
<h1 id="类的内存分配"><a href="#类的内存分配" class="headerlink" title="类的内存分配"></a>类的内存分配</h1><ul>
<li>C++的类是从结构体发展而来的，所以两者的内存分配机制时一样的。</li>
<li>一个类对象的地址就是类包含的这片内存空间的首地址</li>
<li>这个首地址就对应着具体某一个成员变量的地址</li>
<li>在定义类对象的同时这些成员变量也被定义了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Person()</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;age &#x3D; 23;</span><br><span class="line">    &#125;</span><br><span class="line">    void printAge()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; this-&gt;age &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person()&#123;&#125;</span><br><span class="line">public:</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; &quot;对象地址：&quot;&lt;&lt; &amp;p &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; &quot;age地址：&quot;&lt;&lt; &amp;(p.age) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; &quot;对象大小：&quot;&lt;&lt; sizeof(p) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; &quot;age大小：&quot;&lt;&lt; sizeof(p.age) &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">&#x2F;&#x2F;对象地址：0x7fffec0f15a8</span><br><span class="line">&#x2F;&#x2F;age地址：0x7fffec0f15a8</span><br><span class="line">&#x2F;&#x2F;对象大小：4</span><br><span class="line">&#x2F;&#x2F;age大小：4</span><br></pre></td></tr></table></figure>
<ul>
<li>类对象的大小和对象中数据成员的大小是一致的，换句话说，成员函数不占用对象内存</li>
<li>因为所有的函数都是存放在代码区的，不管是全局函数还是成员函数</li>
</ul>
<h1 id="构造函数不能为虚函数"><a href="#构造函数不能为虚函数" class="headerlink" title="构造函数不能为虚函数"></a>构造函数不能为虚函数</h1><ul>
<li>内存空间角度：<ul>
<li>虚函数对应着一个指向vtable虚函数表的指针，这个指针指向vtable事实上是存放在对象的内存空间上</li>
<li>若我们假设构造函数是虚的，就需要通过vtable来调用，那么对象都还没有实例化，也就是内存空间都没有，那指向vtable的指针去哪里找呢</li>
</ul>
</li>
<li>使用角度：<ul>
<li>虚函数主要是用于父类的指针指向不同子类对象，能使重写的函数得到相应的调用</li>
<li>虚函数用于通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用</li>
<li>虚函数是在不同类型的子类对象产生不同的动作，但构造函数调用时，其子类都还没有产生，虚函数就没有存在的意义了</li>
</ul>
</li>
<li>实现角度：<ul>
<li>vtable在构造函数调用后才建立，因而构造函数不可能成为虚函数</li>
</ul>
</li>
<li>实际含义角度：<ul>
<li>在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）</li>
<li>并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，也没有必要成为虚函数。</li>
</ul>
</li>
</ul>
<h1 id="析构函数要为虚函数"><a href="#析构函数要为虚函数" class="headerlink" title="析构函数要为虚函数"></a>析构函数要为虚函数</h1><ul>
<li>我们往往通过基类的指针来销毁对象。这时候假设析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。</li>
<li>基类采用virtual虚析构函数是<strong>为了防止内存泄漏。</strong></li>
<li>具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。</li>
<li>假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。</li>
<li>那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。</li>
<li>为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。</li>
<li>纯虚析构函数必须定义，因为每一个派生类的析构函数都会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上层基类的析构函数</li>
<li>所以，缺乏任何一个基类析构函数的定义都会导致链接失败，最好还是不要把虚析构函数定义为纯虚析构函数。</li>
</ul>
<h1 id="析构函数作用"><a href="#析构函数作用" class="headerlink" title="析构函数作用"></a>析构函数作用</h1><ul>
<li>用于释放对象内的动态申请内存的数据成员，</li>
<li>析构函数与构造函数同名，但该函数前面加~。</li>
<li>析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。</li>
<li>当释放对象时，编译器也会自动调用析构函数。</li>
<li>每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。</li>
<li>一般析构函数定义为类的公有成员。</li>
</ul>
<h1 id="构造函数和析构函数能否调用虚函数"><a href="#构造函数和析构函数能否调用虚函数" class="headerlink" title="构造函数和析构函数能否调用虚函数"></a>构造函数和析构函数能否调用虚函数</h1><ul>
<li>在C++中，提倡不在构造函数和析构函数中调用虚函数</li>
<li>从语法上讲，调用完全没有问题</li>
<li>但是从效果上看，往往不能达到需要的目的</li>
<li>构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本</li>
<li>因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编</li>
<li>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Base()</span><br><span class="line">    &#123;</span><br><span class="line">       Function();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void Function()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base::Fuction&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Base()</span><br><span class="line">    &#123;</span><br><span class="line">        Function();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line">      Function();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void Function()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;A::Function&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        Function();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Base* a &#x3D; new Base;</span><br><span class="line">    delete a;</span><br><span class="line">    cout &lt;&lt; &quot;-------------------------&quot; &lt;&lt;endl;</span><br><span class="line">    Base* b &#x3D; new A;&#x2F;&#x2F;语句1</span><br><span class="line">    delete b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">&#x2F;&#x2F;Base::Fuction</span><br><span class="line">&#x2F;&#x2F;Base::Fuction</span><br><span class="line">&#x2F;&#x2F;-------------------------</span><br><span class="line">&#x2F;&#x2F;Base::Fuction</span><br><span class="line">&#x2F;&#x2F;A::Function</span><br><span class="line">&#x2F;&#x2F;Base::Fuction</span><br></pre></td></tr></table></figure>


<h1 id="析构函数的执行顺序"><a href="#析构函数的执行顺序" class="headerlink" title="析构函数的执行顺序"></a>析构函数的执行顺序</h1><ol>
<li>调用派生类的析构函数</li>
<li>调用成员类对象的析构函数</li>
<li>调用基类的析构函数</li>
</ol>
<h1 id="构造函数析构函数可否抛出异常"><a href="#构造函数析构函数可否抛出异常" class="headerlink" title="构造函数析构函数可否抛出异常"></a>构造函数析构函数可否抛出异常</h1><ul>
<li>C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。所以在对象的构造函数中发生异常，对象的析构函数不会被调用。因此会造成内存泄漏。</li>
<li>用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源。</li>
<li>如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束。</li>
<li>如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。</li>
</ul>
<h1 id="析构函数调用的时机"><a href="#析构函数调用的时机" class="headerlink" title="析构函数调用的时机"></a>析构函数调用的时机</h1><ul>
<li>对象生命周期结束，被销毁时</li>
<li>delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类析构函数是虚函数时</li>
<li>对象a是对象b的成员，b的析构函数被调用时，对象a的析构函数也被调用</li>
</ul>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。</p>
<h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><ul>
<li>C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。</li>
<li>智能指针在C++11版本之后提供，包含在头文件中，shared_ptr、unique_ptr、weak_ptr。</li>
<li>初始化。智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如<code>std::shared_ptr p4 = new int(1);</code>写法是错误的</li>
</ul>
<h2 id="常用的智能指针"><a href="#常用的智能指针" class="headerlink" title="常用的智能指针"></a>常用的智能指针</h2><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><ul>
<li>采用引用计数器的方法，允许多个智能指针指向同一个对象</li>
<li>每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1</li>
<li>每当减少一个智能指针指向对象时，引用计数会减1<ul>
<li>对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数</li>
<li>并增加右操作数所指对象的引用计数</li>
</ul>
</li>
<li>当计数为0的时候会自动的释放动态分配的资源</li>
<li>shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。</li>
</ul>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><ul>
<li>unique_ptr采用的是独享所有权语义</li>
<li>一个非空的unique_ptr总是拥有它所指向的资源</li>
<li>转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空</li>
<li>所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中</li>
<li>局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）</li>
<li>如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃</li>
<li>相比于原始指针，unique_ptr使得在出现异常的情况下，动态资源能得到释放</li>
<li>unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。</li>
<li>离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。</li>
<li>在智能指针生命周期内，可以改变智能指针所指对象，如：<ul>
<li>创建智能指针时通过构造函数指定</li>
<li>通过reset方法重新指定</li>
<li>通过release方法释放所有权</li>
<li>通过移动语义转移所有权</li>
</ul>
</li>
</ul>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><ul>
<li>弱引用，引用计数有一个问题就是互相引用形成环（环形引用）</li>
<li>这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用</li>
<li>weak_ptr是为了配合shared_ptr而引入的一种智能指针</li>
<li>它只是提供了对管理对象的一个访问手段</li>
<li>它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数</li>
<li>如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放</li>
<li>所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针</li>
</ul>
<h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><ul>
<li>主要是为了解决“有异常抛出时发生内存泄漏”的问题 ，因为发生异常而无法正常释放内存</li>
<li>auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题</li>
<li>而unique_ptr则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移</li>
<li>auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中</li>
<li>因为STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能在STL中使用。</li>
</ul>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>我们以shared_ptr作为栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class SharedPtr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    SharedPtr(T* ptr &#x3D; NULL):_ptr(ptr), _pcount(new int(1))</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    SharedPtr(const SharedPtr&amp; s):_ptr(s._ptr), _pcount(s._pcount)&#123;</span><br><span class="line">        *(_pcount)++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SharedPtr&lt;T&gt;&amp; operator&#x3D;(const SharedPtr&amp; s)&#123;</span><br><span class="line">        if (this !&#x3D; &amp;s)</span><br><span class="line">        &#123;</span><br><span class="line">            if (--(*(this-&gt;_pcount)) &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                delete this-&gt;_ptr;</span><br><span class="line">                delete this-&gt;_pcount;</span><br><span class="line">            &#125;</span><br><span class="line">            _ptr &#x3D; s._ptr;</span><br><span class="line">            _pcount &#x3D; s._pcount;</span><br><span class="line">            *(_pcount)++;</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; operator*()</span><br><span class="line">    &#123;</span><br><span class="line">        return *(this-&gt;_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    T* operator-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        return this-&gt;_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    ~SharedPtr()</span><br><span class="line">    &#123;</span><br><span class="line">        --(*(this-&gt;_pcount));</span><br><span class="line">        if (this-&gt;_pcount &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            delete _ptr;</span><br><span class="line">            _ptr &#x3D; NULL;</span><br><span class="line">            delete _pcount;</span><br><span class="line">            _pcount &#x3D; NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T* _ptr;</span><br><span class="line">    int* _pcount;&#x2F;&#x2F;指向引用计数的指针</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="智能指针的循环引用"><a href="#智能指针的循环引用" class="headerlink" title="智能指针的循环引用"></a>智能指针的循环引用</h1><p>循环引用是指使用多个智能指针share_ptr时，出现了指针之间相互指向，从而形成环的情况，有点类似于死锁的情况，这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。</p>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Node</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Node(const T&amp; value)</span><br><span class="line">        :_pPre(NULL)</span><br><span class="line">        , _pNext(NULL)</span><br><span class="line">        , _value(value)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Node()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Node()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~Node()&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;this:&quot; &lt;&lt; this &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Node&lt;T&gt;&gt; _pPre;</span><br><span class="line">    shared_ptr&lt;Node&lt;T&gt;&gt; _pNext;</span><br><span class="line">    T _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Funtest()</span><br><span class="line">&#123;</span><br><span class="line">    shared_ptr&lt;Node&lt;int&gt;&gt; sp1(new Node&lt;int&gt;(1));</span><br><span class="line">    shared_ptr&lt;Node&lt;int&gt;&gt; sp2(new Node&lt;int&gt;(2));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;sp1.use_count:&quot; &lt;&lt; sp1.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;sp2.use_count:&quot; &lt;&lt; sp2.use_count() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    sp1-&gt;_pNext &#x3D; sp2; &#x2F;&#x2F;sp1的引用+1</span><br><span class="line">    sp2-&gt;_pPre &#x3D; sp1; &#x2F;&#x2F;sp2的引用+1</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;sp1.use_count:&quot; &lt;&lt; sp1.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;sp2.use_count:&quot; &lt;&lt; sp2.use_count() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Funtest();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">&#x2F;&#x2F;Node()</span><br><span class="line">&#x2F;&#x2F;Node()</span><br><span class="line">&#x2F;&#x2F;sp1.use_count:1</span><br><span class="line">&#x2F;&#x2F;sp2.use_count:1</span><br><span class="line">&#x2F;&#x2F;sp1.use_count:2</span><br><span class="line">&#x2F;&#x2F;sp2.use_count:2</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>只有当引用计数等于0，析构时才会释放对象，而上述情况造成了一个僵局。</li>
<li>那就是析构对象时先析构sp2,可是由于sp2的空间sp1还在使用中，所以<code>sp2.use_count--</code>之后为1，不释放。</li>
<li>sp1也是相同的道理，由于sp1的空间sp2还在使用中，所以<code>sp1.use_count--</code>之后为1，也不释放。</li>
<li>sp1等着sp2先释放，sp2等着sp1先释放,二者互不相让，导致最终都没能释放，内存泄漏。</li>
<li>所以在实际编程过程中，应该尽量避免出现智能指针之前相互指向的情况.</li>
<li>如果不可避免，可以使用使用弱指针——weak_ptr，它不增加引用计数，只要出了作用域就会自动析构。</li>
</ul>
</blockquote>
<h1 id="构造函数的几种关键字"><a href="#构造函数的几种关键字" class="headerlink" title="构造函数的几种关键字"></a>构造函数的几种关键字</h1><h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><p>可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class CString</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CString() &#x3D; default; &#x2F;&#x2F;语句1</span><br><span class="line">    &#x2F;&#x2F;构造函数</span><br><span class="line">    CString(const char* pstr) : _str(pstr)&#123;&#125;</span><br><span class="line">    void* operator new() &#x3D; delete;&#x2F;&#x2F;这样不允许使用new关键字</span><br><span class="line">    &#x2F;&#x2F;析构函数</span><br><span class="line">    ~CString()&#123;&#125;</span><br><span class="line">public:</span><br><span class="line">     string _str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   auto a &#x3D; new CString(); &#x2F;&#x2F;语句2</span><br><span class="line">   cout &lt;&lt; &quot;Hello World&quot; &lt;&lt;endl;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;运行结果</span><br><span class="line">&#x2F;&#x2F;Hello World</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果没有语句1，那么语句2会报错，因为找不到参数为空的构造函数，将其设置为default可以解决这个问题</p>
</blockquote>
<h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>可以删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class CString</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void* operator new() &#x3D; delete;&#x2F;&#x2F;这样不允许使用new关键字</span><br><span class="line">    &#x2F;&#x2F;析构函数</span><br><span class="line">    ~CString()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   auto a &#x3D; new CString(); &#x2F;&#x2F;语句1</span><br><span class="line">   cout &lt;&lt; &quot;Hello World&quot; &lt;&lt;endl;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在执行语句1会提醒new方法已被删除，如果将new设置为私有方法，则会报惨不忍睹的错误，因此使用delete关键字可以更加人性化的删除一些默认方法</p>
</blockquote>
<h2 id="0"><a href="#0" class="headerlink" title="0"></a>0</h2><p>将虚函数定义为纯虚函数（纯虚函数无需定义，= 0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，不过函数体必须定义在类的外部）</p>
<h1 id="四种强制转换"><a href="#四种强制转换" class="headerlink" title="四种强制转换"></a>四种强制转换</h1><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：</p>
<ul>
<li>常量指针被转化成非常量的指针，并且仍然指向原来的对象</li>
<li>常量引用被转换成非常量的引用，并且仍然指向原来的对象</li>
<li>const_cast一般用于修改底指针。如const char *p形式</li>
</ul>
<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：</p>
<ul>
<li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换<ul>
<li>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的</li>
<li>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的</li>
</ul>
</li>
<li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证</li>
<li>把空指针转换成目标类型的空指针</li>
<li>把任何类型的表达式转换成void类型</li>
</ul>
<blockquote>
<p>注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。</p>
</blockquote>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><ul>
<li>有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全</li>
<li>该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*</li>
<li>如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用</li>
<li>可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）</li>
<li>可以用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换</li>
<li>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的</li>
<li>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Base() :b(1) &#123;&#125;</span><br><span class="line">    virtual void fun() &#123;&#125;;</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Son : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Son() :d(2) &#123;&#125;</span><br><span class="line">    int d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n &#x3D; 97;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;reinterpret_cast</span><br><span class="line">    int *p &#x3D; &amp;n;</span><br><span class="line">    &#x2F;&#x2F;以下两者效果相同</span><br><span class="line">    char *c &#x3D; reinterpret_cast&lt;char*&gt; (p); </span><br><span class="line">    char *c2 &#x3D;  (char*)(p);</span><br><span class="line">    cout &lt;&lt; &quot;reinterpret_cast输出：&quot;&lt;&lt; *c2 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;const_cast</span><br><span class="line">    const int *p2 &#x3D; &amp;n;</span><br><span class="line">    int *p3 &#x3D; const_cast&lt;int*&gt;(p2);</span><br><span class="line">    *p3 &#x3D; 100;</span><br><span class="line">    cout &lt;&lt; &quot;const_cast输出：&quot; &lt;&lt; *p3 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    Base* b1 &#x3D; new Son;</span><br><span class="line">    Base* b2 &#x3D; new Base;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;static_cast</span><br><span class="line">    Son* s1 &#x3D; static_cast&lt;Son*&gt;(b1); &#x2F;&#x2F;同类型转换</span><br><span class="line">    Son* s2 &#x3D; static_cast&lt;Son*&gt;(b2); &#x2F;&#x2F;下行转换，不安全</span><br><span class="line">    cout &lt;&lt; &quot;static_cast输出：&quot;&lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s1-&gt;d &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s2-&gt;d &lt;&lt; endl; &#x2F;&#x2F;下行转换，原先父对象没有d成员，输出垃圾值</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;dynamic_cast</span><br><span class="line">    Son* s3 &#x3D; dynamic_cast&lt;Son*&gt;(b1); &#x2F;&#x2F;同类型转换</span><br><span class="line">    Son* s4 &#x3D; dynamic_cast&lt;Son*&gt;(b2); &#x2F;&#x2F;下行转换，安全</span><br><span class="line">    cout &lt;&lt; &quot;dynamic_cast输出：&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s3-&gt;d &lt;&lt; endl;</span><br><span class="line">    if(s4 &#x3D;&#x3D; nullptr)</span><br><span class="line">        cout &lt;&lt; &quot;s4指针为nullptr&quot; &lt;&lt; endl;</span><br><span class="line">    else</span><br><span class="line">        cout &lt;&lt; s4-&gt;d &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">&#x2F;&#x2F;reinterpret_cast输出：a</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;const_cast输出：100</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;static_cast输出：</span><br><span class="line">&#x2F;&#x2F;2</span><br><span class="line">&#x2F;&#x2F;-33686019</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;dynamic_cast输出：</span><br><span class="line">&#x2F;&#x2F;2</span><br><span class="line">&#x2F;&#x2F;s4指针为nullptr</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从输出结果可以看出，在进行下行转换时，dynamic_cast安全的，如果下行转换不安全的话其会返回空指针，这样在进行操作的时候可以预先判断。而使用static_cast下行转换存在不安全的情况也可以转换成功，但是直接使用转换后的对象进行操作容易造成错误。</p>
</blockquote>
<h1 id="函数调用的压栈过程"><a href="#函数调用的压栈过程" class="headerlink" title="函数调用的压栈过程"></a>函数调用的压栈过程</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int f(int n) </span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func(int param1, int param2)</span><br><span class="line">&#123;</span><br><span class="line">    int var1 &#x3D; param1;</span><br><span class="line">    int var2 &#x3D; param2;</span><br><span class="line">    printf(&quot;var1&#x3D;%d,var2&#x3D;%d&quot;, f(var1), f(var2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    func(1, 2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">&#x2F;&#x2F;2</span><br><span class="line">&#x2F;&#x2F;1</span><br><span class="line">&#x2F;&#x2F;var1&#x3D;1,var2&#x3D;2</span><br></pre></td></tr></table></figure>
<ul>
<li>入口函数 <code>main()</code>开始执行，编译器会将操作系统的运行状态、<code>main()</code>函数的返回地址，<code>main()</code>的参数、<code>main()</code>函数中的变量、进行依次压栈；</li>
<li><code>main()</code>函数开始调用<code>func()</code>函数时候，编译器会将<code>main()</code>函数的运行状态进行压栈，再将<code>func()</code>函数的返回地址、<code>func()</code>函数参数从右到左、<code>func()</code>定义的变量依次压栈；</li>
<li>当<code>func()</code>函数调用f()函数的时候，编译器此时会将<code>func()</code>函数的运行状态进行压栈，<code>f()</code>的返回地址、<code>f()</code>函数的参数从右到左、<code>f()</code>定义的变量从右到左依次压栈。</li>
<li>从代码输出结果看，函数<code>f(var1)</code>、<code>f(var2)</code>依次入栈，而后先执行``f(var2)<code>，再执行</code>f(var1)`，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。</li>
</ul>
<h1 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h1><blockquote>
<p>我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</p>
</blockquote>
<ul>
<li>拷贝构造函数中，对于指针，我们一定要采用深层复制</li>
<li>而移动构造函数中，对于指针，我们采用浅层复制。</li>
<li>浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。</li>
<li>所以我们只要避免第一个指针释放空间就可以了。</li>
<li>避免的方法就是将第一个指针（比如a-&gt;value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a-&gt;value指向的空间</li>
<li>移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。</li>
<li>意味着，移动构造函数的参数是一个右值或者将亡值的引用。</li>
<li>也就是说，只要用一个右值或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。</li>
</ul>
<h1 id="临时变量作为返回值的过程"><a href="#临时变量作为返回值的过程" class="headerlink" title="临时变量作为返回值的过程"></a>临时变量作为返回值的过程</h1><ul>
<li>临时变量，在函数调用过程中是被压到程序进程的栈中的</li>
<li>当函数退出时，临时变量出栈，即临时变量已经被销毁</li>
<li>临时变量占用的内存空间可以没有被清空，但是可以被分配给其他变量</li>
<li>所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</li>
<li>函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系</li>
<li>当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系</li>
<li>如果我们需要返回值，一般使用赋值语句就可以了</li>
</ul>
<blockquote>
<p>C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit</p>
</blockquote>
<h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><ul>
<li>his指针是类的指针，指向对象的首地址</li>
<li>this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this</li>
<li>this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置</li>
</ul>
<h2 id="this指针的使用"><a href="#this指针的使用" class="headerlink" title="this指针的使用"></a>this指针的使用</h2><ul>
<li>在类的非静态成员函数中返回类对象本身的时候，直接使用 <code>return *this</code></li>
<li>当形参数与成员变量名相同时用于区分，如<code>this-&gt;n = n</code> （不能写成n = n）</li>
</ul>
<h2 id="this指针的特点"><a href="#this指针的特点" class="headerlink" title="this指针的特点"></a>this指针的特点</h2><ul>
<li>this只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，成员函数默认第一个参数为<code>T * const this</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;func的原型在编译器看来应该是：int func(A * const this,int p);</span><br><span class="line">    int func(int p)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>this在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A a;</span><br><span class="line">a.func(10);</span><br><span class="line">&#x2F;&#x2F;此处，编译器将会编译成：A::func(&amp;a,10);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的。</p>
</blockquote>
<h2 id="this指针的易混问题"><a href="#this指针的易混问题" class="headerlink" title="this指针的易混问题"></a>this指针的易混问题</h2><ul>
<li><strong>this指针是什么时候创建的？</strong><ul>
<li>this在成员函数的开始执行前构造，在成员的执行结束后清除。</li>
<li>但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C语言的struct使用。</li>
<li>采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。</li>
<li>采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx</li>
</ul>
</li>
<li><strong>this指针存放在何处？堆、栈、全局变量，还是其他？</strong><ul>
<li>this指针会因编译器不同而有不同的放置位置。</li>
<li>可能是栈，也可能是寄存器，甚至全局变量。</li>
<li>在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。</li>
<li>不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。</li>
</ul>
</li>
<li><strong>this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？</strong><ul>
<li>大多数编译器通过ecx（寄数寄存器）寄存器传递this指针。</li>
<li>事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。</li>
<li>在调用之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。</li>
<li>this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的</li>
</ul>
</li>
<li><strong>我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？</strong><ul>
<li><strong>this指针只有在成员函数中才有定义。</strong></li>
<li>因此，你获得一个对象后，也不能通过对象使用this指针。</li>
<li>所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。</li>
<li>当然，在成员函数里，你是可以知道this指针的位置的（可以通过&amp;this获得），也可以直接使用它。</li>
</ul>
</li>
<li><strong>每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</strong><ul>
<li>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。</li>
<li>只有虚函数才会被放到函数表中。</li>
<li>但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。</li>
<li>正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰</li>
</ul>
</li>
</ul>
<h1 id="构造函数、拷贝构造函数、赋值操作符区别"><a href="#构造函数、拷贝构造函数、赋值操作符区别" class="headerlink" title="构造函数、拷贝构造函数、赋值操作符区别"></a>构造函数、拷贝构造函数、赋值操作符区别</h1><ul>
<li><strong>构造函数</strong></li>
</ul>
<p>对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数</p>
<ul>
<li><strong>拷贝构造函数</strong></li>
</ul>
<p>对象不存在，但是使用别的已经存在的对象来进行初始化</p>
<ul>
<li><strong>赋值运算符</strong></li>
</ul>
<p>对象存在，用别的对象给它赋值，这属于重载“=”号运算符的范畴，“=”号两侧的对象都是已存在的</p>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;我是构造函数&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    A(const A&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;我是拷贝构造函数&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    A&amp; operator &#x3D; (A&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;我是赋值操作符&quot; &lt;&lt; endl;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    A a1; &#x2F;&#x2F;调用构造函数</span><br><span class="line">    A a2 &#x3D; a1; &#x2F;&#x2F;调用拷贝构造函数</span><br><span class="line">    a2 &#x3D; a1; &#x2F;&#x2F;调用赋值操作符</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">&#x2F;&#x2F;我是构造函数</span><br><span class="line">&#x2F;&#x2F;我是拷贝构造函数</span><br><span class="line">&#x2F;&#x2F;我是赋值操作符</span><br></pre></td></tr></table></figure>


<h1 id="拷贝构造函数和赋值运算符重载的区别"><a href="#拷贝构造函数和赋值运算符重载的区别" class="headerlink" title="拷贝构造函数和赋值运算符重载的区别"></a>拷贝构造函数和赋值运算符重载的区别</h1><ul>
<li><p>拷贝构造函数是函数，赋值运算符是运算符重载。</p>
</li>
<li><p>拷贝构造函数会生成新的类对象，赋值运算符不能。</p>
</li>
<li><p>拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；<br>赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。</p>
</li>
<li><p>形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现”=”的地方都是使用赋值运算符，举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student s;</span><br><span class="line">Student s1 &#x3D; s;    &#x2F;&#x2F; 调用拷贝构造函数</span><br><span class="line">Student s2;</span><br><span class="line">s2 &#x3D; s;    &#x2F;&#x2F; 赋值运算符操作</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符</p>
</blockquote>
</li>
</ul>
<h1 id="什么是虚拟继承"><a href="#什么是虚拟继承" class="headerlink" title="什么是虚拟继承"></a>什么是虚拟继承</h1><p>C++支持多继承，除了public、protected和private三种继承方式外，还支持虚拟（virtual）继承，举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class A  &#x2F;&#x2F;大小为4</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int a;</span><br><span class="line">&#125;;</span><br><span class="line">class B :virtual public A  &#x2F;&#x2F;大小为12，变量a,b共8字节，虚基类表指针4</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br><span class="line">class C :virtual public A &#x2F;&#x2F;与B一样12</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int c;</span><br><span class="line">&#125;;</span><br><span class="line">class D :public B, public C &#x2F;&#x2F;24,变量a,b,c,d共16，B的虚基类指针4，C的虚基类指针</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int d;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    C c;</span><br><span class="line">    D d;</span><br><span class="line">    cout &lt;&lt; sizeof(a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; sizeof(b) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; sizeof(c) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; sizeof(d) &lt;&lt; endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体。</strong></li>
<li>通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）。</li>
<li>当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</li>
<li>vbptr指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table）</li>
<li>虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，</li>
<li>而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</li>
</ul>
<h1 id="获得结构成员相对于结构开头的字节偏移量"><a href="#获得结构成员相对于结构开头的字节偏移量" class="headerlink" title="获得结构成员相对于结构开头的字节偏移量"></a>获得结构成员相对于结构开头的字节偏移量</h1><p>使用&lt;stddef.h&gt;头文件中的，offsetof宏。</p>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stddef.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct  S</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">    char y;</span><br><span class="line">    int z;</span><br><span class="line">    double a;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; offsetof(S, x) &lt;&lt; endl; &#x2F;&#x2F; 0</span><br><span class="line">    cout &lt;&lt; offsetof(S, y) &lt;&lt; endl; &#x2F;&#x2F; 4</span><br><span class="line">    cout &lt;&lt; offsetof(S, z) &lt;&lt; endl; &#x2F;&#x2F; 8</span><br><span class="line">    cout &lt;&lt; offsetof(S, a) &lt;&lt; endl; &#x2F;&#x2F; 12</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">在VS2019 + win下 并不是这样的</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; offsetof(S, x) &lt;&lt; endl; &#x2F;&#x2F; 0</span><br><span class="line">    cout &lt;&lt; offsetof(S, y) &lt;&lt; endl; &#x2F;&#x2F; 4</span><br><span class="line">    cout &lt;&lt; offsetof(S, z) &lt;&lt; endl; &#x2F;&#x2F; 8</span><br><span class="line">    cout &lt;&lt; offsetof(S, a) &lt;&lt; endl; &#x2F;&#x2F; 16 这里是 16的位置，因为 double是8字节，需要找一个8的倍数对齐，</span><br><span class="line">当然了，如果加上  #pragma pack(4)指定 4字节对齐就可以了</span><br><span class="line"></span><br><span class="line">#pragma pack(4)</span><br><span class="line">struct  S</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">    char y;</span><br><span class="line">    int z;</span><br><span class="line">    double a;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; offsetof(S, x) &lt;&lt; endl; &#x2F;&#x2F; 0</span><br><span class="line">    cout &lt;&lt; offsetof(S, y) &lt;&lt; endl; &#x2F;&#x2F; 4</span><br><span class="line">    cout &lt;&lt; offsetof(S, z) &lt;&lt; endl; &#x2F;&#x2F; 8</span><br><span class="line">    cout &lt;&lt; offsetof(S, a) &lt;&lt; endl; &#x2F;&#x2F; 12</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>


<h1 id="静态-动态类型，静态-动态绑定"><a href="#静态-动态类型，静态-动态绑定" class="headerlink" title="静态/动态类型，静态/动态绑定"></a>静态/动态类型，静态/动态绑定</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul>
<li>静态类型：对象在声明时采用的类型，在编译期既已确定；</li>
<li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</li>
<li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li>
<li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</li>
</ul>
<blockquote>
<p>非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态性）。</p>
</blockquote>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;*virtual*&#x2F; void func() &#123; std::cout &lt;&lt; &quot;A::func()\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B : public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void func() &#123; std::cout &lt;&lt; &quot;B::func()\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class C : public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void func() &#123; std::cout &lt;&lt; &quot;C::func()\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    C* pc &#x3D; new C(); &#x2F;&#x2F;pc的静态类型是它声明的类型C*，动态类型也是C*；</span><br><span class="line">    B* pb &#x3D; new B(); &#x2F;&#x2F;pb的静态类型和动态类型也都是B*；</span><br><span class="line">    A* pa &#x3D; pc;      &#x2F;&#x2F;pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；</span><br><span class="line">    pa &#x3D; pb;         &#x2F;&#x2F;pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；</span><br><span class="line">    C *pnull &#x3D; NULL; &#x2F;&#x2F;pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span><br><span class="line">    </span><br><span class="line">    pa-&gt;func();      &#x2F;&#x2F;A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；</span><br><span class="line">    pc-&gt;func();      &#x2F;&#x2F;C::func() pc的动、静态类型都是C*，因此调用C::func()；</span><br><span class="line">    pnull-&gt;func();   &#x2F;&#x2F;C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；</span><br><span class="line">    &#x2F;*</span><br><span class="line">    pa-&gt;func();      &#x2F;&#x2F;B::func() 因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找，找到后直接调用；</span><br><span class="line">    pc-&gt;func();      &#x2F;&#x2F;C::func() pc的动、静态类型都是C*，因此也是先在C中查找；</span><br><span class="line">    pnull-&gt;func();   &#x2F;&#x2F;空指针异常，因为是func是virtual函数，因此对func的调用只能等到运行期才能确定，然后才发现pnull是空指针；</span><br><span class="line">    *&#x2F;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>如果基类A中的func不是virtual函数，那么不论pa、pb、pc指向哪个子类对象，对func的调用都是在定义pa、pb、pc时的静态类型决定，早已在编译期确定了。</li>
<li>同样的空指针也能够直接调用no-virtual函数而不报错（这也说明一定要做空指针检查啊！），因此静态绑定不能实现多态；</li>
<li>如果func是虚函数，那所有的调用都要等到运行时根据其指向对象的类型才能确定，比起静态绑定自然是要有性能损失的，但是却能实现多态特性；</li>
</ul>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>静态绑定发生在编译期，动态绑定发生在运行期；</li>
<li>对象的动态类型可以更改，但是静态类型无法更改；</li>
<li>要想实现多态，必须使用动态绑定；</li>
<li>在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；</li>
</ul>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul>
<li>绝对不要重新定义继承而来的非虚(non-virtual)函数（《Effective C++ 第三版》条款36）。</li>
<li>因为这样导致函数的调用由对象声明时的静态类型确定，而和对象本身脱离了关系，没有多态，也这将给程序留下不可预知的隐患和莫名其妙的BUG；</li>
<li>另外，在动态绑定也即在virtual函数中，要注意默认参数的使用。当缺省参数和virtual函数一起使用的时候一定要谨慎，不然出了问题怕是很难排查。</li>
</ul>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class E</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void func(int i &#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;E::func()\t&quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class F : public E</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void func(int i &#x3D; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;F::func()\t&quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test2()</span><br><span class="line">&#123;</span><br><span class="line">    F* pf &#x3D; new F();</span><br><span class="line">    E* pe &#x3D; pf;</span><br><span class="line">    pf-&gt;func(); &#x2F;&#x2F;F::func() 1  正常，就该如此；</span><br><span class="line">    pe-&gt;func(); &#x2F;&#x2F;F::func() 0  哇哦，这是什么情况，调用了子类的函数，却使用了基类中参数的默认值！</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test2();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h1><ul>
<li>nullptr替代 NULL</li>
<li>引入了 auto 和 decltype 这两个关键字实现了类型推导</li>
<li>基于范围的 for 循环for(auto&amp; i : res){}</li>
<li>类和结构体的中初始化列表</li>
<li>Lambda 表达式（匿名函数）</li>
<li>std::forward_list（单向链表）</li>
<li>右值引用和move语义</li>
</ul>
<h1 id="引用实现动态绑定"><a href="#引用实现动态绑定" class="headerlink" title="引用实现动态绑定"></a>引用实现动态绑定</h1><p>引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数。</p>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void  fun()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;base :: fun()&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Son : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void  fun()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;son :: fun()&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void func()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;son :: not virtual function&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	Base&amp; b &#x3D; s; &#x2F;&#x2F; 基类类型引用绑定已经存在的Son对象，引用必须初始化</span><br><span class="line">	s.fun(); &#x2F;&#x2F;son::fun()</span><br><span class="line">	b.fun(); &#x2F;&#x2F;son :: fun()</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要说明的是：</p>
<p>虚函数才具有动态绑定，上面代码中，Son类中还有一个非虚函数func()，这在b对象中是无法调用的，如果使用基类指针来指向子类也是一样的。</p>
</blockquote>
<h1 id="全局变量和局部变量的区别"><a href="#全局变量和局部变量的区别" class="headerlink" title="全局变量和局部变量的区别"></a>全局变量和局部变量的区别</h1><ul>
<li>生命周期不同</li>
</ul>
<p>全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</p>
<ul>
<li>使用方式不同</li>
</ul>
<p>通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。</p>
<ul>
<li>内存分配的位置不同</li>
</ul>
<p>全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。</p>
<h1 id="指针加减计算"><a href="#指针加减计算" class="headerlink" title="指针加减计算"></a>指针加减计算</h1><p>指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险。</p>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int *a, *b, c;</span><br><span class="line">    a &#x3D; (int*)0x500;</span><br><span class="line">    b &#x3D; (int*)0x520;</span><br><span class="line">    c &#x3D; b - a;</span><br><span class="line">    printf(&quot;%d\n&quot;, c); &#x2F;&#x2F; 8</span><br><span class="line">    a +&#x3D; 0x020;</span><br><span class="line">    c &#x3D; b - a;</span><br><span class="line">    printf(&quot;%d\n&quot;, c); &#x2F;&#x2F; -24</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>变量a和b都是以16进制的形式初始化</li>
<li>将它们转成10进制分别是1280（<code>5*16^2=1280</code>）和1312（<code>5*16^2+2*16=1312</code>)</li>
<li>那么它们的差值为32，也就是说a和b所指向的地址之间间隔32个位，</li>
<li>但是考虑到是int类型占4位，所以c的值为<code>32/4=8</code></li>
<li>a自增16进制0x20之后，其实际地址变为<code>1280 + 2*16*4 = 1408</code>，（因为一个int占4位，所以要乘4），</li>
<li>这样它们的差值就变成了<code>1312 - 1280 = -96</code>，所以c的值就变成了<code>-96/4 = -24</code></li>
<li>遇到指针的计算，需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度</li>
<li>建议都转成10进制计算，计算结果除以类型长度取得结果</li>
</ul>
<h1 id="判断浮点数是否相等"><a href="#判断浮点数是否相等" class="headerlink" title="判断浮点数是否相等"></a>判断浮点数是否相等</h1><ul>
<li>对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！</li>
<li>明明相等的两个数比较反而是不相等！</li>
<li>对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！</li>
<li>浮点数与0的比较也应该注意。与浮点数的表示方式有关。</li>
</ul>
<h1 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><ul>
<li>程序用栈来传递过程参数、存储返回信息，保存寄存器用于以后恢复以及本地存储。</li>
<li>而为单个过程分配的那部分栈称为帧栈；</li>
<li>帧栈可以认为是程序栈的一段，它有两个端点，一个标识起始地址，一个标识着结束地址，结束地址指针esp，开始地址指针ebp;</li>
<li>一个程序由一系列栈帧构成，这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回地址；</li>
<li>每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。</li>
<li>由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。</li>
<li>如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。</li>
</ul>
<h2 id="过程实现"><a href="#过程实现" class="headerlink" title="过程实现"></a>过程实现</h2><ul>
<li>备份原来的帧指针，调整当前的栈帧指针到栈指针位置</li>
<li>建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存</li>
<li>使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。</li>
<li>恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了</li>
<li>释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针</li>
<li>恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置。</li>
<li>弹出返回地址，跳出当前过程，继续执行调用者的代码。</li>
</ul>
<h1 id="指针参数传递和引用参数传递"><a href="#指针参数传递和引用参数传递" class="headerlink" title="指针参数传递和引用参数传递"></a>指针参数传递和引用参数传递</h1><h2 id="指针参数传递"><a href="#指针参数传递" class="headerlink" title="指针参数传递"></a>指针参数传递</h2><ul>
<li>指针参数传递本质上是值传递，它所传递的是一个地址值。</li>
<li>值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。</li>
<li>值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。</li>
</ul>
<h2 id="引用参数传递"><a href="#引用参数传递" class="headerlink" title="引用参数传递"></a>引用参数传递</h2><ul>
<li>引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。</li>
<li>被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。</li>
<li>因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>虽然他们都是在被调函数栈空间上的一个局部变量。</li>
<li>对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。</li>
<li>对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。</li>
<li>从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。</li>
<li>指针变量在符号表上对应的地址值为指针变量的地址值。</li>
<li>引用变量在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。</li>
<li>符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</li>
</ul>
<h1 id="类如何实现只能静态分配和只能动态分配"><a href="#类如何实现只能静态分配和只能动态分配" class="headerlink" title="类如何实现只能静态分配和只能动态分配"></a>类如何实现只能静态分配和只能动态分配</h1><ul>
<li>静态分配是把new、delete运算符重载为private属性；动态分配是把构造、析构函数设为protected属性，再用子类来动态创建</li>
<li>建立类的对象有两种方式：<ul>
<li>静态建立，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；</li>
<li>动态建立，<code>A *p = new A();</code>动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；</li>
</ul>
</li>
<li>只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上，可以将new运算符设为私有。</li>
</ul>
<h1 id="自动生成默认构造函数的情况"><a href="#自动生成默认构造函数的情况" class="headerlink" title="自动生成默认构造函数的情况"></a>自动生成默认构造函数的情况</h1><ul>
<li><ol>
<li>带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。</li>
<li>不过这个合成操作只有在构造函数真正被需要的时候才会发生。</li>
<li>如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行。</li>
</ol>
</li>
<li>带有默认构造函数的基类，如果一个没有任何构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数。</li>
<li>带有一个虚函数的类</li>
<li>带有一个虚基类的类</li>
<li>合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。</li>
</ul>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote>
<p>转载自<a href="https://github.com/forthespada/InterviewGuide">https://github.com/forthespada/InterviewGuide</a>，感激大佬的整理和分享！</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++知识点整理第四弹-STL篇</title>
    <url>/2021/03/28/C%E8%89%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%E7%AC%AC%E5%9B%9B%E5%BC%B9-STL%E7%AF%87/</url>
    <content><![CDATA[<h1 id="哈希表的实现"><a href="#哈希表的实现" class="headerlink" title="哈希表的实现"></a>哈希表的实现</h1><p>STL中的哈希表使用的是链地址法。来人，上图！</p>
<p><img src="https://jiajuu.top/2021/03/28/C%E8%89%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%E7%AC%AC%E5%9B%9B%E5%BC%B9-STL%E7%AF%87/%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95.png" alt="链地址法"></p>
<ul>
<li>哈希表中的bucket（篮子）所维护的list不是list也不是slist，而是其自己定义的<code>hashtable_node</code>数据结构组成的<code>linked-list</code></li>
<li>而哈希表的bucket聚合体本身使用<code>vector</code>进行存储。</li>
<li>哈希表的迭代器仅提供前进操作，不提供后退操作</li>
<li>哈希表在设计篮子数量时，内置了28个质数[53,97,193,…,429496729]</li>
<li>创建哈希表时会根据存入元素个数就近选择大于或等于元素个数的质数作为哈希表容器的容量</li>
<li>而每个篮子所维护的<code>linked-list</code>长度也等于哈希表的容量</li>
<li>如果插入哈希表的元素个数大于篮子数，就会进行重建哈希表的操作</li>
<li>重建哈希表会寻找下一个质数，然后重新计算每个元素在哈希表中的位置</li>
</ul>
<h1 id="traits的技法"><a href="#traits的技法" class="headerlink" title="traits的技法"></a>traits的技法</h1><p><code>traits</code>也就是我们常说的萃取机，利用“内嵌型别”的编程技巧和编译器的template参数推导功能，来增强C++型别认证能力。</p>
<p>常用的有：</p>
<ul>
<li><code>iterator_traits</code>特性萃取机</li>
<li><code>type_traits</code>性别萃取机</li>
</ul>
<h2 id="iterator-traits"><a href="#iterator-traits" class="headerlink" title="iterator_traits"></a>iterator_traits</h2><p>特性萃取机能够给外界获取以下5种型别：</p>
<ul>
<li><code>value_type</code>：迭代器所指对象的型别</li>
<li><code>difference_type</code>：两个迭代器之间的距离</li>
<li><code>pointer</code>：迭代器所指向的型别</li>
<li><code>reference</code>：迭代器所引用的型别</li>
<li><code>iterator_category</code></li>
</ul>
<h2 id="type-traits"><a href="#type-traits" class="headerlink" title="type_traits"></a>type_traits</h2><p>关注的是型别的特性，例如这个型别是否具备默认构造函数？是否具备拷贝构造函数？赋值运算符？析构函数？如果答案是否定的，便可以直接操作内存的方式来提高效率。</p>
<p>一般来说，支持以下5种类型的判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__type_traits&lt;T&gt;::has_trivial_default_constructor</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_copy_constructor</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_assignment_operator</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_destructor</span><br><span class="line">__type_traits&lt;T&gt;::is_POD_type</span><br></pre></td></tr></table></figure>
<p>但是由于编译器只针对class object形式的参数进行参数推导，所以bool不作为返回结果。</p>
<p>问题来了，如果不用bool值，那应该用什么呢？实际上使用的是一种空的结构体：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __true_type&#123;&#125;;</span><br><span class="line">struct __false_type&#123;&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为上述两个结构体没有成员数据，所以也就占用1个字节，所以并不会带来负担</p>
</blockquote>
<p>当然，我们也可以针对自定义的类型进行<code>type_traits</code>的特化版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;&gt; struct __type_traits&lt;MyClass&gt;&#123;</span><br><span class="line">	typedef __true_type has_trivial_default_constructor;</span><br><span class="line">	typedef __false_type has_trivial_copy_constructor;</span><br><span class="line">	typedef __false_type has_trivial_assignment_operator;</span><br><span class="line">	typedef __false_type has_trivial_destructor;</span><br><span class="line">	typedef __false_type is_POD_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h1><blockquote>
<p>背景：首先我们需要了解一下为什么我们需要二级空间配置器</p>
<ol>
<li>我们动态申请内存是需要在堆上申请</li>
<li>但如果我们频繁在堆上申请释放内存，会在堆上造成很多外部碎片，浪费内存空间</li>
<li>而且每次的<code>malloc</code>、<code>free</code>函数等操作，使空间会增加附加信息，降低空间的利用率</li>
<li>所以随着外部碎片的增加，内存分配器找不到合适的内存时需要合并空闲块，会降低工作效率和浪费时间</li>
</ol>
<p>所以大佬们引入了二级空间适配器，当开辟内存小于等于128bytes时，便视为用二级空间配置器来开辟小块内存。</p>
<p>在STL中，一般默认优先使用二级空间配置器，如果大于128bytes时再转去使用一级空间配置器。</p>
</blockquote>
<h2 id="一级空间配置器"><a href="#一级空间配置器" class="headerlink" title="一级空间配置器"></a>一级空间配置器</h2><p>其中重要的函数就是<code>allocate()</code>、<code>deallocate()</code>、<code>reallocate()</code>。实际上还是以<code>malloc()</code>、<code>free()</code>、<code>realloc()</code>等C函数执行内存分配。大致的分配过程：</p>
<p><img src="https://jiajuu.top/2021/03/28/C%E8%89%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%E7%AC%AC%E5%9B%9B%E5%BC%B9-STL%E7%AF%87/%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.png" alt="分配过程"></p>
<ul>
<li><code>allocate()</code>分配内存，本事还是使用<code>malloc()</code>来分配，成功直接返回，否则调用处理函数</li>
<li>失败时，如果用户自定义了内存分配失败的处理函数就调用该函数，否则抛出异常</li>
<li>处理完分配失败处理函数后，再尝试继续分配。</li>
</ul>
<h2 id="二级空间配置器"><a href="#二级空间配置器" class="headerlink" title="二级空间配置器"></a>二级空间配置器</h2><p><img src="https://jiajuu.top/2021/03/28/C%E8%89%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%E7%AC%AC%E5%9B%9B%E5%BC%B9-STL%E7%AF%87/%E5%86%85%E5%AD%98%E6%B1%A0.png" alt="内存池"></p>
<ul>
<li>维护16条链表，分别是0-15号链表，最小8字节，以8字节逐渐递增，最大128字节。</li>
<li>你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（如需要13bytes空间，我们会给它分配16bytes大小）</li>
<li>在找到合适你的链表后查看链表是否为空，如果不为空直接从对应的<code>free_list</code>中拔出，将已经拨出的指针向后移动一位。</li>
<li>对应的<code>free_list</code>为空，先看其内存池是不是空时，如果内存池不为空：<ul>
<li>先检验它剩余空间是否够20个节点大小（即所需内存大小(提升后) * 20），若足够则直接从内存池中拿出20个节点大小空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的<code>free_list</code>下，这样下次再有相同大小的内存需求时，可直接拨出。 </li>
<li>如果不够20个节点大小，则看它是否能满足1个节点大小，如果够的话则直接拿出一个分配给用户，然后从剩余的空间中分配尽可能多的节点挂在相应的<code>free_list</code>中。</li>
<li>如果连一个节点内存都不能满足的话，则将内存池中剩余的空间挂在相应的<code>free_list</code>中，然后再给内存池申请内存。 </li>
</ul>
</li>
<li>内存池为空，此时二级空间配置器会使用<code>malloc()</code>从heap上申请内存，（一次所申请的内存大小为2 * 所需节点内存大小（提升后）* 20 + 一段额外空间），申请40块，一半拿来用，一半放内存池中。</li>
<li> 如果<code>malloc()</code>还是失败了，说明heap上没有足够空间分配给我们了，这时，二级空间配置器会从比所需节点空间大的free_list中一一搜索，从比它所需节点空间大的<code>free_list</code>中拔除一个节点来使用。如果这也没找到，说明比其大的<code>free_list</code>中都没有自由区块了，那就要调用一级适配器了。</li>
<li>释放时调用<code>deallocate()</code>函数，若释放的n&gt;128，则调用一级空间配置器，否则就直接将内存块挂上自由链表的合适位置。</li>
</ul>
<blockquote>
<p>缺点：</p>
<ul>
<li><p>因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它会给你8个字节，即浪费了7个字节，所以它又引入了内部碎片的问题，若相似情况出现很多次，就会造成很多内部碎片；</p>
</li>
<li><p>二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有：</p>
<ul>
<li>即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失败；</li>
<li>若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="vector和list"><a href="#vector和list" class="headerlink" title="vector和list"></a>vector和list</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ul>
<li>和数组类似，拥有一段连续的内存空间，并且起始地址不变。</li>
<li>因此能高效的进行随机存取，时间复杂度为o(1);</li>
<li>但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。</li>
<li>当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。</li>
<li>连续存储结构：vector是可以实现动态增长的对象数组，支持对数组高效率的访问和在数组尾端的删除和插入操作，在中间和头部删除和插入相对不易，需要挪动大量的数据。</li>
<li>它与数组最大的区别就是vector不需程序员自己去考虑容量问题，库里面本身已经实现了容量的动态增长，而数组需要程序员手动写入扩容函数进形扩容。</li>
</ul>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><ul>
<li>list是由双向链表实现的，因此内存空间是不连续的。</li>
<li>只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);</li>
<li>但由于链表的特点，能高效地进行插入和删除。</li>
<li>非连续存储结构：list是一个双链表结构，支持对链表的双向遍历。每个节点包括三个信息：元素本身，指向前一个元素的节点（prev）和指向下一个元素的节点（next）。</li>
<li>因此list可以高效率的对数据元素任意位置进行访问和插入删除等操作。由于涉及对额外指针的维护，所以开销比较大。</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>vector的随机访问效率高，但在插入和删除时（不包括尾部）需要挪动数据，不易操作。</li>
<li>list的访问要遍历整个链表，它的随机访问效率低。但对数据的插入和删除操作等都比较方便，改变指针的指向即可。</li>
<li>list是单向的，</li>
<li>vector是双向的。</li>
<li>vector中的迭代器在使用后就失效了，</li>
<li>而list的迭代器在使用之后还可以继续使用。</li>
<li>list不提供随机访问，所以不能用下标直接访问到某个位置的元素，要访问list里的元素只能遍历，不过你要是只需要访问list的最后N个元素的话，可以用反向迭代器来遍历</li>
</ul>
<h1 id="vector-1"><a href="#vector-1" class="headerlink" title="vector"></a>vector</h1><ul>
<li>size()函数返回的是已用空间大小</li>
<li>capacity()返回的是总空间大小</li>
<li>capacity()-size()则是剩余的可用空间大小。</li>
<li>size()==capacity()，说明vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长。</li>
</ul>
<h2 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h2><blockquote>
<ul>
<li>由于动态增长会引起重新分配内存空间、拷贝原空间、释放原空间，这些过程会降低程序效率。</li>
<li>因此，可以使用<code>reserve(n)</code>预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样便提升了效率。</li>
<li>只有当<code>n&gt;capacity()</code>时，调用<code>reserve(n)</code>才会改变vector容量。</li>
</ul>
</blockquote>
<ol>
<li><p>空的vector对象，<code>size()</code>和<code>capacity()</code>都为0</p>
</li>
<li><p>当空间大小不足时，新分配的空间大小为原空间大小的2倍。</p>
<blockquote>
<p>不同的编译器，vector有不同的扩容大小。在vs下是1.5倍，在GCC下是2倍；</p>
</blockquote>
</li>
<li><p>使用<code>reserve()</code>预先分配一块内存后，在空间未满的情况下，不会引起重新分配，从而提升了效率。</p>
</li>
<li><p>当<code>reserve()</code>分配的空间比原空间小时，也是不会引起重新分配的。</p>
</li>
<li><p><code>resize()</code>函数只改变容器的元素数目，未改变容器大小（但是如果元素数目大于容器大小，那么也会改变容器大小嗷）。</p>
</li>
<li><p>用<code>reserve(size_type)</code>只是扩大<code>capacity</code>值，这些内存空间可能还是“野”的，如果此时使用<code>[]</code>来访问，则可能会越界。而<code>resize(size_type new_size)</code>会真正使容器具有new_size个对象。</p>
</li>
</ol>
<blockquote>
<ul>
<li>空间和时间的权衡。简单来说， 空间分配的多，平摊时间复杂度低，但浪费空间也多。</li>
<li>使用k=2增长因子的问题在于，每次扩展的新尺寸必然刚好大于之前分配的总和，也就是说，之前分配的内存空间不可能被使用。这样对内存不友好。最好把增长因子设为(1,2)</li>
<li>对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。</li>
</ul>
</blockquote>
<h2 id="释放空间"><a href="#释放空间" class="headerlink" title="释放空间"></a>释放空间</h2><ul>
<li>由于vector的内存占用空间只增不减</li>
<li>比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。</li>
<li>所有内存空间是在vector析构时候才能被系统回收。</li>
<li>empty()用来检测容器是否为空的，clear()可以清空所有元素。</li>
<li>但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。</li>
<li>如果需要空间动态缩小，可以考虑使用deque。如果vector，可以用swap()来帮助你释放内存。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector(Vec).swap(Vec);</span><br><span class="line">&#x2F;&#x2F;将Vec的内存空洞清除；</span><br><span class="line">vector().swap(Vec);</span><br><span class="line">&#x2F;&#x2F;清空Vec的内存；</span><br></pre></td></tr></table></figure>


<h1 id="删除容器元素"><a href="#删除容器元素" class="headerlink" title="删除容器元素"></a>删除容器元素</h1><h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><blockquote>
<p>序列式容器，比如vector、deque</p>
</blockquote>
<p>erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">It &#x3D; c.erase(it);</span><br></pre></td></tr></table></figure>
<h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><blockquote>
<p>关联式容器，比如map、set、multimap、multiset等</p>
</blockquote>
<p>erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c.erase(it++)</span><br></pre></td></tr></table></figure>


<h1 id="迭代器的实现"><a href="#迭代器的实现" class="headerlink" title="迭代器的实现"></a>迭代器的实现</h1><ul>
<li> 迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。</li>
<li>迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是<code>*</code>运算符与<code>-&gt;</code>运算符，以及<code>++</code>、<code>--</code>等可能需要重载的运算符重载。这和C++中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。</li>
<li>最常用的迭代器的相应型别有五种：<code>value_type</code>、<code>difference_type</code>、<code>pointer</code>、<code>reference</code>、<code>iterator_catagoly</code>;</li>
</ul>
<h1 id="map和set的实现"><a href="#map和set的实现" class="headerlink" title="map和set的实现"></a>map和set的实现</h1><ul>
<li>底层都是以红黑树的结构实现，因此插入删除等操作都在O(logN)时间内完成，因此可以完成高效的插入删除；</li>
<li>定义了一个模版参数，如果它是key那么它就是set，如果它是map，那么它就是map；底层是红黑树，实现map的红黑树的节点数据类型是key+value，而实现set的节点数据类型是value</li>
<li>因为map和set要求是自动排序的，红黑树能够实现这一功能，而且时间复杂度比较低。</li>
</ul>
<h1 id="map的插入数据"><a href="#map的插入数据" class="headerlink" title="map的插入数据"></a>map的插入数据</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;用insert函数插入pair数据，</span><br><span class="line">mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_one&quot;)); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用insert函数插入value_type数据</span><br><span class="line">mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在insert函数中使用make_pair()函数</span><br><span class="line">mapStudent.insert(make_pair(1, &quot;student_one&quot;)); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用数组方式插入数据</span><br><span class="line">mapStudent[1] &#x3D; &quot;student_one&quot;; </span><br></pre></td></tr></table></figure>


<h1 id="unordered-map-hash-map-和map"><a href="#unordered-map-hash-map-和map" class="headerlink" title="unordered_map(hash_map)和map"></a>unordered_map(hash_map)和map</h1><ul>
<li>unordered_map和map类似，都是存储的key-value的值，可以通过key快速索引到value。不同的是unordered_map不会根据key的大小进行排序</li>
<li>存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历</li>
<li>所以使用时map的key需要定义operator&lt;。而unordered_map需要定义hash_value函数并且重载operator==。但是很多系统内置的数据类型都自带这些</li>
<li>那么如果是自定义类型，那么就需要自己重载operator&lt;或者hash_value()了</li>
<li>如果需要内部元素自动排序，使用map，不需要排序使用unordered_map</li>
<li>unordered_map底层使用的是hash_table，而hash_table使用的开链法进行冲突避免，所有hash_map采用开链法进行冲突解决。</li>
<li>当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值，即当前数组的长度乘以加载因子的值的时候，就要自动扩容</li>
<li>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。</li>
</ul>
<h1 id="越界访问下标"><a href="#越界访问下标" class="headerlink" title="越界访问下标"></a>越界访问下标</h1><ul>
<li>通过下标访问vector中的元素时不会做边界检查，即便下标越界<ul>
<li>也就是说，下标与first迭代器相加的结果超过了finish迭代器的位置，程序也不会报错，而是返回这个地址中存储的值。</li>
<li>如果想在访问vector中的元素时首先进行边界检查，可以使用vector中的at函数。通过使用at函数不但可以通过下标访问vector中的元素，而且在at函数内部会对下标进行边界检查。</li>
</ul>
</li>
<li>map的下标运算符[]的作用是：将key作为下标去执行查找，并返回相应的值；如果不存在这个key，就将一个具有该key和value的默认值插入这个map。</li>
</ul>
<h1 id="vector删除元素"><a href="#vector删除元素" class="headerlink" title="vector删除元素"></a>vector删除元素</h1><ul>
<li><code>erase()</code>函数，只能删除内容，不能改变容量大小;</li>
<li><code>erase()</code>函数，它删除了itVect迭代器指向的元素，并且返回要被删除的itVect之后的迭代器，迭代器相当于一个智能指针;</li>
<li><code>clear()</code>函数，只能清空内容，不能改变容量大小;</li>
<li>如果要想在删除内容的同时释放内存，那么你可以选择<code>deque</code>容器。</li>
</ul>
<h1 id="map中-和find"><a href="#map中-和find" class="headerlink" title="map中[]和find()"></a>map中[]和find()</h1><ul>
<li>map的下标运算符<code>[]</code>的作用是：</li>
</ul>
<p>将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。</p>
<ul>
<li>map的<code>find()</code>函数的作用：</li>
</ul>
<p>用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。</p>
<h1 id="list与queue的区别"><a href="#list与queue的区别" class="headerlink" title="list与queue的区别"></a>list与queue的区别</h1><ul>
<li>list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在存储空间中连续存在；</li>
<li>list插入操作和结合才做都不会造成原有的list迭代器失效;</li>
<li>list不仅是一个双向链表，而且还是一个环状双向链表，所以它只需要一个指针；</li>
<li>list不像vector那样有可能在空间不足时做重新配置、数据移动的操作，所以插入前的所有迭代器在插入操作之后都仍然有效；</li>
<li>deque是一种双向开口的连续线性空间，所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作；可以在头尾两端分别做元素的插入和删除操作；</li>
<li>deque和vector最大的差异，一在于deque允许常数时间内对起头端进行元素的插入或移除操作，二在于deque没有所谓容量概念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，deque没有所谓的空间保留功能。</li>
</ul>
<h1 id="allocator-和deallocator"><a href="#allocator-和deallocator" class="headerlink" title="allocator()和deallocator()"></a>allocator()和deallocator()</h1><ul>
<li>第一级配置器直接使用malloc()、free()和relloc()，第二级配置器视情况采用不同的策略：当配置区块超过128bytes时，视之为足够大，便调用第一级配置器；当配置器区块小于128bytes时，为了降低额外负担，使用复杂的内存池整理方式，而不再用一级配置器；</li>
<li>第二级配置器主动将任何小额区块的内存需求量上调至8的倍数，并维护16个free-list，各自管理大小为8~128bytes的小额区块；</li>
<li>空间配置函数allocate()，首先判断区块大小，大于128就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空间；</li>
<li>空间释放函数deallocate()，该函数首先判断区块大小，大于128bytes时，直接调用一级配置器，小于128bytes就找到对应的free-list然后释放内存。</li>
</ul>
<h1 id="哈希表扩容"><a href="#哈希表扩容" class="headerlink" title="哈希表扩容"></a>哈希表扩容</h1><ul>
<li>哈希表中的元素称为bucket，而由桶所链接的元素称为节点node,其中存入桶元素的容器为stl本身很重要的一种序列式容器——vector容器。之所以选择vector为存放桶元素的基础容器，主要是因为vector容器本身具有动态扩容能力，无需人工干预。</li>
<li>向前操作：首先尝试从目前所指的节点出发，前进一个位置，由于节点被安置于list内，所以利用节点的next指针即可轻易完成前进操作，如果目前正巧是list的尾端，就跳至下一个bucket身上，那正是指向下一个list的头部节点。</li>
</ul>
<h1 id="常见容器"><a href="#常见容器" class="headerlink" title="常见容器"></a>常见容器</h1><ul>
<li><p>vector 底层数据结构为数组 ，支持快速随机访问</p>
</li>
<li><p>list 底层数据结构为双向链表，支持快速增删</p>
</li>
<li><p>deque 底层数据结构为一个中央控制器和多个缓冲区，支持首尾快速增删（中间不能快速增减，需要挪动元素），也支持随机访问</p>
<ul>
<li><p>deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下:</p>
<blockquote>
<p>[队列1] –&gt; [队列2] –&gt;[队列3] –&gt; …</p>
</blockquote>
</li>
<li><p>每个队列保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品</p>
</li>
</ul>
</li>
<li><p>stack 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</p>
</li>
<li><p>queue 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</p>
</li>
<li><p>stack和queue其实是适配器,而不叫容器，因为是对容器的再封装</p>
</li>
<li><p>priority_queue 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现</p>
</li>
<li><p>set底层数据结构为红黑树，有序，不重复</p>
</li>
<li><p>multiset底层数据结构为红黑树，有序，可重复</p>
</li>
<li><p>map底层数据结构为红黑树，有序，不重复</p>
</li>
<li><p>multimap底层数据结构为红黑树，有序，可重复</p>
</li>
<li><p>unordered_set底层数据结构为哈希表，无序，不重复</p>
</li>
<li><p>unordered_multiset底层数据结构为哈希表，无序，可重复</p>
</li>
<li><p>unordered_map底层数据结构为哈希表，无序，不重复</p>
</li>
<li><p>unordered_multimap底层数据结构为哈希表，无序，可重复</p>
</li>
</ul>
<h1 id="vector增删的实现"><a href="#vector增删的实现" class="headerlink" title="vector增删的实现"></a>vector增删的实现</h1><ul>
<li>新增元素：</li>
</ul>
<p>vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；</p>
<ul>
<li>对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 ；</li>
<li>初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1；</li>
<li>不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。</li>
</ul>
<blockquote>
<p>采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。</p>
<ul>
<li>考虑可能产生的堆空间浪费，成倍增长倍数不能太大，使用较为广泛的扩容方式有两种，以2二倍的方式扩容，或者以1.5倍的方式扩容。</li>
<li>以2倍的方式扩容，导致下一次申请的内存必然大于之前分配内存的总和，导致之前分配的内存不能再被使用，所以最好倍增长因子设置为(1,2)之间；</li>
<li>向量容器vector的成员函数<code>pop_back()</code>可以删除最后一个元素</li>
<li>而函数<code>erase()</code>可以删除由一个iterator指出的元素，也可以删除一个指定范围的元素。</li>
<li>还可以采用通用算法<code>remove()</code>来删除vector容器中的元素；</li>
<li>不同的是：采用<code>remove()</code>一般情况下不会改变<code>size()</code>的大小，而<code>pop_back()</code>与<code>erase()</code>等成员函数会改变<code>size()</code>的大小。</li>
</ul>
</blockquote>
<h1 id="容器对应的迭代器"><a href="#容器对应的迭代器" class="headerlink" title="容器对应的迭代器"></a>容器对应的迭代器</h1><table>
<thead>
<tr>
<th>容器</th>
<th>迭代器</th>
</tr>
</thead>
<tbody><tr>
<td>vector、deque</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>stack、queue、priority_queue</td>
<td>无</td>
</tr>
<tr>
<td>list、(multi)set/map</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>unordered_(multi)set/map、forward_list</td>
<td>前向迭代器</td>
</tr>
</tbody></table>
<h1 id="unordered-map和map的区别"><a href="#unordered-map和map的区别" class="headerlink" title="unordered_map和map的区别"></a>unordered_map和map的区别</h1><ul>
<li>map支持键值的自动排序，底层机制是红黑树，红黑树的查询和维护时间复杂度均为<code>O(logn)</code>，但是空间占用比较大，因为每个节点要保持父节点、孩子节点及颜色的信息</li>
<li>unordered_map是C++ 11新添加的容器，底层机制是哈希表，通过hash函数计算元素位置，其查询时间复杂度为O(1)，维护时间与bucket桶所维护的list长度有关，但是建立hash表耗时较大</li>
<li>从两者的底层机制和特点可以看出：map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场景</li>
</ul>
<h1 id="哈希冲突的解决方案"><a href="#哈希冲突的解决方案" class="headerlink" title="哈希冲突的解决方案"></a>哈希冲突的解决方案</h1><h2 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h2><h3 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h3><p>使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位</p>
<h3 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h3><p>使用hash函数计算出的位置如果已经有元素占用了，按照<code>1^2</code>、<code>2^2</code>、<code>3^2</code>…的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测</p>
<h2 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h2><p>每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中</p>
<h2 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h2><p>发生冲突时使用另一种hash函数再计算一个地址，直到不冲突</p>
<h2 id="公共溢出区"><a href="#公共溢出区" class="headerlink" title="公共溢出区"></a>公共溢出区</h2><p>一旦hash函数计算的结果相同，就放入公共溢出区</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote>
<p>转载自<a href="https://github.com/forthespada/InterviewGuide">https://github.com/forthespada/InterviewGuide</a>，感激大佬的整理和分享！</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell-入门概述</title>
    <url>/2021/02/19/HelloShell/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><p>linux是通过内核接口方式控制计算机的硬件</p>
</li>
<li><p>而程序猿通过shell命令的方式让内核去操作计算机的硬件</p>
</li>
<li><p>一系列的shell命令编写的shell文本，便是我们常说的shell脚本</p>
</li>
</ul>
<h1 id="Shell运行流程"><a href="#Shell运行流程" class="headerlink" title="Shell运行流程"></a>Shell运行流程</h1><p><img src="https://jiajuu.top/2021/02/19/HelloShell/ShellProcess.PNG" alt="Shell运行流程"></p>
<h1 id="Shell解析器"><a href="#Shell解析器" class="headerlink" title="Shell解析器"></a>Shell解析器</h1><p><code>cat /etc/shells</code>查询linux支持的Shell解释器</p>
<p><code>echo $shell</code>查询现在默认使用的Shell解释器，其中$shell是全局共享的环境变量</p>
<table>
<thead>
<tr>
<th>常见解释器</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td>/bin/sh</td>
<td align="left">UNIX最初使用的shell</td>
</tr>
<tr>
<td><strong>/bin/bash</strong></td>
<td align="left"><strong>linux默认的解释器</strong></td>
</tr>
<tr>
<td>/sbin/nologin</td>
<td align="left">未登录解释器，用于控制用户禁止登陆系统的，针对部分不需要登陆的服务（例如邮件服务）</td>
</tr>
<tr>
<td>/bin/csh</td>
<td align="left">C语言风格的shell</td>
</tr>
</tbody></table>
<h1 id="Shell脚本文件"><a href="#Shell脚本文件" class="headerlink" title="Shell脚本文件"></a>Shell脚本文件</h1><p><code>.sh</code>Shell脚本文件后缀常</p>
<p><code>#!/usr/bin/bash</code>首行设置默认Shell解释器，声明该脚本文件所采用的解释器</p>
<p><code># 注释内容</code>单行注释</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;!</span><br><span class="line">多行注释1</span><br><span class="line">多行注释2</span><br><span class="line">多行注释3</span><br><span class="line">！</span><br></pre></td></tr></table></figure>
<h2 id="Shell脚本文件执行"><a href="#Shell脚本文件执行" class="headerlink" title="Shell脚本文件执行"></a>Shell脚本文件执行</h2><p><code>sh HelloWorld.sh</code>sh解释器执行，</p>
<p><code>bash HelloWorld.sh</code>bash解释器执行</p>
<p><code>./HelloWorld.sh</code>路径执行，文件需要可执行权限</p>
<p><strong>区别：</strong></p>
<ul>
<li>sh&amp;bash执行脚本是直接使用解释器运行脚本文件，无需可执行权限</li>
<li>路径执行需要可执行权限，且采用的解释器为脚本文件的首行声明解释器</li>
</ul>
<h2 id="Shell脚本多命令执行"><a href="#Shell脚本多命令执行" class="headerlink" title="Shell脚本多命令执行"></a>Shell脚本多命令执行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">:&lt;&lt;!</span><br><span class="line">1.在&#x2F;home&#x2F;jiajuu路径下创建test目录</span><br><span class="line">2.在&#x2F;home&#x2F;jiajuu&#x2F;test路径下创建hello.txt文件</span><br><span class="line">3.输出Hello Shell到test01.sh文件中</span><br><span class="line">!</span><br><span class="line">mkdir &#x2F;home&#x2F;jiajuu&#x2F;test</span><br><span class="line">touch &#x2F;home&#x2F;jiajuu&#x2F;test&#x2F;test01.sh</span><br><span class="line">echo &quot;Holle Shell&quot; &gt;&gt; &#x2F;home&#x2F;jiajuu&#x2F;test&#x2F;hello.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2077/09/17/HelloWorld/</url>
    <content><![CDATA[<blockquote>
<p>“Talk is cheap，Show me the code。    —— Linus Torvalds”             </p>
<p>“冗談無用，源碼拿來。    —— 林纳斯·托瓦兹”</p>
</blockquote>
<ul>
<li><p>2021/02/28    阴</p>
<p>弄了个Travis-CI来自动部署Hexo，以后可以随便找台电脑就能更新Blog了，不需要在新电脑上重新配置node.js那些鬼玩意了。感觉可以写一下关于部署Travis过程的Blog，但是要以后找时间了，希望能不鸽哈ε=ε=ε=┏(゜ロ゜;)┛</p>
</li>
<li><p>2021/02/26    阴</p>
<p>写了几天的关于leetcode的博文，感觉还行，所以打算以后尽量保持每天写一篇。然后这几天计划抽空把以前typecho上的文章新整理一下C++、计网、操作系统的笔记再搬回来，顺便梳理一下知识点为春招作准备。(ง •_•)ง</p>
</li>
<li><p>2021/02/04    晴</p>
<p>电脑进益力多的缘故，耽误了一周多的时间。终于将diaspora主题反人类的gitalk评论系统改成valine的评论系统了。被迫摸鱼┭┮﹏┭┮！！</p>
</li>
<li><p>2021/01/23    晴</p>
<p>从typecho转hexo，不可以再像以前那么摸鱼了(￣▽￣)”</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Shell-算数计算</title>
    <url>/2021/02/23/ShellCalculation/</url>
    <content><![CDATA[<h1 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h1><h2 id="expr求值表达式"><a href="#expr求值表达式" class="headerlink" title="expr求值表达式"></a>expr求值表达式</h2><blockquote>
<p>可以实现整数计算</p>
<p>可以对字符串进行处理(例如计算字符串长度、字符串比较、字符串匹配、字符串提取)</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expr 1 + 1 #直接输出结果</span><br><span class="line"></span><br><span class="line">res=`expr 1 + 1` #返回结果给res变量</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加法</td>
<td><code>expr $a + $b</code>结果为3</td>
</tr>
<tr>
<td><code>-</code></td>
<td>减法</td>
<td><code>expr $a - $b</code>结果为-1</td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘法</td>
<td><code>expr $a \* $b</code>结果为2</td>
</tr>
<tr>
<td><code>/</code></td>
<td>除法</td>
<td><code>expr $a / $b</code>结果为2</td>
</tr>
<tr>
<td><code>%</code></td>
<td>取余</td>
<td><code>expr $a % $b</code>结果为0</td>
</tr>
<tr>
<td><code>=</code></td>
<td>赋值</td>
<td><code>a=$b</code>把变量b赋值给变量a</td>
</tr>
</tbody></table>
<blockquote>
<p>其中a = 1，b = 2</p>
<p>注意：四则运算中使用<code>()</code>也需要转义<code>\( 1 + 1 \)</code></p>
</blockquote>
<h1 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h1><h2 id="整数比较"><a href="#整数比较" class="headerlink" title="整数比较"></a>整数比较</h2><table>
<thead>
<tr>
<th>运算符eq</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-eq</code></td>
<td>equals检测两个数是否相等，相等返回0，否则返回1。</td>
<td><code>[ $a -eq $b ]</code>返回1</td>
</tr>
<tr>
<td><code>-ne</code></td>
<td>not equals检测两个数是否不相等，不相等返回ture</td>
<td><code>[ $a -ne $b ]</code>返回0</td>
</tr>
<tr>
<td><code>-gt</code></td>
<td>greater than 检测左边数是否大于右边数，大于返回0，否则返回1</td>
<td><code>[ $a -gt $b ]</code>返回1</td>
</tr>
<tr>
<td><code>-lt</code></td>
<td>lower than 检测左边数是否小于右边数，小于返回0，否则返回1</td>
<td><code>[ $a -lt $b ]</code>返回0</td>
</tr>
<tr>
<td><code>-ge</code></td>
<td>greater equals检测左边数是否大于等于右边数，大于等于返回0，否则返回1</td>
<td><code>[ $a -ge $b ]</code>返回1</td>
</tr>
<tr>
<td><code>-le</code></td>
<td>lower equals 检测左边数是否小于等于右边数，小于等于返回0，否则返回1</td>
<td><code>[ $a -le $b ]</code>返回0</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>检测左边数是否小于右边数，小于返回0，否则返回1</td>
<td><code>(($a&lt;$b))</code>返回1</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>检测左边数是否小于等于右边数，小于等于返回0，否则返回1</td>
<td><code>(($a&lt;=$b))</code>返回0</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>检测左边数是否大于右边数，大于返回0，否则返回1</td>
<td><code>(($a&gt;=$b))</code>返回1</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>检测左边数是否大于等于右边数，大于等于返回0，否则返回1</td>
<td><code>(($a&gt;=$b))</code>返回0</td>
</tr>
<tr>
<td><code>==</code></td>
<td>检测两个数是否相等，相等返回0，否则返回1。</td>
<td><code>(($a==$b))</code>返回0</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>检测两个数是否不相等，不相等返回true</td>
<td><code>(($a!=$b))</code>返回1</td>
</tr>
</tbody></table>
<blockquote>
<p>其中a = 1，b = 1</p>
<p>注意：整数比较运算符仅支持整数运算，不支持浮点数与字符串</p>
<p><code>[]</code>与 <code>(())</code>的区别：</p>
<ul>
<li><code>[]</code>参数为<code>-eq</code> <code>-gt</code> <code>-ge</code> <code>-lt</code> <code>-le</code> <code>ne</code></li>
<li><code>()</code>参数为 <code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code> <code>==</code> <code>!=</code></li>
</ul>
</blockquote>
<h2 id="字符串比较运算符"><a href="#字符串比较运算符" class="headerlink" title="字符串比较运算符"></a>字符串比较运算符</h2><blockquote>
<p>可以比较数字与字符串</p>
</blockquote>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code>或者<code>=</code></td>
<td>相等,用于比较两个字符串或数字,相同返回0</td>
<td><code>[ $a == $b ]</code>返回1<br><code> [ $a = $b ]</code>返回1<br><code>[[ $a == $b ]]</code>返回1<br><code>[[ $a = $b ]]</code>返回1</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不相等,用于比较两个字符串或数字,不相同返回0</td>
<td><code>[ $a != $b ]</code>返回0<br/><code>[[ $a != $b]]</code>返回0</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于,用于比较两个字符串或数字,小于返回0,否则返回1</td>
<td><code>[ $a \&lt; $b ]</code>返回0<br/><code>[[ $a &lt; $b]]</code>返回0</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于,用于比较两个字符串或数字,大于返回0,否则返回1</td>
<td><code>[ $a \&gt; $b ]</code>返回1<br/><code>[[ $a &gt; $b]]</code>返回1</td>
</tr>
<tr>
<td><code>-z</code></td>
<td>检测字符串长度是否为0,为0返回true</td>
<td>[-z “$a”]返回false</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>检测字符串长度是否不为0,不为0返回true</td>
<td>[-n “$a”]返回true</td>
</tr>
<tr>
<td><code>$</code></td>
<td>检测字符串长度是否为空,不为空返回true</td>
<td>[ $a ]返回true</td>
</tr>
</tbody></table>
<blockquote>
<p>其中a=”abc”,b=”efg”</p>
<p>注意：字符串比较没有<code>&lt;=</code>,但是可以通过<code>[[ &quot;a&quot; &lt; &quot;b&quot; &amp;&amp; &quot;a&quot; == &quot;b&quot; ]]</code></p>
<br>

<p><code>[]</code>与 <code>[[]]</code>的区别：</p>
<ul>
<li><p>区别①</p>
<p><code>[]</code>会有word splitting发生,即将含有空格字符的字符串进行分拆分割后再进行比较</p>
<p><code>[[]]</code>不会有word splitting发生</p>
</li>
<li><p>区别②</p>
<p><code>[]</code>不会对<code>&lt;</code>进行转义,需要手动转义</p>
<p><code>[[]]</code>自动对<code>&lt;</code>进行转义,不需要手动转义</p>
</li>
</ul>
</blockquote>
<h1 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h1><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><code>!</code></td>
<td>非运算,取反,表达式为true则返回false,否则返回true</td>
<td><code>[ ! 表达式 ]</code>取反</td>
</tr>
<tr>
<td><code>-o</code></td>
<td>or或运算,有一个表达式为true则返回true</td>
<td><code>[ 表达式1 -o 表达式2 ]</code></td>
</tr>
<tr>
<td><code>-a</code></td>
<td>and与运算,两个表达式都为true才返回true</td>
<td><code>[ 表达式1 -a 表达式2 ]</code></td>
</tr>
</tbody></table>
<blockquote>
<p>注意：布尔运算符需要与<code>[]</code>或<code>test</code>命令配合使用才有效</p>
</blockquote>
<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑AND</td>
<td><code>[[ 表达式1 &amp;&amp; 表达式2 ]]</code></td>
</tr>
<tr>
<td><code>||</code></td>
<td>逻辑OR</td>
<td><code>[[ 表达式1 || 表达式2 ]]</code></td>
</tr>
<tr>
<td><code>!</code></td>
<td>逻辑NOT</td>
<td><code>[[ ! 表达式 ]]</code></td>
</tr>
</tbody></table>
<blockquote>
<p>注意：</p>
<ul>
<li>使用<code>&amp;&amp;</code> 与<code>||</code>需要配合<code>[[]]</code>或<code>(())</code>使用,否则会报错(╯▔皿▔)╯</li>
<li><code>!</code>可以配合<code>[]</code> 或<code>[[]]</code>,但是不可以配合<code>(())</code></li>
</ul>
<br>

<p>逻辑运算符与布尔运算符区别：</p>
<ul>
<li>布尔运算符：<code>!</code> <code>-o</code> <code>-a</code> 且必须搭配<code>[]</code>或<code>test</code>命令使用</li>
<li>逻辑运算符： <code>||</code> <code>&amp;&amp;</code>且必须搭配<code>[[]]</code>或<code>(())</code>使用,<code>!</code>不能配合<code>(())</code>使用</li>
</ul>
</blockquote>
<h1 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h1><blockquote>
<p>用于检测文件</p>
<p>检测文件是否存在\是否可读\是否可执行\是否为空\是否可写\是否为名录\是否是普通文件</p>
</blockquote>
<h2 id="linux系统文件类型"><a href="#linux系统文件类型" class="headerlink" title="linux系统文件类型"></a>linux系统文件类型</h2><p><code>-</code>：普通文件</p>
<p><code>d</code>：目录文件</p>
<p><code>l</code>：链接文件</p>
<p><code>b</code>：块设备文件</p>
<blockquote>
<p>对应计算机硬件,以块为单位传输数据</p>
</blockquote>
<p><code>c</code>：字符设备文件</p>
<blockquote>
<p>对应计算机硬件,以字符为单位传输数据</p>
</blockquote>
<p><code>p</code>：管道文件</p>
<h2 id="文件属性检测"><a href="#文件属性检测" class="headerlink" title="文件属性检测"></a>文件属性检测</h2><table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-b file</code></td>
<td>检测文件是否为块设备文件,是返回true</td>
<td><code>[ -b $file ]</code>返回false</td>
</tr>
<tr>
<td><code>-c file</code></td>
<td>检测文件是否为字符设备文件,是返回true</td>
<td><code>[ -c $file ]</code>返回false</td>
</tr>
<tr>
<td><code>-d file</code></td>
<td>directory,检测文件是否为目录,是返回true</td>
<td><code>[ -d $file ]</code>返回false</td>
</tr>
<tr>
<td><code>-f file</code></td>
<td>file,检测文件是否为普通文件,是返回true</td>
<td><code>[ -f $file ]</code>返回ture</td>
</tr>
<tr>
<td><code>-g file</code></td>
<td>检测文件是否设置了SGID位,是返回true</td>
<td><code>[ -g $file ]</code>返回false</td>
</tr>
<tr>
<td><code>-k file</code></td>
<td>检测文件是否设置了粘着位,是返回true</td>
<td><code>[ -k $file ]</code>返回false</td>
</tr>
<tr>
<td><code>-p file</code></td>
<td>检测文件是否为有名管道文件,是返回true</td>
<td><code>[ -p $file ]</code>返回false</td>
</tr>
<tr>
<td><code>-u file</code></td>
<td>检测文件是否设置了SUID位,是返回true</td>
<td><code>[ -u $file ]</code>返回false</td>
</tr>
<tr>
<td><code>-r file</code></td>
<td>read,检测文件是否可读,是返回true</td>
<td><code>[ -r $file ]</code>返回true</td>
</tr>
<tr>
<td><code>-w file</code></td>
<td>write,检测文件是否可写,是返回true</td>
<td><code>[ -w $file ]</code>返回true</td>
</tr>
<tr>
<td><code>-x file</code></td>
<td>execute,检测文件是否可执行,是返回true</td>
<td><code>[ -x $file ]</code>返回true</td>
</tr>
<tr>
<td><code>-s file</code></td>
<td>size,检测文件是否为空,是返回true</td>
<td><code>[ -s $file ]</code>返回true</td>
</tr>
<tr>
<td><code>-e file</code></td>
<td>exists,检测文件是否存在,是返回true</td>
<td><code>[ -e $file ]</code>返回true</td>
</tr>
<tr>
<td><code>file1 -nt file2</code></td>
<td>newer than,检测文件1是否比文件2新,是返回true</td>
<td><code>[ file1 -nt file2 ]</code>返回</td>
</tr>
<tr>
<td><code>file1 -ot file2</code></td>
<td>older than,检测文件1是否比文件2旧,是返回true</td>
<td><code>[ $file1 -ot file2 ]</code>返回</td>
</tr>
<tr>
<td><code>-S file</code></td>
<td>socket,检测文件是否为socket,是返回true</td>
<td><code>[ -S $file ]</code>返回false</td>
</tr>
<tr>
<td><code>-L file</code></td>
<td>link,检测文件是否存在并且是一个符号链接,是返回true</td>
<td><code>[ -L $file ]</code>返回false</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：</p>
<ul>
<li><p>配合<code>[]</code>或<code>[[]]</code>均可</p>
</li>
<li><p>file需要为路径字符串</p>
</li>
</ul>
</blockquote>
<h1 id="计算命令"><a href="#计算命令" class="headerlink" title="计算命令"></a>计算命令</h1><h2 id="expr命令详解"><a href="#expr命令详解" class="headerlink" title="expr命令详解"></a>expr命令详解</h2><blockquote>
<p>优点：可以直接输出整数表达式结果</p>
<p>缺点：</p>
<ol>
<li>表达式内引用变量需要使用<code>$</code></li>
<li>特殊字符需要转义</li>
<li>只能计算一个表达式</li>
</ol>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">计算语法</span></span><br><span class="line">expr 1 + 1 #返回2</span><br><span class="line">expr \( 10 + 10 \) \* 2 + 100 #返回140</span><br><span class="line">res=`expr 1 + 1` #输出结果给res变量</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">字符串语法</span></span><br><span class="line"><span class="meta">#</span><span class="bash">计算字符串长度</span></span><br><span class="line">expr length &quot;jiajuu&quot; #返回6</span><br><span class="line"><span class="meta">#</span><span class="bash">截取字符串</span></span><br><span class="line">expr substr &quot;jiajuu&quot; 1 3 #返回jia</span><br><span class="line"><span class="meta">#</span><span class="bash">获取第一个字符再字符串出现的位置</span></span><br><span class="line">expr index &quot;jiajuu&quot; i #返回2</span><br><span class="line"><span class="meta">#</span><span class="bash">正则表达式匹配</span></span><br><span class="line">expr match &quot;jiajuu&quot; &quot;.*a&quot; #返回3</span><br><span class="line">expr &quot;jiajuu&quot; : &quot;.*a&quot; #返回3</span><br></pre></td></tr></table></figure>
<h2 id="命令详解"><a href="#命令详解" class="headerlink" title="(())命令详解"></a>(())命令详解</h2><blockquote>
<p><code>(())</code>可用于进行数学运算表达式的执行</p>
<p>并且可以使用<code>$</code>获取<code>(())</code>表达式命令中的结果</p>
<p><br>优点：</p>
<ol>
<li>直接计算表达式，特殊符号不需要转义</li>
<li>可以多个表达式赋值</li>
</ol>
<p>缺点：需要变量获取结果才能输出</p>
<p>(悄悄话：直接输出计算结果推荐方式（b(￣▽￣)d）)</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">计算完成给变量赋值,注意：不需要添加<span class="string">&quot;$&quot;</span>,能自动解析变量</span></span><br><span class="line">((a=1+6))</span><br><span class="line">((b=a-1))</span><br><span class="line">((c=a+b))</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">用<span class="string">&quot;(())&quot;</span>前添加<span class="string">&quot;$&quot;</span>获取<span class="string">&quot;(())&quot;</span>命令的结果</span></span><br><span class="line">a=$((1+6))</span><br><span class="line">b=$((a-1))</span><br><span class="line">c=$((a+b))she</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">用<span class="string">&quot;(())&quot;</span>进行逻辑运算,常用于<span class="keyword">if</span>语句</span></span><br><span class="line"><span class="meta">((a&gt;</span><span class="bash">7 &amp;&amp; b==c))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">输出运算结果</span></span><br><span class="line">echo $((a+10))</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">对多个表达式同时进行计算,用<span class="string">&quot;,&quot;</span>进行分割</span></span><br><span class="line">((a=3+5,b=a+10))</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="let命令详解"><a href="#let命令详解" class="headerlink" title="let命令详解"></a>let命令详解</h2><blockquote>
<p>与<code>(())</code>命令在数字计算方面一样，</p>
<p><code>let</code>是最简洁的整数运算赋值命令，</p>
<p>但是功能没有<code>(())</code>命令功能强大.<code>let</code>只能用于赋值计算,不能直接输出,也不可以进行条件判断。</p>
<p><br>优点：赋值简单，特殊符号不需要转义</p>
<p>缺点：无法直接输出结果，需要变量获取结果再输出</p>
<p>(悄悄话：赋值操作推荐方式（b(￣▽￣)d）)</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">let a=1+6 #计算1+6赋值给变量a</span><br><span class="line"></span><br><span class="line">let b=a-1 #将变量a-1赋值给变量b</span><br><span class="line"></span><br><span class="line">let c=a+b #将变量a+变量b赋值给变量c</span><br><span class="line"></span><br><span class="line">let a=1+6 b=a-1 c=a+b #多个表达式计算赋值</span><br></pre></td></tr></table></figure>


<h2 id="命令详解-1"><a href="#命令详解-1" class="headerlink" title="$[]命令详解"></a>$[]命令详解</h2><blockquote>
<p>和<code>(())</code>、<code>let</code>命令类似，</p>
<p>但是<code>$[]</code>只能进行整数运算，且只能对单个表达式进行计算求值和输出</p>
<p>而且内部不能对变量赋值</p>
<p><br>优点：赋值简单，特殊符号不需要转义</p>
<p>缺点：不能多表达式运算</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=$[1+6]</span><br><span class="line">b=$[a-1]</span><br><span class="line">c=$[a+b]</span><br><span class="line">echo &quot;$[1+6],$[a-1],$[a+b]&quot;</span><br></pre></td></tr></table></figure>


<h2 id="bc命令详解"><a href="#bc命令详解" class="headerlink" title="bc命令详解"></a>bc命令详解</h2><blockquote>
<p>Bash Shell内置了对整型运算的支持，但是不提供符点运算</p>
<p>而<code>bc</code>命令可以对符点型进行方便的符点运算，是linux简单的计算器</p>
<p><code>bc</code>命令不仅可以进行任意精度的符点计算，还能进行进制的转换</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bc [options] [参数]</span><br></pre></td></tr></table></figure>

<h3 id="options"><a href="#options" class="headerlink" title="options"></a>options</h3><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-h</code></td>
<td>help，帮助信息</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>version，显示命令版本信息</td>
</tr>
<tr>
<td><code>-l</code></td>
<td>mathlib，使用标准数学库，例如使用内置函数就需要使用这个选项</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>interactive，强制交互</td>
</tr>
<tr>
<td><code>-w</code></td>
<td>warn，显示POSIX的警告信息</td>
</tr>
<tr>
<td><code>-s</code></td>
<td>standard，使用POSIX标准来处理</td>
</tr>
<tr>
<td><code>-q</code></td>
<td>quiet，不显示欢迎信息(默认bc启动会有欢迎信息)</td>
</tr>
</tbody></table>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>指定包含计算任务的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bc task.txt</span><br></pre></td></tr></table></figure>
<p>task.txt文件</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">108*67+12345</span><br><span class="line">58+2007*11</span><br></pre></td></tr></table></figure>


<h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><table>
<thead>
<tr>
<th>变量名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>scale</code></td>
<td>指定精度，即小数点后的位数。默认为0，不适用小数部分</td>
</tr>
<tr>
<td><code>ibase</code></td>
<td>指定输入的数字进制。默认为十进制</td>
</tr>
<tr>
<td><code>obase</code></td>
<td>指定输出的数字进制。默认为十进制</td>
</tr>
<tr>
<td><code>last</code>或者<code>.</code></td>
<td>获取最近计算打印结果的数字</td>
</tr>
</tbody></table>
<h3 id="内置数学函数"><a href="#内置数学函数" class="headerlink" title="内置数学函数"></a>内置数学函数</h3><blockquote>
<p>需要把options设为-i，才能使用内置数学函数</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>s(x)</code></td>
<td>计算x的正弦值，x是弧度值</td>
</tr>
<tr>
<td><code>c(x)</code></td>
<td>计算x的余弦值，x是弧度值</td>
</tr>
<tr>
<td><code>a(x)</code></td>
<td>计算x的反正切值，返回弧度值</td>
</tr>
<tr>
<td><code>l(x)</code></td>
<td>计算x的自然对数</td>
</tr>
<tr>
<td><code>e(x)</code></td>
<td>计算e的x次方</td>
</tr>
<tr>
<td><code>j(n,x)</code></td>
<td>计算从n到x的阶数</td>
</tr>
</tbody></table>
<h3 id="借助管道使用bc运算"><a href="#借助管道使用bc运算" class="headerlink" title="借助管道使用bc运算"></a>借助管道使用bc运算</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">直接进行bc的表达式</span></span><br><span class="line">echo &quot;scale=2;9*6/3.3&quot; | bc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">引用Shell变量</span></span><br><span class="line">a=2</span><br><span class="line">echo &quot;b=$a+2;b&quot; | bc #其中的b是bc命令中的变量，不是Shell变量</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将bc计算结果赋值给Shell变量</span></span><br><span class="line">value = `ehco &quot;1+1&quot; | bc` #所有linux系统均支持的方式</span><br><span class="line">value = $(ehco &quot;1+1&quot; | bc) #不是所有linux均支持</span><br></pre></td></tr></table></figure>
<blockquote>
<p>表达式必须符合bc命令要求的公式</p>
<p>表达式可以引用shell变量</p>
</blockquote>
<h3 id="输入重定向到bc运算"><a href="#输入重定向到bc运算" class="headerlink" title="输入重定向到bc运算"></a>输入重定向到bc运算</h3><blockquote>
<p>特点类似于文件中输入，支持多行表达式（b(￣▽￣)d）</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">方式一，使用``</span></span><br><span class="line">value=`bc &lt;&lt; EOF</span><br><span class="line">ibase=10;</span><br><span class="line">obase=2;</span><br><span class="line">b=9*9</span><br><span class="line">EOF</span><br><span class="line">`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">方式二，使用$()</span></span><br><span class="line">value=$(bc &lt;&lt; EOF</span><br><span class="line">ibase=10;</span><br><span class="line">obase=2;</span><br><span class="line">b=9*9</span><br><span class="line">EOF</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell-常用内置命令</title>
    <url>/2021/02/21/ShellCommand/</url>
    <content><![CDATA[<blockquote>
<p>内置命令相比于可执行脚本文件的优势：</p>
<p>内置命令碧可执行文件执行得更快</p>
<p>因为执行外部命令不但会触发磁盘I/O，还需要fork一个独立进程来执行，执行完毕再退出</p>
<p>而执行内置命令相当于调用当前Shell进程的一个函数，仍然再当前Shell环境进程内执行，减少了上下文切换的开销</p>
</blockquote>
<h1 id="查询是否为内置命令"><a href="#查询是否为内置命令" class="headerlink" title="查询是否为内置命令"></a>查询是否为内置命令</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">type commmand</span><br></pre></td></tr></table></figure>


<h1 id="alias设置别名"><a href="#alias设置别名" class="headerlink" title="alias设置别名"></a>alias设置别名</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias #查询显示当前Shell进程的所有别名列表</span><br><span class="line">alias 别名=&quot;command&quot; #为命令添加别名</span><br><span class="line"></span><br><span class="line">unalias 别名 #删除别名</span><br><span class="line">unalias -a #删除所有别名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>P.S 删除别名只能临时删除当前Shell别名，若想永久删除需要去配置文件中手动删除</p>
</blockquote>
<h1 id="echo输出字符串"><a href="#echo输出字符串" class="headerlink" title="echo输出字符串"></a>echo输出字符串</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 字符串 #默认换行输出</span><br><span class="line">echo -n 字符串 #不换行输出</span><br><span class="line">echo -e 字符串 #解析转义字符输出</span><br></pre></td></tr></table></figure>


<h1 id="read读取控制台输入"><a href="#read读取控制台输入" class="headerlink" title="read读取控制台输入"></a>read读取控制台输入</h1><blockquote>
<p>默认从终端控制台读取用户输入数据</p>
<p>若进行重定向，则可以从文件中读取数据</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">read #若没有提供变量，默认会把读取的数据存放到REPLY环境变量中，$REPLY会保存read最后一个读入的数据</span><br><span class="line">read value #读入数据到value变量中</span><br><span class="line">read -p &quot;请输入数值&quot; value #显示提示信息</span><br><span class="line">read -n 5 value #读取5个字符到value变量中</span><br><span class="line">read -t 2 value #设置2秒超时时间，超出时间没有输入完成，read会返回一个非零状态码，表示读取失败</span><br><span class="line">read -s value #静默模式，屏幕不显示输入字符，常用于密码输入</span><br><span class="line">read -a array #读取数据赋值到数组array中</span><br><span class="line">read -d delimiter value #用delimiter字符串指定读取结束的位置，而非换行符(回车)，value变量内容不包含delimiter字符串</span><br><span class="line">read -e #获取用户输入时，对功能码进行编码转换，不会直接显示功能键对于的字符</span><br><span class="line">read -r #原样读取，不会把反斜杠解释为转移字符</span><br><span class="line">read -u fd #使用文件描述符fd作为输入源，和重定向相似</span><br></pre></td></tr></table></figure>


<h1 id="exit退出"><a href="#exit退出" class="headerlink" title="exit退出"></a>exit退出</h1><blockquote>
<p>用于退出当前Shell进程，并且会返回状态码</p>
<p>可使用<code>$?</code>查看退出状态码</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit #正确退出，默认换回状态码0，一般代表命令执行成功</span><br><span class="line"></span><br><span class="line">exit 非零数字 #错误退出，建议返回0~255(不同状态码代表不同的错误)，一般代表命令执行失败</span><br></pre></td></tr></table></figure>


<h1 id="declare设置变量"><a href="#declare设置变量" class="headerlink" title="declare设置变量"></a>declare设置变量</h1><blockquote>
<ul>
<li>声明Shell变量</li>
<li>声明变量并设置变量的属性</li>
<li>显示Shell函数</li>
<li>显示所有Shell变量和函数(set指令相似)</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">declare #显示所有Shell变量和函数</span><br><span class="line">declare -f #查询所有函数的定义</span><br><span class="line">declare -F #查询所有函数的名称列表</span><br><span class="line"></span><br><span class="line">declare [-/+][aArxif][变量名称=设置值]</span><br><span class="line"><span class="meta">#</span><span class="bash">+/-：<span class="string">&quot;-&quot;</span>用来指定变量的属性，<span class="string">&quot;+&quot;</span>则是取消变量所设的属性</span></span><br><span class="line"><span class="meta">#</span><span class="bash">a array：设置为普通索引数组</span></span><br><span class="line"><span class="meta">#</span><span class="bash">A Array：设置为key-value关联数组</span></span><br><span class="line"><span class="meta">#</span><span class="bash">r <span class="built_in">readonly</span>：设置为只读变量，也可以直接使用<span class="built_in">readonly</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">x <span class="built_in">export</span>：设置为常量，也可以直接使用<span class="built_in">export</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">i int：设置为整型变量</span></span><br><span class="line"><span class="meta">#</span><span class="bash">f <span class="keyword">function</span>：设置为一个函数变量</span></span><br></pre></td></tr></table></figure>
<h2 id="关联数组变量"><a href="#关联数组变量" class="headerlink" title="关联数组变量"></a>关联数组变量</h2><blockquote>
<p>关联数组最好用declare方法创建，直接用变量创建关联数组会有大坑(╯▔皿▔)╯</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">declare -A 关联数组变量名=([字符串key1]=值1 [字符串key2]=值2 [字符串key2]=值2 ...)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">获取指定key的值</span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;关联数组变量名[key]&#125;</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">获取所有值</span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;关联数组变量名[*]&#125; <span class="comment">#方式1</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;关联数组变量名[@]&#125; <span class="comment">#方式2</span></span></span><br></pre></td></tr></table></figure>


<h2 id="索引数组变量"><a href="#索引数组变量" class="headerlink" title="索引数组变量"></a>索引数组变量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">declare -a 索引数组变量名=(值1 值2 值3 ...)</span><br><span class="line">declare -a 索引数组变量名=([0]=值1 [1]=值2 [2]=值3 ...)</span><br></pre></td></tr></table></figure>


<h1 id="test测试"><a href="#test测试" class="headerlink" title="test测试"></a>test测试</h1><h2 id="整数比较测试"><a href="#整数比较测试" class="headerlink" title="整数比较测试"></a>整数比较测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test 1 -eq 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>test命令和<code>[]</code>用法相似</p>
</blockquote>
<table>
<thead>
<tr>
<th>options</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-eq</code></td>
<td>等于则为真</td>
</tr>
<tr>
<td><code>-ne</code></td>
<td>不等于则为真</td>
</tr>
<tr>
<td><code>-gt</code></td>
<td>大于则为真</td>
</tr>
<tr>
<td><code>-ge</code></td>
<td>大于等于则为真</td>
</tr>
<tr>
<td><code>-lt</code></td>
<td>小于则为真</td>
</tr>
<tr>
<td><code>-le</code></td>
<td>小于等于则为真</td>
</tr>
</tbody></table>
<h2 id="字符串比较测试"><a href="#字符串比较测试" class="headerlink" title="字符串比较测试"></a>字符串比较测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test &quot;a&quot; == &quot;b&quot;</span><br><span class="line">test -z &quot;aaa&quot;</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>options</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code>或<code>==</code></td>
<td>等于，等于返回0代表成功，否则返回1代表失败</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于</td>
</tr>
<tr>
<td><code>\&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>\&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>-z</code></td>
<td>字符串长度为零则为真</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>字符串长度不为零则为真</td>
</tr>
</tbody></table>
<h2 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h2><table>
<thead>
<tr>
<th>options</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-e</code></td>
<td>exists，如果文件存在则为真</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>read，如果文件存在且可读则为真</td>
</tr>
<tr>
<td><code>-w</code></td>
<td>write，如果文件存在且可写则为真</td>
</tr>
<tr>
<td><code>-x</code></td>
<td>execute，如果文件存在且可执行则为真</td>
</tr>
<tr>
<td><code>-s</code></td>
<td>string，如果文件存在且至少有一个字符则为真</td>
</tr>
<tr>
<td><code>-d</code></td>
<td>directory，如果文件存在且为目录则为真</td>
</tr>
<tr>
<td><code>-f</code></td>
<td>file，如果文件存在且为普通文件则为真</td>
</tr>
<tr>
<td><code>-c</code></td>
<td>character，如果文件存在且为字符型特殊文件则为真</td>
</tr>
<tr>
<td><code>-b</code></td>
<td>如果文件存在且为块特殊文件则为真</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell-工作环境加载流程原理</title>
    <url>/2021/02/21/ShellEnv/</url>
    <content><![CDATA[<h1 id="Shell工作环境分类"><a href="#Shell工作环境分类" class="headerlink" title="Shell工作环境分类"></a>Shell工作环境分类</h1><blockquote>
<p>用户进入linux系统就会初始化Shell环境，这个时候会加载全局配置文件和用户个人配置文件中的环境变量</p>
<p>每个脚本的执行也有其自己的Shell环境</p>
</blockquote>
<h2 id="交互式Shell-amp-非交互式Shell"><a href="#交互式Shell-amp-非交互式Shell" class="headerlink" title="交互式Shell&amp;非交互式Shell"></a>交互式Shell&amp;非交互式Shell</h2><table>
<thead>
<tr>
<th>类型名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>交互式Shell</td>
<td>与用户进行交互，用户输入，Shell环境立即响应</td>
</tr>
<tr>
<td>非交互式Shell</td>
<td>不需要用户参与便执行多个命令，例如我们的Shell脚本，直接执行并返回结果</td>
</tr>
</tbody></table>
<h2 id="登陆Shell-amp-非登陆式Shell"><a href="#登陆Shell-amp-非登陆式Shell" class="headerlink" title="登陆Shell&amp;非登陆式Shell"></a>登陆Shell&amp;非登陆式Shell</h2><table>
<thead>
<tr>
<th>类型名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Shell登陆环境</td>
<td>需要用户名/密码登陆的Shell环境</td>
</tr>
<tr>
<td>Shell非登陆环境</td>
<td>不需要用户名/密码进入的Shell环境 或 执行脚本文件的环境</td>
</tr>
</tbody></table>
<blockquote>
<p>P.S. 不同的工作环境加载环境变量的流程不一样</p>
</blockquote>
<h1 id="Shell登陆环境的加载流程"><a href="#Shell登陆环境的加载流程" class="headerlink" title="Shell登陆环境的加载流程"></a>Shell登陆环境的加载流程</h1><h2 id="登陆环境变量的加载流程"><a href="#登陆环境变量的加载流程" class="headerlink" title="登陆环境变量的加载流程"></a>登陆环境变量的加载流程</h2><p><img src="https://jiajuu.top/2021/02/21/ShellEnv/LoginProcess.PNG" alt="登陆环境变量的加载流程"></p>
<h2 id="非登录环境变量的加载流程"><a href="#非登录环境变量的加载流程" class="headerlink" title="非登录环境变量的加载流程"></a>非登录环境变量的加载流程</h2><p><img src="https://jiajuu.top/2021/02/21/ShellEnv/NonloginProcess.PNG" alt="非登录环境变量的加载流程"></p>
<h1 id="加载流程的测试、识别"><a href="#加载流程的测试、识别" class="headerlink" title="加载流程的测试、识别"></a>加载流程的测试、识别</h1><blockquote>
<p>脚本文件可以指定具体的Shell环境执行</p>
<p>Shell登陆环境会运行<code>/etc/profile</code></p>
<p>Shell非登陆环境会运行<code>/当前用户/.bashrc</code></p>
<p>我们只需要在上面两个文件添加两个测试变量</p>
<p>然后我们在两个不同的Shell脚本中读取测试变量</p>
</blockquote>
<h2 id="执行登陆环境执行脚本"><a href="#执行登陆环境执行脚本" class="headerlink" title="执行登陆环境执行脚本"></a>执行登陆环境执行脚本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh -l XX.sh #先加载Shell登陆环境初始化环境变量，在执行脚本文件</span><br></pre></td></tr></table></figure>
<h2 id="执行非登陆环境执行脚本"><a href="#执行非登陆环境执行脚本" class="headerlink" title="执行非登陆环境执行脚本"></a>执行非登陆环境执行脚本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash #加载Shell非登录环境</span><br><span class="line">sh XX.sh #直接执行脚本文件</span><br></pre></td></tr></table></figure>
<h2 id="识别Shell环境"><a href="#识别Shell环境" class="headerlink" title="识别Shell环境"></a>识别Shell环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $0</span><br><span class="line"><span class="meta">#</span><span class="bash">输出-bash为Shell登录模式</span></span><br><span class="line"><span class="meta">#</span><span class="bash">输出bash为Shell非登录模式</span></span><br></pre></td></tr></table></figure>
<h2 id="切换Shell环境"><a href="#切换Shell环境" class="headerlink" title="切换Shell环境"></a>切换Shell环境</h2><ol>
<li><p><strong>直接登陆系统，默认就是Shell登录模式</strong></p>
</li>
<li><p><strong>su切换用户登陆</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su username --login</span><br><span class="line">或者</span><br><span class="line">su username -l</span><br><span class="line"><span class="meta">#</span><span class="bash">切换到指定用户，加载Shell登陆环境变量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>bash切换Shell非登录模式</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash</span><br></pre></td></tr></table></figure></li>
<li><p><strong>以Shell登陆模式执行脚本</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh -l XX.sh 或者 sh --login XX.sh</span><br><span class="line">bash -l XX.sh 或者 bash --login XX.sh</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell-输入输出</title>
    <url>/2021/02/25/ShellInputOutput/</url>
    <content><![CDATA[<h1 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h1><blockquote>
<p>标准输入是从键盘读取用户输入数据</p>
<p>标准输出是从Shell程序产生，并呈现到显示器供用户查看</p>
</blockquote>
<table>
<thead>
<tr>
<th>文件名</th>
<th>类型</th>
<th>文件描述符fd</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>stdin</td>
<td>standard input标准输入文件</td>
<td>0</td>
<td>获取键盘的输入数据</td>
</tr>
<tr>
<td>stdout</td>
<td>standard output标准输出文件</td>
<td>1</td>
<td>将正确数据输出到显示器</td>
</tr>
<tr>
<td>stderr</td>
<td>standard error标准错误输出文件</td>
<td>2</td>
<td>将错误信息输出到显示器</td>
</tr>
</tbody></table>
<blockquote>
<p>每个Linux命令运行都会打开这三个文件</p>
<p>Shell程序默认会从stdin文件中读取输入数据</p>
<p>Shell程序默认会从stdout文件中输出正确数据</p>
<p>Shell程序默认会从stderr文件中输出错误信息</p>
</blockquote>
<h1 id="重定向输入输出"><a href="#重定向输入输出" class="headerlink" title="重定向输入输出"></a>重定向输入输出</h1><blockquote>
<p>Linux Shell重定向分为输入重定向、输出重定向</p>
<br>

<p>若改变数据流入的方向，数据从其他地方流入（而非从键盘流入），这就是输入重定向</p>
<p>若改变数据流出的方向，数据向其他地方流出（而非流向显示器），这就是输出重定向</p>
<br>

<p>一般我们会重定向到文件中，把命令结果保存起来供日后查阅</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>命令 &gt; file</code></td>
<td>将正确数据重定向输出到file文件中，覆盖方式</td>
</tr>
<tr>
<td><code>命令 &lt; file</code></td>
<td>将输入重定向从file文件中读取数据</td>
</tr>
<tr>
<td><code>命令 &gt;&gt; file</code></td>
<td>将正确数据重定向输出到file文件汇总，追加方式</td>
</tr>
<tr>
<td><code>命令 &lt; file1 &gt; file2</code></td>
<td>从file1文件读取数据，输出数据到file2文件中</td>
</tr>
<tr>
<td><code>命令 fd &gt; file</code></td>
<td>根据指定的文件描述符fd将数据重定向输出到file文件中，覆盖方式</td>
</tr>
<tr>
<td><code>命令 fd &gt;&gt; file</code></td>
<td>根据指定的文件描述符fd将数据重定向输出到file文件中，追加方式</td>
</tr>
<tr>
<td><code>命令 &gt; file fd1 &gt;&amp; fd2</code></td>
<td>将fd1和fd2文件描述符合并输出到文件</td>
</tr>
<tr>
<td><code>fd1 &lt;&amp; fd2</code></td>
<td>将fd1和fd2文件描述符合并从文件读取输入</td>
</tr>
<tr>
<td><code>&lt;&lt; tag</code></td>
<td>读取终端输入数据，将开始标记tag和结束标记tag之间的内容作为输入<br>标记名tag可以任意</td>
</tr>
</tbody></table>
<blockquote>
<p>输出重定向中，<code>&gt;</code>为覆盖输出，<code>&gt;&gt;</code>为追加输出</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;hello&quot; &gt; log.txt #覆盖方式输出到log.txt</span><br><span class="line"></span><br><span class="line">echo &quot;hello&quot; &gt;&gt; log.txt #追加方式输出到log.txt</span><br><span class="line"></span><br><span class="line">ll aaaa 2&gt;&gt; log.txt #输出错误信息到log.txt</span><br><span class="line"></span><br><span class="line">ll aaaa &gt;&gt; log.txt 2&gt;&amp;1 #错误信息、正确数据合并输出到log.txt</span><br><span class="line"></span><br><span class="line">wc -l &lt; log.txt #从log.txt读取数据</span><br><span class="line"></span><br><span class="line">while read str; do echo $str; done &lt; log.txt #逐行读取log.txt文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">读取终端输入数据</span></span><br><span class="line">wc -l &lt;&lt; E0F</span><br><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">cc</span><br><span class="line">dd</span><br><span class="line">E0F</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell-流程控制</title>
    <url>/2021/02/25/ShellProcessControl/</url>
    <content><![CDATA[<h1 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h1><h2 id="if语法"><a href="#if语法" class="headerlink" title="if语法"></a>if语法</h2><p>多行形式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if	条件</span><br><span class="line">then</span><br><span class="line">	命令</span><br><span class="line">else</span><br><span class="line">	命令</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>单行形式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if	条件; then 命令; fi</span><br></pre></td></tr></table></figure>
<h2 id="if-else语法"><a href="#if-else语法" class="headerlink" title="if-else语法"></a>if-else语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if	条件</span><br><span class="line">then</span><br><span class="line">	命令</span><br><span class="line">else</span><br><span class="line">	命令</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h2 id="if-elif-else语法"><a href="#if-elif-else语法" class="headerlink" title="if-elif-else语法"></a>if-elif-else语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if	条件1</span><br><span class="line">then</span><br><span class="line">	命令1</span><br><span class="line">elif 条件2</span><br><span class="line">then</span><br><span class="line">	命令2</span><br><span class="line">elif 条件3</span><br><span class="line">then</span><br><span class="line">	命令3</span><br><span class="line">...</span><br><span class="line">else</span><br><span class="line">	命令N</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h2 id="if条件判断句的退出状态"><a href="#if条件判断句的退出状态" class="headerlink" title="if条件判断句的退出状态"></a>if条件判断句的退出状态</h2><blockquote>
<p>linux任何命令的执行都有一个退出状态，无论是内置命令、外部文件命令还是自定义的Shell函数</p>
<p>当它退出即运行结束时，都会返回一个比较小的整数值给调用它的程序</p>
<p>这个就是命令的退出状态</p>
<p><br>大多数命令状态都是0代表成功，非0代表失败</p>
<p>我们常用<code>$?</code>获取上一个命令的命令状态</p>
<p><br>而我们的if语句就是根据逻辑运算符的退出状态码来确定走哪一条语句</p>
</blockquote>
<h1 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case $num in</span><br><span class="line">1)</span><br><span class="line">	echo &quot;one&quot;</span><br><span class="line">	;;</span><br><span class="line">2)</span><br><span class="line">	echo &quot;two&quot;</span><br><span class="line">	;;</span><br><span class="line">3)</span><br><span class="line">	echo &quot;three&quot;</span><br><span class="line">	;;</span><br><span class="line">*)</span><br><span class="line">	;;</span><br><span class="line"></span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<blockquote>
<p>仅支持简单正则表达式</p>
</blockquote>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>表示任意字符串</td>
</tr>
<tr>
<td><code>[abc]</code></td>
<td>表示a、b、c三个字符中任意一个。比如，[15ZH]表示1、5、Z、H四个字符中任意一个</td>
</tr>
<tr>
<td><code>m-n</code></td>
<td>表示从m到n的任意一个字符。比如，[0-9]表示任意一个数字，[0-9a-zA-Z]表示字母或数字</td>
</tr>
<tr>
<td>`</td>
<td>`</td>
</tr>
</tbody></table>
<h1 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h1><p>多行形式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while 条件</span><br><span class="line">do</span><br><span class="line">	命令1</span><br><span class="line">	命令2</span><br><span class="line">	...</span><br><span class="line">	continue; #结束当前一轮循环，进入下一轮循环</span><br><span class="line">	break; #结束当前循环</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>当行形式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while 条件; do 命令; done;</span><br></pre></td></tr></table></figure>
<h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">方式一</span></span><br><span class="line">while :</span><br><span class="line">do </span><br><span class="line">	command</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">方式二</span></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">	command</span><br><span class="line">done</span><br></pre></td></tr></table></figure>


<h1 id="until语句"><a href="#until语句" class="headerlink" title="until语句"></a>until语句</h1><blockquote>
<p>也是循环语句，但是和while的处理方式是相反的，条件为false的时候才会继续循环，true时会停止循环</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until 条件</span><br><span class="line">do</span><br><span class="line">	command1</span><br><span class="line">done</span><br></pre></td></tr></table></figure>


<h1 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h1><p>多行形式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">方式1</span></span><br><span class="line">for var in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">	echo &quot;This is number$&#123;var&#125;&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">方式2</span></span><br><span class="line">for var in &#123;1..5&#125;</span><br><span class="line">do</span><br><span class="line">	echo &quot;This is number$&#123;var&#125;&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">方式3</span></span><br><span class="line">for((i=1;i&lt;10;i++))</span><br><span class="line">do</span><br><span class="line">	echo &quot;This is number$&#123;i&#125;&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">死循环</span></span><br><span class="line">for((;;));do ehco &quot;无限循环大法&quot;;done;</span><br></pre></td></tr></table></figure>
<p>一行形式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for var in 1 2 3; do echo &quot;This is number$&#123;var&#125;&quot;; done;</span><br></pre></td></tr></table></figure>
<h1 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h1><blockquote>
<p><code>select in</code>循环能够进行菜单选择输入，可以增强交互性，它可以显示出带编号的菜单，用户输入不同的编号就能选择不同的菜单，并执行不同功能</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select name in &quot;jia&quot; &quot;juu&quot; &quot;jiajuu&quot;</span><br><span class="line">do</span><br><span class="line">	case $name in</span><br><span class="line">	&quot;jia&quot;)</span><br><span class="line">		echo $name</span><br><span class="line">		break</span><br><span class="line">		;;</span><br><span class="line">	&quot;juu&quot;)</span><br><span class="line">		echo $name</span><br><span class="line">		break</span><br><span class="line">		;;</span><br><span class="line">	&quot;jiajuu&quot;)</span><br><span class="line">		echo $name</span><br><span class="line">		break</span><br><span class="line">		;;</span><br><span class="line">	*)</span><br><span class="line">		echo &quot;你别乱输入=┗|｀O′|┛ 嗷~~&quot;</span><br><span class="line">	esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<p>select是死循环，输入空值或输入无效值都不会结束循环，只能通过<code>break</code>语句或者<code>Ctrl+D</code>来结束循环</p>
<p>执行过程中，终端会输出<code>$?</code>来显示输入选择的菜单编号</p>
</blockquote>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell-常用外部命令</title>
    <url>/2021/02/25/ShellTool/</url>
    <content><![CDATA[<h1 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h1><blockquote>
<p>用来对文本进行统计.包括单词个数、行数、字节数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wc [options] [文件名]</span><br></pre></td></tr></table></figure>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><table>
<thead>
<tr>
<th>options</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-c</code></td>
<td>character,统计字节数</td>
</tr>
<tr>
<td><code>-w</code></td>
<td>word,统计单词数</td>
</tr>
<tr>
<td><code>-l</code></td>
<td>line,统计行数</td>
</tr>
</tbody></table>
<h1 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a>cut命令</h1><blockquote>
<p>可以切割提取指定列、字符、字节的数据</p>
<p>可以逐行读入文本,然后按列划分字段并进行提取输出操作</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cut [options] filename</span><br></pre></td></tr></table></figure>
<h2 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h2><table>
<thead>
<tr>
<th>options</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>-f 提取范围</code></td>
<td>列号,获取第几列</td>
</tr>
<tr>
<td><code>-d 自定义分隔符</code></td>
<td>自定义分隔符,默认为制表符</td>
</tr>
<tr>
<td><code>-c 提取范围</code></td>
<td>以字符为单位进行分割</td>
</tr>
<tr>
<td><code>-b 提取范围</code></td>
<td>以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了-n标志</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>与“-b”选项连用，不分割多字节字符</td>
</tr>
</tbody></table>
<h2 id="提取范围说明"><a href="#提取范围说明" class="headerlink" title="提取范围说明"></a>提取范围说明</h2><table>
<thead>
<tr>
<th>提取范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>n-</td>
<td>提取指定第n列或字符或字节后面所有数据</td>
</tr>
<tr>
<td>n-m</td>
<td>提取指定第n列或字符或字节到第m列或字符或字节中间所有数据</td>
</tr>
<tr>
<td>-m</td>
<td>提取指定第m列或字符或字节前面所有数据</td>
</tr>
<tr>
<td>n1,n2,…</td>
<td>提取指定枚举列的所有数据</td>
</tr>
</tbody></table>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>text.txt</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">AA  jia  11  aa</span><br><span class="line">BB  juu  22  bb</span><br><span class="line">CC  jiajuu  33  cc</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut text.txt -d &quot; &quot; -f l,3 #按空格键分割text.txt文件，提取第一列和第三列</span><br><span class="line"></span><br><span class="line">cut text.txt -c 1-2 #提取第一个到第二个字符</span><br><span class="line"></span><br><span class="line">ehco &quot;jiajuu&quot; | cut -b 1-3 #提取第一个到第三个字节</span><br><span class="line"></span><br><span class="line">ehco &quot;jiajuu&quot; | cut -nb 1-3 #提取第一个到第三个字节，多字节不被截断</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">切割提取指定单词数据</span></span><br><span class="line">cat text.txt | grep jiajuu | cut -d &quot; &quot; -f 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">切割提取bash进程的PID号</span></span><br><span class="line">ps -aux | grep bash | head -n 1 | cut -d &quot; &quot; -f 8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">切割提取IP地址</span></span><br><span class="line">ifconfig | grep broadcast | cut -d &quot; &quot; -f 10</span><br></pre></td></tr></table></figure>


<h1 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h1><blockquote>
<p>sed（stream editor，流编辑器）是Linux的一款非交互流式文本编辑器(vim是交互式文本编辑器)</p>
<p>可以对文本文件的每一行数据匹配查询之后进行增、删、查、改等操作，支持按正则匹配文本内容</p>
</blockquote>
<p><img src="https://jiajuu.top/2021/02/25/ShellTool/SedProcess.PNG" alt="sed的处理流程"></p>
<blockquote>
<p>sed一次读取一行内存，会把这行放入缓存(模式空间)中</p>
<p>然后才对该行进行处理，处理完后将缓存区内容发送到终端</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed [选项参数] [模式匹配&#x2F;sed程序命令] [文件名]</span><br><span class="line"></span><br><span class="line">#模式匹配，sed会读取每一行数据到模式空间中，接着判断当前行是否符合模式匹配要求，符合要求就会执行sed程序命令，否则不执行</span><br><span class="line">#如果模式匹配为空，则每一行都会执行sed程序命令</span><br></pre></td></tr></table></figure>
<h2 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h2><table>
<thead>
<tr>
<th>options</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>-e</code></td>
<td>直接在指令列模式上进行sed动作编辑。它告诉sed将下一个参数解释为一个sed指令<br>只有当命令行上给出多个sed指令才需要使用该选项,一行命令语句可执行多条sed命令</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>直接对内容进行修改，不加<code>-i</code>默认预览，不对文件做实际修改</td>
</tr>
<tr>
<td><code>-f</code></td>
<td>选项后面跟保存sed指令的文件</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>取消默认输出，sed默认会输出所有文本内容，使用该选项后只显示处理过的行</td>
</tr>
<tr>
<td><code>-r ruguler</code></td>
<td>使用扩展正则表达式，默认只识别基本正则表达式</td>
</tr>
</tbody></table>
<h2 id="sed程序命令说明"><a href="#sed程序命令说明" class="headerlink" title="sed程序命令说明"></a>sed程序命令说明</h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>add新增，<code>a</code>后面接字符串，在下一行显示</td>
</tr>
<tr>
<td>c</td>
<td>change更改，更改匹配行的内容</td>
</tr>
<tr>
<td>d</td>
<td>delete删除，删除匹配内容</td>
</tr>
<tr>
<td>i</td>
<td>insert插入，向匹配行前插入内容</td>
</tr>
<tr>
<td>p</td>
<td>print打印，打印出匹配的内容，通常与<code>-n</code>选项一起使用</td>
</tr>
<tr>
<td>s</td>
<td>substitute替换，替换掉匹配的内容</td>
</tr>
<tr>
<td>=</td>
<td>用来打印被匹配行的行号</td>
</tr>
<tr>
<td>n</td>
<td>读取下一行，遇到n会自动跳入下一行</td>
</tr>
</tbody></table>
<h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>!</code></td>
<td>取反，放在限制条件后面，对指定行以外所有行应用</td>
</tr>
<tr>
<td><code>&#123;sed命令1;sed命令2&#125;</code></td>
<td>多个命令操作同一行</td>
</tr>
<tr>
<td><code>$</code></td>
<td>最后一行</td>
</tr>
</tbody></table>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>text.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ABC</span><br><span class="line">jiajuu jiajuu</span><br><span class="line">jia</span><br><span class="line">123</span><br><span class="line">juu</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">添加文件中数据</span></span><br><span class="line">sed &#x27;3ahello&#x27; text.txt #在第三行后面添加一行，实际上没有修改文件，只是预览</span><br><span class="line">sed -i &#x27;3ahello&#x27; text.txt #在第三行后面添加一行，修改文件</span><br><span class="line">sed &#x27;3ihello&#x27; text.txt #在第三行前面添加一行，实际上没有修改文件，只是预览</span><br><span class="line"></span><br><span class="line">sed &#x27;/jiajuu/ihello&#x27; text.txt #在jiajuu指定字符串前添加一行</span><br><span class="line">sed &#x27;/jiajuu/ahello&#x27; text.txt #在jiajuu指定字符串后添加一行</span><br><span class="line"></span><br><span class="line">sed &#x27;$ahello&#x27; text.txt #在最后一行后面添加一行</span><br><span class="line">sed &#x27;$ihello&#x27; text.txt #在最后一行前面添加一行</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除文件中数据</span></span><br><span class="line">sed &#x27;2d&#x27; text.txt #删除第二行</span><br><span class="line">sed &#x27;1~2d&#x27; text.txt #删除奇数行，1代表第一行，2代表每隔两行</span><br><span class="line">sed &#x27;1,3d&#x27; text.txt #删除第一行到第三行</span><br><span class="line">sed &#x27;1,3!d&#x27; text.txt #删除第一行到第三行外全部行</span><br><span class="line">sed &#x27;$d&#x27; text.txt #删除最后一行</span><br><span class="line">sed &#x27;/jiajuu/d&#x27; text.txt #删除含有jiajuu的行</span><br><span class="line">sed &#x27;/jiajuu/,$d&#x27; text.txt #删除含jiajuu行到最后一行</span><br><span class="line">sed &#x27;/jiajuu/,+1d&#x27; text.txt #删除含jiajuu行和下一行</span><br><span class="line">sed &#x27;/jia\|juu/!d&#x27; text.txt #删除含有jia和juu行以外所有行</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">更改文件中数据</span></span><br><span class="line">sed &#x27;1chello&#x27; text.txt #修改第一行为hello</span><br><span class="line">sed &#x27;/jiajuu/chello&#x27; text.txt #修改含jiajuu行为hello</span><br><span class="line">sed &#x27;$chello&#x27; text.txt #修改最后一行为hello</span><br><span class="line">sed &#x27;s/jiajuu/hello/&#x27; text.txt #将每行的第一个jiajuu替换为hello</span><br><span class="line">sed &#x27;s/jiajuu/hello/g&#x27; text.txt #将每行的所有jiajuu替换为hello</span><br><span class="line">sed &#x27;s/jiajuu/hello/2&#x27; text.txt #将每行的第二个jiajuu替换为hello</span><br><span class="line">sed &#x27;s/jiajuu/hello/2w temp.txt&#x27; text.txt #将替换的内容行写入文件</span><br><span class="line">sed -n &#x27;s/jiajuu/hello/2p&#x27; text.txt #显示替换的内容，n是获取匹配的，p是打印</span><br><span class="line">sed &#x27;/i/s/a.*//&#x27; text.txt #正则表达式匹配替换，匹配有i的行，替换匹配行中a后面所有内容为空</span><br><span class="line">sed &#x27;s/$/&amp; test/&#x27; text.txt #每行的末尾拼接test，&amp;为拼接</span><br><span class="line">sed &#x27;s/^/&amp;#/&#x27; text.txt #每行的行首添加#，&amp;为拼接</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查询文件中数据</span></span><br><span class="line">sed -n &#x27;/jiajuu/p&#x27; #查询含有jiajuu的行</span><br><span class="line">ps -aux | sed -n &#x27;/sshd/p&#x27; #管道查询所有进程中含有sshd的进程信息命令</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">多个sed命令执行</span></span><br><span class="line">sed -e &#x27;1d&#x27; -e &#x27;s/jiajuu/hello/g&#x27; text.txt #方式一，将text.txt文件中的第一行删除并将jiajuu替换为hello</span><br><span class="line">sed &#x27;1d;s/jiajuu/hello/g&#x27; text.txt #方式2，将text.txt文件中的第一行删除并将jiajuu替换为hello</span><br></pre></td></tr></table></figure>
<h2 id="高级用法：缓存区数据交换"><a href="#高级用法：缓存区数据交换" class="headerlink" title="高级用法：缓存区数据交换"></a>高级用法：缓存区数据交换</h2><blockquote>
<p>模式空间与暂存空间：</p>
<ul>
<li><p>sed处理文件是逐行处理的，即读取一行处理一行，输出一行</p>
</li>
<li><p>ssd把文件读出来的每一行存放的空间为模式空间，会在该空间中对读取的内容做相应的处理</p>
</li>
<li><p>sed还有一个额外的空间为暂存空间，暂存空间刚才是只有一个空行</p>
</li>
<li><p>sed可使用相应的命令从模式空间往暂存空间放入内容，或者从暂存空间内容放入模式空间</p>
<blockquote>
<p>模式空间与暂存空间的目的时为了更好的处理数据，实现复制、粘贴。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="缓存区命令"><a href="#缓存区命令" class="headerlink" title="缓存区命令"></a>缓存区命令</h3><table>
<thead>
<tr>
<th>command</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>h</code></td>
<td>将<code>模式空间</code>里面的内容复制到<code>暂存空间</code>缓存区(覆盖方式)</td>
</tr>
<tr>
<td><code>H</code></td>
<td>将<code>模式空间</code>里面的内容复制到<code>暂存空间</code>缓存区(追加方式)</td>
</tr>
<tr>
<td><code>g</code></td>
<td>将<code>暂存空间</code>里面的内容复制到<code>模式空间</code>缓存区(覆盖方式)</td>
</tr>
<tr>
<td><code>G</code></td>
<td>将<code>暂存空间</code>里面的内容复制到<code>模式空间</code>缓存区(追加方式)</td>
</tr>
<tr>
<td><code>x</code></td>
<td>交换2个空间的内容</td>
</tr>
</tbody></table>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">缓存空间数据交换</span></span><br><span class="line"><span class="meta">#</span><span class="bash">将模式空间第一行复制到暂存空间(覆盖方式)，并将暂存空间的内容复制进模式空间中的最后一行(追加方式)</span></span><br><span class="line">sed &#x27;1h;$G&#x27; text.txt #将第一行复制到最后一行</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将模式空间第一行复制到暂存空间(覆盖方式)并删除，最后将暂存空间的内容复制到模式空间中的最后一行(追加方式)</span></span><br><span class="line">sed &#x27;1&#123;h;d&#125;;$G&#x27; text.txt #第一行删除后粘贴到最后一行</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将模式空间第一行复制到暂存空间(覆盖模式)，最后将暂存空间的内容复制到模式空间中替换从第二行带式到最后一行的每一行数据</span></span><br><span class="line">sed &#x27;1h;2,$g&#x27; text.txt #将第一行复制粘贴替换第二行到最后一行</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将前三行数据复制到暂存空间(追加方式)，之后将暂存空间的所有内容复制到模式空间复制粘贴到模式空间最后一行(追加方式)</span></span><br><span class="line">sed &#x27;1,3H;$G&#x27; text.txt #将前三行数据复制粘贴到最后一行</span><br><span class="line"></span><br><span class="line">sed &#x27;G&#x27; text.txt #给每一行添加空行</span><br><span class="line"></span><br><span class="line">sed &#x27;/^$/d&#x27; text.txt #删除空行，^开始，$结尾</span><br></pre></td></tr></table></figure>


<h1 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h1><blockquote>
<p><code>awk</code>能够分析文本</p>
<p>相对于<code>grep</code>的查找，<code>sed</code>的编辑，<code>awk</code>在对数据分析并生成报告尤为强大简单</p>
<p><code>awk</code>就是把文件逐行读取，以空格为默认分隔符为每行切片，切开部分再进行分析处理</p>
<p>且<code>awk</code>能够定义变量，使用运算符，使用流程控制语句</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk [options] &#x27;pattern&#123;action&#125;&#x27; &#123;filename&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>pattern：表示<code>awk</code>再数据中查找的内容，也就是匹配模式</p>
<p>action：再找到匹配内容时所执行的命令</p>
</blockquote>
<h2 id="参数说明-3"><a href="#参数说明-3" class="headerlink" title="参数说明"></a>参数说明</h2><table>
<thead>
<tr>
<th>options</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>-F</code></td>
<td>指定输入文件拆分分隔符</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>赋值一个用户定义变量</td>
</tr>
</tbody></table>
<h2 id="内置变量说明"><a href="#内置变量说明" class="headerlink" title="内置变量说明"></a>内置变量说明</h2><table>
<thead>
<tr>
<th>内置变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>ARGC</code></td>
<td>命令行参数个数</td>
</tr>
<tr>
<td><code>ARGV</code></td>
<td>命令行参数排列</td>
</tr>
<tr>
<td><code>ENVIRON</code></td>
<td>支持队列中系统环境变量的使用</td>
</tr>
<tr>
<td><code>FILENAME</code></td>
<td>awk浏览的文件名</td>
</tr>
<tr>
<td><code>FNR</code></td>
<td>浏览文件的记录数</td>
</tr>
<tr>
<td><code>FS</code></td>
<td>设置输入域分隔符，等价于命令行 -F选项</td>
</tr>
<tr>
<td><code>NF</code></td>
<td>浏览记录域的个数，根据分隔符分割后的列数</td>
</tr>
<tr>
<td><code>NR</code></td>
<td>已读的记录数，也就是行号</td>
</tr>
<tr>
<td><code>OFS</code></td>
<td>输出域分隔符</td>
</tr>
<tr>
<td><code>ORS</code></td>
<td>输出记录分隔符</td>
</tr>
<tr>
<td><code>RS</code></td>
<td>控制记录分隔符</td>
</tr>
<tr>
<td><code>$n</code></td>
<td><code>$0</code>变量是指整条记录。<code>$1</code>表示当前行的第一个域…</td>
</tr>
<tr>
<td><code>$NF</code></td>
<td><code>$NF</code>是number finally，表示最后一列的信息，注意：变量NF是统计每行列的总数</td>
</tr>
</tbody></table>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;abc 123 456&quot; | awk &#x27;&#123;print $1&quot;&amp;&quot;$2&quot;&amp;&quot;$3&#125;&#x27; #用&quot;&amp;&quot;分割字符串</span><br><span class="line"></span><br><span class="line">awk &#x27;/root/&#123;print $0&#125;&#x27; passwd #打印含有&#x27;/root&#x27;的行</span><br><span class="line"></span><br><span class="line">awk -F &quot;:&quot; &#x27;/root/&#123;print $7&#125;&#x27; passwd #以&quot;:&quot;拆分匹配行，打印匹配行中第七列</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">打印文件每行属性信息</span></span><br><span class="line">awk -F &quot;:&quot; &#x27;&#123;print &quot;文件名：&quot;FILENAME&quot;,行号：&quot;NR&quot;，列数：&quot;NF&quot;，内容：&quot;$0&#125;&#x27; passwd </span><br><span class="line">awk -F &quot;:&quot; &#x27;&#123;printf(&quot;文件名：%s,行号：%s,列数：%s,内容：%s&quot;，FILENAME,NR,NF,$0)&#125;&#x27; passwd</span><br><span class="line"></span><br><span class="line">awk -F &quot;:&quot; &#x27;NR==2&#123;printf(&quot;filename:%s,内容:%s\n&quot;,FILENAME,$0)&#125;&#x27; passwd #打印第二行信息</span><br><span class="line"></span><br><span class="line">ls -a | awk &#x27;/^c/&#x27; #查找以c开头的文件</span><br><span class="line"></span><br><span class="line">awk -F &quot;:&quot; &#x27;&#123;print $1&#125;&#x27; passwd #打印第一列</span><br><span class="line">awk -F &quot;:&quot; &#x27;&#123;print $NF&#125;&#x27; passwd #打印最后一列</span><br><span class="line">awk -F &quot;:&quot; &#x27;&#123;print $(NF-1)&#125;&#x27; passwd #打印最后第二列</span><br><span class="line">awk -F &quot;:&quot; &#x27;&#123;if(NR&gt;=10 &amp;&amp; NR&lt;=20)&#123;print $1&#125;&#125;&#x27; passwd #打印10到20行的第一列</span><br><span class="line"></span><br><span class="line">echo &quot;one:two/three&quot; | awk -F &quot;[:/]&quot; &#x27;&#123;print $1&quot; &quot;$2&quot; &quot;$3&#125;&#x27; #多分隔符分割</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">添加开始与结束内容</span></span><br><span class="line">echo -e &quot;abc\nabc&quot; | awk &#x27;BEGIN&#123;print &quot;开始...&quot;&#125;&#123;print $0&#125;END&#123;print &quot;结束...&quot;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">echo &quot;abc  jiajuu jia juu&quot; | awk &#x27;&#123;print $1&quot; &quot;$2&quot; &quot;$3&#125;&#x27; #拼接分割的字符串</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">使用循环拼接分割的字符串</span></span><br><span class="line">echo &quot;abc  jiajuu jia juu&quot; | awk -v str=&quot;&quot; &#x27;&#123;for(n=1;n&lt;=NF;i++)&#123;str=str$n&#125;&#125; END&#123;print str&#125;&#x27;</span><br><span class="line"></span><br><span class="line">echo &quot;2.1&quot; | awk -v i=1 &#x27;&#123;print $0+i&#125;&#x27; #操作指定数字运算</span><br><span class="line"></span><br><span class="line">ifconfig | awk &#x27;/broadcast/&#123;print $0&#125;&#x27; | awk &#x27;&#123;print $2&#125;&#x27; #切割打印ip地址</span><br><span class="line"></span><br><span class="line">sed &#x27;G&#x27; text.txt | awk &#x27;/^$/&#123;print NR&#125;&#x27; #显示空行行号</span><br></pre></td></tr></table></figure>


<h1 id="sort命令"><a href="#sort命令" class="headerlink" title="sort命令"></a>sort命令</h1><blockquote>
<p>能对文件进行排序，并将结果标准输出或重定向输出到指定文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort (options) 文件列表</span><br></pre></td></tr></table></figure>
<h2 id="参数说明-4"><a href="#参数说明-4" class="headerlink" title="参数说明"></a>参数说明</h2><table>
<thead>
<tr>
<th>options</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-n</code></td>
<td>number，依照数值大小排序</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>reverse，以相反顺序排序</td>
</tr>
<tr>
<td><code>-t 分隔字符</code></td>
<td>设置排序是所用的分隔字符，默认空格</td>
</tr>
<tr>
<td><code>-k</code></td>
<td>指定需要排序的列</td>
</tr>
<tr>
<td><code>-d</code></td>
<td>排序时，处理英文字母、数字及空格字符外，忽略其他字符</td>
</tr>
<tr>
<td><code>-f</code></td>
<td>排序时，将小写字母视为大写字母</td>
</tr>
<tr>
<td><code>-b</code></td>
<td>忽略每行前面开始的空格字符</td>
</tr>
<tr>
<td><code>-o 输出文件</code></td>
<td>将排序后的结果存入指定的文件</td>
</tr>
<tr>
<td><code>-u</code></td>
<td>unique，输出的结果是去重的</td>
</tr>
<tr>
<td><code>-m</code></td>
<td>将几个排序号的文件合并</td>
</tr>
</tbody></table>
<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><p>text.txt</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">A 张三 30</span><br><span class="line">A 李四 55</span><br><span class="line">C jiajuu 100</span><br><span class="line">C jia 95</span><br><span class="line">B juu 98</span><br><span class="line">B jia 90</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sort -t &quot; &quot; -k3n,3 text.txt #按第三列升序排序</span><br><span class="line"></span><br><span class="line">sort -t &quot; &quot; -k3nr,3 text.txt #按第三列降序排序</span><br><span class="line"></span><br><span class="line">sort -t &quot; &quot; -k3n,3 -uk2,3 text.txt #按第二列以及第三列去重</span><br><span class="line"></span><br><span class="line">sort -t &quot; &quot; -k3n,3 -uk2,3 -o temp.txt text.txt #将输出结果保存到temp.txt中</span><br><span class="line"></span><br><span class="line">sort -t &quot;,&quot; -k1,1 -k3nr,3 text.txt #多列排序，以&quot;，&quot;分割先对第一列字符串升序排序，再对第三列数字降序排序</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell-变量</title>
    <url>/2021/02/20/ShellVariable/</url>
    <content><![CDATA[<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><blockquote>
<p>顾名思义，系统环境变量就是系统提供的共享变量，针对于所有Shell程序</p>
<p>存在于shell的配置文件中，linux系统启动时就会加载。</p>
</blockquote>
<ul>
<li><p><strong>系统级环境变量</strong></p>
<p>Shell环境加载全局配置文件中的变量，针对所有用户所有Shell程序，全局共享</p>
<p><strong>全局配置文件：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/profile</span><br><span class="line">/etc/profile.d/*.sh</span><br><span class="line">/etc/bashrc</span><br></pre></td></tr></table></figure></li>
<li><p><strong>用户界环境变量</strong></p>
<p>Shell环境加载个人配置文件中的变量，针对当前用户所有Shell程序，登陆用户独享</p>
<p> <strong>个人配置文件：</strong></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/用户目录/.bash_profile</span><br><span class="line">/home/用户目录/.bashrc</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><code>env</code>查询当前Shell系统环境变量</p>
<p><code>set</code>查询当前Shell所有变量，包括系统环境变量、自定义变量、函数</p>
<p><strong>常用的环境变量：</strong></p>
<table>
<thead>
<tr>
<th>变量名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>PATH</strong></td>
<td><strong>和windows环境变量PATH功能相似，设置命令的搜索路径，’:’为分割</strong></td>
</tr>
<tr>
<td>HOME</td>
<td>当前用户主目录<code>/root</code></td>
</tr>
<tr>
<td>SHELL</td>
<td>当前shell解释器类型<code>/bin/bash</code></td>
</tr>
<tr>
<td><strong>HISTFILE</strong></td>
<td><strong>显示当前用户执行命令的历史列表文件<code>/root/.bash_history</code></strong></td>
</tr>
<tr>
<td>PWD</td>
<td>显示当前所在路径</td>
</tr>
<tr>
<td>OLDPWD</td>
<td>显示之前的路径</td>
</tr>
<tr>
<td>HOSTNAME</td>
<td>显示当前主机名</td>
</tr>
<tr>
<td>HOSTTYPE</td>
<td>显示主机的架构</td>
</tr>
<tr>
<td><strong>LANG</strong></td>
<td><strong>显示当前系统语言环境<code>zh_CN.UTF-8</code></strong></td>
</tr>
</tbody></table>
<h2 id="自定义系统环境变量"><a href="#自定义系统环境变量" class="headerlink" title="自定义系统环境变量"></a>自定义系统环境变量</h2><blockquote>
<p>用户进入Shell环境初始化时，会加载全局配置文件<code>/etc/profile</code>里面的环境变量</p>
<p>所以我们可以把所有Shell程序或命令使用的变量全部在<code>/etc/profile</code>文件里面自定义</p>
</blockquote>
<ol>
<li><p>编辑<code>/etc/profile</code>全局配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/jdk1.8.0_162</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export  JAVA_HOME CLASSPATH PATH</span><br></pre></td></tr></table></figure></li>
<li><p>手动重载全局配置文件，不然不会立即生效的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile </span><br></pre></td></tr></table></figure>




</li>
</ol>
<h1 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h1><ul>
<li><p><strong>自定义局部变量</strong></p>
<p>只能在一个脚本文件中使用的变量</p>
<p><code>value_name=value</code>定义变量</p>
<p><code>unset value_name</code>删除变量</p>
<p><code>$value_name</code>查询变量的值</p>
<p><code>$&#123;value_name&#125;</code>也是查询变量名的值，能够防止歧异</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo Hello $&#123;value_name&#125;!!!#把！！！分隔开来</span><br></pre></td></tr></table></figure>
<p><strong>P.S.</strong></p>
<ul>
<li><p>不能以数字开头</p>
</li>
<li><p>等号两侧不要有空格</p>
</li>
<li><p>bash环境下，变量默认类型时字符串类型，无法进行数值运算</p>
</li>
<li><p>变量的值有空格需要用””括起来</p>
</li>
<li><p>不能使用Shell关键字作为变量名称</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>自定义常量</strong></p>
<p>定义以后无法再修改，也叫只读变量</p>
<p><code>readonly varlue_name</code>定义常量</p>
</li>
</ul>
<ul>
<li><p><strong>自定义全局变量</strong></p>
<blockquote>
<p>举个栗子：现在有两个Shell脚本文件A和B</p>
<p>如果我们在A文件中执行B文件，那么这个时候A就是父Shell环境，B为子Shell环境</p>
<p>那么，子Shell就无法使用父Shell的变量了</p>
<p>这个时候，全局变量就隆重登场了！</p>
</blockquote>
<p><code>export value_name1 value_name2</code>声明全局变量</p>
</li>
</ul>
<h2 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h2><ul>
<li><p><strong>字符串变量的定义</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">str1=&#x27;abc&#x27; #强引用，不会解析&#x27;&#x27;内的变量，原样输出</span><br><span class="line">str2=&quot;abc&quot; #弱引用，能够解析&quot;&quot;内的变量，强烈推荐</span><br><span class="line">str3=abc #也能够解析变量，但是不能有空格，不然会被解析为其他命令</span><br></pre></td></tr></table></figure></li>
<li><p><strong>获取字符串长度</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#str&#125;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>字符串拼接</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">str1=jiajuu</span><br><span class="line">str2=&quot;Hello World&quot;</span><br><span class="line">str3=$&#123;str1&#125;$&#123;str2&#125; #无符号拼接</span><br><span class="line">str4=&quot;$&#123;str1&#125;$&#123;str2&#125;&quot; #双引号拼接，强烈推荐</span><br><span class="line">str5=$&#123;str1&#125;&quot;,&quot;$&#123;str2&#125; #混合拼接</span><br></pre></td></tr></table></figure></li>
<li><p><strong>字符串截取</strong></p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>${str:start:length}</strong></td>
<td><strong>从左侧第0个开始，向右截取2个字符<code>$&#123;str:0:2&#125;</code></strong></td>
</tr>
<tr>
<td><strong>${str:start}</strong></td>
<td><strong>从左侧第11个开始，向右截取所有字符<code>$&#123;str:11&#125;</code></strong></td>
</tr>
<tr>
<td>${str:0-start:length}</td>
<td>从右侧第5个开始，向右侧截取2个字符<code>$&#123;str:0-5:2&#125;</code></td>
</tr>
<tr>
<td>${str:0-start}</td>
<td>从右侧第3个开始，向右截取所有字符<code>$&#123;str:0-3&#125;</code></td>
</tr>
<tr>
<td>${str#*chars}</td>
<td>截取从左往右第一个e右边的所有字符<code>$&#123;str#*e&#125;</code></td>
</tr>
<tr>
<td>${str##*chars}</td>
<td>截取从左往右最后一个e右边的所有字符<code>$&#123;str#*e&#125;</code></td>
</tr>
<tr>
<td>${str%chars*}</td>
<td>截取从右往左第一个e左边的所有字符<code>$&#123;str%e*&#125;</code></td>
</tr>
<tr>
<td>${str%%chars*}</td>
<td>截取从右往左最后一个e左边的所有字符<code>$&#123;str%e*&#125;</code></td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="索引数组"><a href="#索引数组" class="headerlink" title="索引数组"></a>索引数组</h2><blockquote>
<p>Bash Shell中仅支持一维数组，不支持多维数组</p>
</blockquote>
<ul>
<li><p><strong>数组的定义</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">方式1,例如nums=(5 2 0 13 14 <span class="string">&quot;jiajuu&quot;</span>)</span></span><br><span class="line">array_name1=(item1 item2 ...)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">方式2，例如str=([1]=<span class="string">&quot;jiajuu&quot;</span> [3]=<span class="string">&quot;666&quot;</span> [5]=<span class="string">&quot;wuhu&quot;</span>),长度仍为3</span></span><br><span class="line">array_name2=([index1]=item2 [index2]=item2 ...) </span><br></pre></td></tr></table></figure></li>
<li><p><strong>数组的获取</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">获取数组其中一个元素</span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;arr[index]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">获取数组所有元素</span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;arr[@]&#125;</span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;arr[*]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">获取数组的长度或个数</span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#arr[@]&#125;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#arr[*]&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">获取数组指定元素的字符长度</span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#arr[index]&#125;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>数组的拼接</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array_new=($arr1[@] $arr2[@] ...)</span><br><span class="line">array_new=($arr1[*] $arr2[*] ...)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>数组的删除</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">删除数组指定元素</span></span><br><span class="line">unset array_name[index]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除整个数组</span></span><br><span class="line">unset array_name</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="特殊符号变量"><a href="#特殊符号变量" class="headerlink" title="特殊符号变量"></a>特殊符号变量</h1><p><code>$n</code>表示执行脚本文件时传入的参数</p>
<blockquote>
<p><code>$0</code>获取当前脚本的文件名</p>
<p><code>$1~$9</code>获取第1个~第9个传入的参数</p>
<p><code>$&#123;num&#125;</code>第十个以上的参数</p>
</blockquote>
<p><code>$*</code> <code>$@</code>获取执行脚本文件传入的所有参数</p>
<p><strong>区别：</strong></p>
<ul>
<li><p>不使用””括起来的功能时相同的</p>
</li>
<li><p>但是使用””括起来以后</p>
<p><code>$*</code>获取所有参数拼接为一个字符串,<code>&quot;$1 $2 $3 $4 $5 $6 $7 $8&quot;</code></p>
<p><code>$@</code>获取一组参数列表对象，<code> &quot;$1&quot; &quot;$2&quot;&quot;$3&quot; &quot;$4&quot; &quot;$5&quot; &quot;$6&quot; &quot;$7&quot; &quot;$8&quot;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">直接输出所有参数</span></span><br><span class="line">echo &#x27;使用$*直接输出&#x27;$*</span><br><span class="line">echo &#x27;使用$@直接输出&#x27;$@</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">循环遍历输出所有传入参数</span></span><br><span class="line">echo &#x27;循环遍历输出$*所有参数&#x27;</span><br><span class="line">for item in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">	echo $item</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &#x27;循环遍历输出$@所有参数&#x27;</span><br><span class="line">for item in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">	echo $item</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p><code>$#</code>获取所有传入参数的个数</p>
</li>
</ul>
<p><code>$?</code>获取上一个Shell命令的退出状态码，或者时函数的返回值</p>
<blockquote>
<p>每一个Shell命令的执行都有返回值，用于说明命令是否执行成功</p>
<p>通常来说，0表示成功，非0表示失败</p>
</blockquote>
<p><code>$$</code>获取当前Shell环境的进程ID号</p>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>白嫖Vercel加速GitHub Pages</title>
    <url>/2021/01/24/VercelAccleration/</url>
    <content><![CDATA[<blockquote>
<p>搭建完Github Pages后，还是忍受不了github pages的速度，实在太太太太慢了啦！┭┮﹏┭┮…</p>
<p>作为一名优秀的面向搜索引擎编程的程序猿，直接baidu走起~~</p>
<p>发现很多云服务器都有CDN加速的服务，但是腾讯CDN加速只有120G赠送，然后以后便要收费了，便打消了这想法…</p>
<p>最后还是被我发现了一个好宝贝(●’◡’●)，就是利用Vercel拉取github上的代码来实现加速。</p>
</blockquote>
<p>P.S.    利用Vercel实现github pages加速实现的步骤大致就是导入github仓库，然后把域名的解析指向Vercel要求的IP地址即可，全程傻瓜式操作。</p>
<h3 id="在Vercel中导入github仓库"><a href="#在Vercel中导入github仓库" class="headerlink" title="在Vercel中导入github仓库"></a>在Vercel中导入github仓库</h3><ul>
<li>进入Vercel官网：<a href="https://vercel.com/">https://vercel.com</a></li>
<li><code>右上角sign in</code>     -&gt;    <code>continue with github</code></li>
<li>登录以后就需要你<code>Import Git Repository</code>了</li>
<li>选择<code>+ Add github Org or Account</code>后会跳转至<code>github官网</code>授权</li>
<li>然后import你的github pages项目即可</li>
</ul>
<h3 id="域名解析指向Vercel的IP地址"><a href="#域名解析指向Vercel的IP地址" class="headerlink" title="域名解析指向Vercel的IP地址"></a>域名解析指向Vercel的IP地址</h3><ul>
<li>选项卡选择<code>Setting</code>    -&gt;    <code>Domains</code></li>
<li>填写你的域名后，点击<code>Add</code></li>
<li>正常来说会报错，提示你的域名指向错误，需要你去域名解析网站那里重新指向</li>
<li>在域名解析管理添加记录：<code>主机记录：@     记录类型：A     记录值：76.76.21.21</code></li>
<li>回到Vercel,<code>refresh</code>一哈就大功告成了O(∩_∩)O。</li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1047.删除字符串中的所有相邻重复项 2021.03.09</title>
    <url>/2021/03/09/leetcode1047-20210309/</url>
    <content><![CDATA[<h1 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047.删除字符串中的所有相邻重复项"></a>1047.删除字符串中的所有相邻重复项</h1><blockquote>
<ul>
<li>难度：简单</li>
</ul>
<br>

<p>给出由小写字母组成的字符串 <code>S</code>，<b>重复项删除操作</b>会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 <code>S</code> 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
</blockquote>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><blockquote>
<p>  <b>输入：</b>“abbaca”<br>  <b>输出：</b>“ca”<br>  <b>解释：</b><br>   例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>栈<ol>
<li>当栈为空时，我们将当前字符压入</li>
<li>当栈不为空，且栈顶与当前字符相同，我们把栈顶元素弹出</li>
<li>当栈顶和当前字符不相同，我们把当前字符压入</li>
<li>最后我们把栈中元素组成字符串（注意是从后往前排嗷）</li>
</ol>
</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;S.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty() &amp;&amp; s.top() == S[i])&#123;</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(S[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(s.size(),<span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        res[i] = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1052.爱生气的书店老板 2021.02.23</title>
    <url>/2021/02/23/leetcode1052-20210223/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>题目：1052.爱生气的书店老板</li>
<li>难度：中等</li>
</ul>
<br>

<p>今天，书店老板有一家店打算试营业 <code>customers.length</code> 分钟。每分钟都有一些顾客（<code>customers[i]</code>）会进入书店，所有这些顾客都会在那一分钟结束后离开。</p>
<p>在某些时候，书店老板会生气。 如果书店老板在第 <code>i</code> 分钟生气，那么 <code>grumpy[i] = 1</code>，否则 <code>grumpy[i] = 0</code>。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p>
<p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。</p>
<p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。</p>
</blockquote>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><blockquote>
<p>输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3<br>输出：16<br>解释：<br>书店老板在最后 3 分钟保持冷静。<br>感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.</p>
</blockquote>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote>
<ul>
<li>1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000</li>
<li>0 &lt;= customers[i] &lt;= 1000</li>
<li>0 &lt;= grumpy[i] &lt;= 1</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>滑动窗口</li>
</ul>
<ol>
<li>首先我们先计算老板没有生气时所有满意客户量</li>
<li>计算前<code>X</code>分钟不生气时的客户数量总和,这个就是我们下面说的窗口┗|｀O′|┛ 嗷~~</li>
<li>我们开始挪动窗口，将窗口向右挪动一个单位<ol>
<li>窗口减去原窗口的第一个单位</li>
<li>窗口最加上原窗口的后一个单位</li>
<li>每次挪动都与窗口旧值比较，取较大值</li>
</ol>
</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSatisfied</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; customers, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; grumpy, <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对应步骤1，计算没有生气时所有满意客户数量</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;customers.size();i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(grumpy[i] == <span class="number">0</span>)&#123;</span><br><span class="line">		total +=customers[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对应步骤2，计算前X分钟不生气的客户数量总和</span></span><br><span class="line">	<span class="keyword">int</span> grow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;X;i++)&#123;</span><br><span class="line">		grow+=customers[i]*grumpy[i];</span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//对应步骤3，向右挪动窗口</span></span><br><span class="line">	<span class="keyword">int</span> max = grow;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = X;i&lt;customers.size();i++)&#123;</span><br><span class="line">        <span class="comment">//对应步骤3.1以及3.2，减去原窗口第一个以及追加原窗口后一个</span></span><br><span class="line">		grow = grow - customers[i-X]*grumpy[i-X] + customers[i]*grumpy[i];</span><br><span class="line">        <span class="comment">//对应步骤3.3，比较以往的最大值，取较大值</span></span><br><span class="line">		max = <span class="built_in">std</span>::max(max,grow);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> max+total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1178.猜字谜 2021.02.26</title>
    <url>/2021/02/26/leetcode1178-20210226/</url>
    <content><![CDATA[<h1 id="1178-猜字谜"><a href="#1178-猜字谜" class="headerlink" title="1178.猜字谜"></a>1178.猜字谜</h1><blockquote>
<ul>
<li>难度：简浑南</li>
</ul>
<br>

<p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p>
<p>字谜的迷面 <code>puzzle</code> 按字符串形式给出，如果一个单词 <code>word</code> 符合下面两个条件，那么它就可以算作谜底：</p>
<ul>
<li>单词 <code>word</code> 中包含谜面 <code>puzzle</code> 的第一个字母。</li>
<li>单词 <code>word</code> 中的每一个字母都可以在谜面 <code>puzzle</code> 中找到。<br>例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）。</li>
</ul>
<p>返回一个答案数组 <code>answer</code>，数组中的每个元素 <code>answer[i]</code> 是在给出的单词列表 <code>words</code> 中可以作为字谜迷面 <code>puzzles[i]</code> 所对应的谜底的单词数目。</p>
</blockquote>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>示例1：</p>
<blockquote>
<p>输入：<br>words = [“aaaa”,”asas”,”able”,”ability”,”actt”,”actor”,”access”],<br>puzzles = [“aboveyz”,”abrodyz”,”abslute”,”absoryz”,”actresz”,”gaswxyz”]</p>
<p>输出：[1,1,3,2,4,0]</p>
<p>解释：<br>1 个单词可以作为 “aboveyz” 的谜底 : “aaaa”<br>1 个单词可以作为 “abrodyz” 的谜底 : “aaaa”<br>3 个单词可以作为 “abslute” 的谜底 : “aaaa”, “asas”, “able”<br>2 个单词可以作为 “absoryz” 的谜底 : “aaaa”, “asas”<br>4 个单词可以作为 “actresz” 的谜底 : “aaaa”, “asas”, “actt”, “access”<br>没有单词可以作为 “gaswxyz” 的谜底，因为列表中的单词都不含字母 ‘g’。</p>
</blockquote>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote>
<ul>
<li>1 &lt;= words.length &lt;= 10^5</li>
<li>4 &lt;= words[i].length &lt;= 50</li>
<li>1 &lt;= puzzles.length &lt;= 10^4</li>
<li>puzzles[i].length == 7</li>
<li>words[i][j], puzzles[i][j] 都是小写英文字母。</li>
<li>每个 puzzles[i] 所包含的字符都不重复。</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li><p>二进制状态压缩 + 寻找所有子集</p>
<ol>
<li><p>遍历所有<code>words</code>数组中的字符串</p>
<ol>
<li><p>遍历<code>word</code>字符串的所有字符</p>
</li>
<li><p>出现过的所有字符把<code>bitset</code>对应的<code>bit</code>位设置成1(总共最多26个位，因为只用26个字母嘛)</p>
<blockquote>
<p>例如：<code>ace</code> 对应 <code>10101</code></p>
</blockquote>
</li>
<li><p>把的<code>bitset</code>存入哈希表中</p>
</li>
</ol>
</li>
<li><p>遍历所有<code>puzzles</code>数组</p>
<ol>
<li><p>遍历<code>puzzle</code>字符串的所有字符</p>
</li>
<li><p>出现过的所有字符把<code>bitset</code>对应的<code>bit</code>位设置成1</p>
</li>
<li><p>记录头字符的在<code>bitset</code>中的位置</p>
</li>
<li><p>遍历<code>bitset</code>的子集<code>cur</code>，直至<code>cur</code>为0</p>
<ol>
<li><p>如果子集<code>cur</code>中的头字符对应的<code>bit</code>位为1，则查询哈希表是否存在当前子集<code>cur</code></p>
<ul>
<li>存在，则<code>total</code>获取哈希表关键字<code>cur</code>对应的值</li>
<li>不存在，则跳过</li>
</ul>
</li>
<li><p>刷新<code>cur</code>，获取下一个子集</p>
<p><img src="https://jiajuu.top/2021/02/26/leetcode1178-20210226/GetCur.png" alt="获取子集"></p>
</li>
</ol>
</li>
<li><p>把<code>total</code>存取数组<code>res</code>中</p>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findNumOfValidWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; puzzles)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="comment">//遍历所有words数组中的字符串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str : words)&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">bitset</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历word字符串的所有字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : str)</span><br><span class="line">            <span class="comment">//出现过的所有字符把bitset对应的bit位设置成1</span></span><br><span class="line">            <span class="built_in">bitset</span> |= <span class="number">1</span> &lt;&lt; (c-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="comment">//把所有的bitset存入哈希表中</span></span><br><span class="line">        ++<span class="built_in">map</span>[<span class="built_in">bitset</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历所有puzzles数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str : puzzles)&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">bitset</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历puzzle字符串的所有字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : str)</span><br><span class="line">            <span class="comment">//出现过的所有字符把bitset对应的bit位设置成1</span></span><br><span class="line">            <span class="built_in">bitset</span> |= <span class="number">1</span> &lt;&lt; (c-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="comment">//记录头字符的在`bitset`中的位置</span></span><br><span class="line">        <span class="keyword">int</span> firstChar = str[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="built_in">bitset</span>;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历bitset的子集cur，直至cur为0</span></span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="comment">//如果子集cur中的头字符对应的bit位为1，则查询哈希表是否存在当前子集cur</span></span><br><span class="line">            <span class="keyword">if</span>((cur &gt;&gt; firstChar) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">auto</span> it = <span class="built_in">map</span>.find(cur);</span><br><span class="line">                <span class="comment">//存在，则total获取哈希表关键字cur对应的值</span></span><br><span class="line">                <span class="keyword">if</span>(it != <span class="built_in">map</span>.end()) total += <span class="built_in">map</span>[cur];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//刷新cur，获取下一个子集</span></span><br><span class="line">            cur = (cur - <span class="number">1</span>) &amp; <span class="built_in">bitset</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把total存取数组res中</span></span><br><span class="line">        res.push_back(total);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 131.分割回文串 2021.03.07</title>
    <url>/2021/03/07/leetcode131-20210307/</url>
    <content><![CDATA[<h1 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h1><blockquote>
<ul>
<li>难度：中等</li>
</ul>
<br>

<p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。</p>
<p>返回 <em>s</em> 所有可能的分割方案。</p>
</blockquote>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><blockquote>
<p>  输入: “aab”<br>  输出:<br>  [<br>    [“aa”,”b”],<br>    [“a”,”a”,”b”]<br>  ]</p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>回溯法+双指针<ol>
<li>双指针检测字符串是否为回文</li>
<li>设置回溯的出口为字符串长度为0的时候，在返回前，我们将遍历到最深处所保存的字符串数组保存到<code>res</code>数组中</li>
<li>每一次我们都是从头截取n个字符的子串(其中1&lt;=n&lt;字符串的长度)</li>
<li>并判断截取的子串是否是回文<ol>
<li>是回文则将当前截取子串放入纵向路径的字符串数组中，并查找子串的子串，直至子串长度为0时返回，返回回来后需要把当前子串从纵向路径的字符串数组中pop掉</li>
<li>不是回文则直接跳过</li>
</ol>
</li>
</ol>
</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回溯法+双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;<span class="comment">//所有纵向路径的字符串数组的数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path;<span class="comment">//纵向路径的字符串数组</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//判断字符串是否为回文字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPal</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = s.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l] != s[r]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=s.length();i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> newS = s.substr(<span class="number">0</span>,i);</span><br><span class="line">            <span class="keyword">if</span>(isPal(newS))&#123;</span><br><span class="line">                path.push_back(newS);</span><br><span class="line">                dfs(s.substr(i));</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        dfs(s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 232.用栈实现队列 2021.03.05</title>
    <url>/2021/03/05/leetcode232-20210305/</url>
    <content><![CDATA[<h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h1><blockquote>
<ul>
<li>难度：简单</li>
</ul>
<br>

<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>
<p>实现 <code>MyQueue</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>
<li><code>int pop()</code> 从队列的开头移除并返回元素</li>
<li><code>int peek()</code> 返回队列开头的元素</li>
<li><code>boolean empty()</code> 如果队列为空，返回 true ；否则，返回 false</li>
</ul>
</blockquote>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>示例1：</p>
<blockquote>
<p>  输入：<br>  [“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”]<br>  [[], [1], [2], [], [], []]<br>  输出：<br>  [null, null, null, 1, 1, false]</p>
<p>  解释：<br>  MyQueue myQueue = new MyQueue();<br>  myQueue.push(1); // queue is: [1]<br>  myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)<br>  myQueue.peek(); // return 1<br>  myQueue.pop(); // return 1, queue is [2]<br>  myQueue.empty(); // return false</p>
</blockquote>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote>
<ul>
<li>你只能使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
<li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li>
<li><code>1 &lt;= x &lt;= 9</code></li>
<li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>实例化2个栈，s1以及s2</li>
<li>当我们push数据时，都push到s1栈中</li>
<li>当我们peek数据时，检测s2栈是否有数据<ol>
<li>如果没有，我们s1栈中所有数据push到s2栈中，然后再返回s2栈顶数据</li>
<li>如果有，我们直接返回s2栈顶部数据</li>
</ol>
</li>
<li>当我们pop数据时，同样检测s2栈是否有数据<ol>
<li>如果没有，我们s1栈中所有数据push到s2栈中，然后保存并弹出s2栈顶部数据，最后再返回保存的数据</li>
<li>如果有，我们保存并弹出s2栈顶部数据，然后再返回保存的数据</li>
</ol>
</li>
<li>当我们判断是否为空时候，直接判断两个栈是否都为空</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;* s1;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;* s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MyQueue() &#123;</span><br><span class="line">		s1 = <span class="keyword">new</span> <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">		s2 = <span class="keyword">new</span> <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		s1-&gt;push(x);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!s2-&gt;empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> res = s2-&gt;top();</span><br><span class="line">			s2-&gt;pop();</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!s1-&gt;empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(s1-&gt;size() != <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				s2-&gt;push(s1-&gt;top());</span><br><span class="line">				s1-&gt;pop();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> res = s2-&gt;top();</span><br><span class="line">		s2-&gt;pop();</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Get the front element. */</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!s2-&gt;empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> res = s2-&gt;top();</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!s1-&gt;empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (s1-&gt;size() != <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				s2-&gt;push(s1-&gt;top());</span><br><span class="line">				s1-&gt;pop();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> res = s2-&gt;top();</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s1-&gt;empty() &amp;&amp; s2-&gt;empty();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 303.区域与检索-数组不可变 2021.03.01</title>
    <url>/2021/03/01/leetcode303-20210301/</url>
    <content><![CDATA[<h1 id="303-区域与检索-数组不可变"><a href="#303-区域与检索-数组不可变" class="headerlink" title="303.区域与检索-数组不可变"></a>303.区域与检索-数组不可变</h1><blockquote>
<ul>
<li>难度：简单</li>
</ul>
<br>

<p>给定一个整数数组  <code>nums</code>，求出数组从索引 <code>i</code> 到 <code>j</code>（<code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j</code> 两点。</p>
<p>实现 <code>NumArray</code> 类：</p>
<ul>
<li>NumArray(int[] nums) 使用数组 nums 初始化对象</li>
<li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code> 从索引 <code>i</code> 到 <code>j</code>（<code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j</code> 两点（也就是 <code>sum(nums[i], nums[i + 1], ... , nums[j]</code>)）</li>
</ul>
</blockquote>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>示例1：</p>
<blockquote>
<p>输入：<br>[“NumArray”, “sumRange”, “sumRange”, “sumRange”]<br>[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]<br>输出：<br>[null, 1, -1, -3]</p>
<p>解释：<br>NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);<br>numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)<br>numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1))<br>numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</p>
</blockquote>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote>
<ul>
<li><code>0 &lt;= nums.length &lt;= 10^4</code></li>
<li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li>
<li><code>0 &lt;= i &lt;= j &lt; nums.length</code></li>
<li>最多调用 <code>10^4</code> 次 <code>sumRange</code> 方法</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>无脑暴力解：<ol>
<li>把<code>nums</code>中的<code>i~j</code>相加并返回</li>
<li>当我们调用<code>sumRange()</code>时，均需要循环n次</li>
</ol>
</li>
<li>前缀和：<ol>
<li>相加的环节我们放到构造函数中，这样的话我们在构造时只执行一遍</li>
<li>当我们调用 <code>sumRange()</code>时，只要执行1次便可</li>
</ol>
</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无脑暴力解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers;</span><br><span class="line"></span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        numbers = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = i;a&lt;=j;a++)&#123;</span><br><span class="line">            res+=numbers[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前缀和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers;</span><br><span class="line"></span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        numbers.resize(nums.size()+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            numbers[i+<span class="number">1</span>] = numbers[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numbers[j+<span class="number">1</span>] - numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 304.二维区域和检索-矩阵不可变 2021.03.02</title>
    <url>/2021/03/02/leetcode304-20210302/</url>
    <content><![CDATA[<h1 id="304-二维区域和检索-矩阵不可变"><a href="#304-二维区域和检索-矩阵不可变" class="headerlink" title="304.二维区域和检索-矩阵不可变"></a>304.二维区域和检索-矩阵不可变</h1><blockquote>
<ul>
<li>难度：中等</li>
</ul>
<br>

<p>给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 <code>(row1, col1)</code> ，右下角为 <code>(row2, col2)</code> 。</p>
<p><img src="https://jiajuu.top/2021/03/02/leetcode304-20210302/%E4%B8%BE%E4%BE%8B.png" alt="举个栗子"></p>
<p>上图子矩阵左上角 (row1, col1) = <code>(2, 1)</code> ，右下角(row2, col2) = <code>(4, 3)</code>，该子矩形内元素的总和为 8。</p>
</blockquote>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>示例1：</p>
<blockquote>
<p>给定 matrix = [<br>  [3, 0, 1, 4, 2],<br>  [5, 6, 3, 2, 1],<br>  [1, 2, 0, 1, 5],<br>  [4, 1, 0, 1, 7],<br>  [1, 0, 3, 0, 5]<br>]</p>
<br>

<p>sumRegion(2, 1, 4, 3) -&gt; 8<br>sumRegion(1, 1, 2, 2) -&gt; 11<br>sumRegion(1, 2, 2, 4) -&gt; 12</p>
</blockquote>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote>
<ul>
<li>你可以假设矩阵不可变。</li>
<li>会多次调用 <code>sumRegion</code> 方法<em>。</em></li>
<li>你可以假设 <code>row1 ≤ row2</code> 且 <code>col1 ≤ col2</code> 。</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li><p>无脑暴力解：</p>
<ol>
<li>把<code>matrix</code>中<code>row1</code>行到<code>row2</code>行的<code>col1</code>列到<code>col</code>2列相加并返回</li>
<li>当我们调用<code>sumRange()</code>时，均需要循环n*m次</li>
<li>自信的点击提交！然后你就会发现会超出时间显示┭┮﹏┭┮</li>
</ol>
</li>
<li><p>一维前缀和：</p>
<ol>
<li>相加的环节我们放到构造函数中，这样的话我们在构造时只执行一遍</li>
<li>当我们调用 <code>sumRange()</code>时，只要执行n次便可</li>
</ol>
</li>
<li><p>二维前缀和：</p>
<ol>
<li><p><code>numMatrux</code>每一个坐标的值都保存着(0,0)到当前坐标的矩形之和</p>
<p><img src="https://jiajuu.top/2021/03/02/leetcode304-20210302/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C.jpeg" alt="举个栗子"></p>
</li>
<li><p>白色矩形 = 整个矩形 - 粉色矩形 - 红色矩形 - 灰色矩形</p>
</li>
<li><p>也就是等于D坐标值 - B坐标值 - C坐标值 + A坐标值，其中减了2次灰色矩形，所以我们需要补回来</p>
</li>
<li><p>当我们调用 <code>sumRange()</code>时，只要执行1次便可</p>
</li>
</ol>
</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无脑暴力解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; numMatrux;</span><br><span class="line"></span><br><span class="line">    NumMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        numMatrux = matrix;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row1;i&lt;=row2;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = col1;j&lt;=col2;j++)&#123;</span><br><span class="line">                sum += numMatrux[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一维前缀和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; numMatrux;</span><br><span class="line"></span><br><span class="line">    NumMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        numMatrux.resize(matrix.size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(matrix[<span class="number">0</span>].size()+<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;matrix.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">                numMatrux[i][j+<span class="number">1</span>] += matrix[i][j] + numMatrux[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row1;i&lt;=row2;i++)&#123;</span><br><span class="line">            sum += (numMatrux[i][col2+<span class="number">1</span>]-numMatrux[i][col1]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维前缀和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; numMatrux;</span><br><span class="line"></span><br><span class="line">    NumMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        numMatrux.resize(matrix.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(matrix[<span class="number">0</span>].size()+<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;matrix.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">                numMatrux[i+<span class="number">1</span>][j+<span class="number">1</span>] = </span><br><span class="line">                    numMatrux[i+<span class="number">1</span>][j] + </span><br><span class="line">                    numMatrux[i][j+<span class="number">1</span>] - </span><br><span class="line">                    numMatrux[i][j] + </span><br><span class="line">                    matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">            numMatrux[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - </span><br><span class="line">            numMatrux[row1][col2+<span class="number">1</span>] - </span><br><span class="line">            numMatrux[row2+<span class="number">1</span>][col1] + </span><br><span class="line">            numMatrux[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 338.比特位计算 2021.03.03</title>
    <url>/2021/03/03/leetcode338-20210303/</url>
    <content><![CDATA[<h1 id="338-比特位计算"><a href="#338-比特位计算" class="headerlink" title="338.比特位计算"></a>338.比特位计算</h1><blockquote>
<ul>
<li>难度：中等</li>
</ul>
<br>

<p>给定一个非负整数 <code>num</code>。对于 <code>0 ≤ i ≤ num</code> 范围中的每个数字 <code>i</code> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
</blockquote>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>示例1：</p>
<blockquote>
<p>  输入: 2<br>  输出: [0,1,1]</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入: 5<br>输出: [0,1,1,2,1,2]</p>
</blockquote>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote>
<ul>
<li>给出时间复杂度为<code>O(n*sizeof(integer))</code>的解答非常容易。但你可以在线性时间<code>O(n)</code>内用一趟扫描做到吗？</li>
<li>要求算法的空间复杂度为<code>O(n)</code>。</li>
<li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 <code>__builtin_popcount</code>）来执行此操作。</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li><p>无脑逐个计算：</p>
<ol>
<li>(11)<sub>2</sub>去掉最后一个1,得到(10)<sub>2</sub></li>
<li>(10)<sub>2</sub>继续去掉最后一个1，得到(00)<sub>2</sub></li>
<li>计算过程进行了多少次</li>
</ol>
</li>
<li><p>最高有效位：</p>
<ol>
<li>(1011)<sub>2</sub>中1的个数=(1000)<sub>2</sub>中1的个数+(11)<sub>2</sub>中1的个数</li>
<li>(11)<sub>2</sub>的个数从<code>res[3]</code>中获得</li>
</ol>
</li>
<li><p>最低有效位：</p>
<ol>
<li>(1011)<sub>2</sub>中1的个数=(101)<sub>2</sub>中1的个数+(1)<sub>2</sub>中1的个数</li>
<li>(101)<sub>2</sub>的个数从<code>res[5]</code>中获得</li>
</ol>
</li>
<li><p>最低设置位：</p>
<ol>
<li>(1011)<sub>2</sub>中1的个数=(1010)<sub>2</sub>中1的个数+(1)<sub>2</sub>中1的个数</li>
<li>(1010)<sub>2</sub>的个数从<code>res[10]</code>中获得</li>
</ol>
</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无脑逐个计算</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=num;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = i;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="number">0</span>)&#123;</span><br><span class="line">            temp &amp;= (temp - <span class="number">1</span>);</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最高有效位</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(num+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> highBit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">            highBit = i;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = res[i - highBit] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最低有效位</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(num+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">        res[i] = res[i&gt;&gt;<span class="number">1</span>] + (i&amp;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最低设置位</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(num+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">        res[i] = res[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 354.俄罗斯套娃信封问题 2021.03.04</title>
    <url>/2021/03/04/leetcode354-20210304/</url>
    <content><![CDATA[<h1 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354.俄罗斯套娃信封问题"></a>354.俄罗斯套娃信封问题</h1><blockquote>
<ul>
<li>难度：困难</li>
</ul>
<br>

<p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 <code>(w, h)</code> 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p>
<p>请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p>
</blockquote>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>示例1：</p>
<blockquote>
<p>  输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]<br>  输出: 3<br>  解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</p>
</blockquote>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote>
<p>不允许旋转信封。</p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>动态规划<ol>
<li>我们按信封的宽排序，若宽相等，我们按高进行排序。</li>
<li>我们从第二个信封开始，开始拿起</li>
<li>若拿起的信封能将其之前的信封装入，说明其之前的信封能装的信封它都能装。</li>
<li>拿起的信封能装信封数量=其装入的信封内的数量+1(它本身)</li>
<li>比较拿起的信封能装信封数量是否比旧值大，取较大值</li>
</ol>
</li>
</ul>
<p><img src="https://jiajuu.top/2021/03/04/leetcode354-20210304/%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8B.png" alt="思路流程"></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(envelopes.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sort(envelopes.begin(),envelopes.end(),[](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v1,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v2)&#123;</span><br><span class="line">        <span class="keyword">return</span> v1[<span class="number">0</span>]&lt;v2[<span class="number">0</span>] || (v1[<span class="number">0</span>] == v2[<span class="number">0</span>] &amp;&amp; v1[<span class="number">1</span>]&gt;v2[<span class="number">1</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(envelopes.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;envelopes.size();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(envelopes[j][<span class="number">1</span>]&lt;envelopes[i][<span class="number">1</span>])</span><br><span class="line">                res[i] = max(res[i],res[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *max_element(res.begin(),res.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 395.至少有K个重复字符的最长子串 2021.02.27</title>
    <url>/2021/02/27/leetcode395-20210227/</url>
    <content><![CDATA[<h1 id="395-至少有-K-个重复字符的最长子串"><a href="#395-至少有-K-个重复字符的最长子串" class="headerlink" title="395. 至少有 K 个重复字符的最长子串"></a>395. 至少有 K 个重复字符的最长子串</h1><blockquote>
<ul>
<li>难度：中等</li>
</ul>
<br>

<p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> ，请你找出 <code>s</code> 中的最长子串， 要求该子串中的每一字符出现次数都不少于 <code>k</code> 。返回这一子串的长度。</p>
</blockquote>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>示例1：</p>
<blockquote>
<p>输入：s = “aaabb”, k = 3<br>输出：3<br>解释：最长子串为 “aaa” ，其中 ‘a’ 重复了 3 次。</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：s = “ababbc”, k = 2<br>输出：5<br>解释：最长子串为 “ababb” ，其中 ‘a’ 重复了 2 次， ‘b’ 重复了 3 次。</p>
</blockquote>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
<li><code>1 &lt;= k &lt;= 105</code></li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li><p>滑动窗口+双指针</p>
<blockquote>
<p><code>charType</code>为假设的字符种类数</p>
<p><code>charHash</code>为哈希数组</p>
<p><code>less</code>为不足k的字符种类数</p>
<p><code>typeTotal</code>为当前哈希数组内的字符种类数</p>
</blockquote>
<ol>
<li>首先我们假设最长字串仅有一个字符符合题目要求，逐步增加，直至假设26个字符都符合题目</li>
<li>接着我们用左、右双指针指向字符串的头</li>
<li>如果右指针未到字符串的尾部<ol>
<li>把右指针指向的字符加进一个哈希数组里<ol>
<li>如果哈希数组对应字符的值为1，说明刚才这个值是新加进去的，刚才并没有这个值，则<code>less</code>、<code>typeTotal</code>均加1</li>
<li>如果哈希数组对应字符的值为k，说明这个数达到k的要求了，<code>less</code>就能减1</li>
</ol>
</li>
<li>如果当前哈希数组内的字符种类数超出我们假设的字符种类数，我们便把左指针指向的字符从哈希数组中减去，直至<code>typeTotal</code>≤<code>charType</code><ol>
<li>如果哈希数组对应字符的值为k-1，说明这个字符刚才符合k的要求，现在缺不符合了，<code>less</code>需要加1</li>
<li>如果哈希数组对应字符的值为0，说明这个字符现在不存在我们的窗口内了，<code>less</code>、<code>typeTotal</code>均需要减1</li>
<li>左移左指针</li>
</ol>
</li>
<li>当<code>less</code>等于0，说明窗口内的字符符合题目要求，与以往的字串比较，取最长的。</li>
<li>左移右指针</li>
</ol>
</li>
</ol>
</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//假设最长窗口内包含的不同字符种类</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> charType = <span class="number">1</span>;charType &lt;= <span class="number">26</span>;charType++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;<span class="comment">//左指针</span></span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;<span class="comment">//右指针</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">charHash</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;<span class="comment">//哈希数组</span></span><br><span class="line">        <span class="keyword">int</span> less = <span class="number">0</span>;<span class="comment">//不符合k个字符的字符种类数</span></span><br><span class="line">        <span class="keyword">int</span> typeTotal = <span class="number">0</span>;<span class="comment">//窗口内包含的字符种类数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//直至右指针直到字符串结尾</span></span><br><span class="line">        <span class="keyword">while</span>(r &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">//右指针指向的字符存取哈希数组中</span></span><br><span class="line">        	charHash[s[r] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//判断字符对应哈希数组的数组是否等于1，等于1说明刚才并没有这个字符种类</span></span><br><span class="line">            <span class="keyword">if</span>(charHash[s[r] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                less++;<span class="comment">//不足k个字符种类数加1</span></span><br><span class="line">                typeTotal++;<span class="comment">//窗口内的字符种类数加1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//判断字符对应哈希数组的数组是否等于K，等于K说明刚才并没有符合k个字符的要求</span></span><br><span class="line">            <span class="keyword">if</span>(charHash[s[r] - <span class="string">&#x27;a&#x27;</span>] == k)&#123;</span><br><span class="line">                less--;<span class="comment">//现在符合了，不足k个字符种类数减1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//直至窗口内的字符种类数少于我们假设的字符数</span></span><br><span class="line">            <span class="keyword">while</span>(typeTotal &gt; charType)&#123;</span><br><span class="line">                <span class="comment">//减去哈希数组中左指针指向的字符</span></span><br><span class="line">                charHash[s[l] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//判断字符对应哈希数组的数组是否等于K-1，等于K-1说明刚才符合k个字符的要求</span></span><br><span class="line">                <span class="keyword">if</span>(charHash[s[l] - <span class="string">&#x27;a&#x27;</span>] == k<span class="number">-1</span>)&#123;</span><br><span class="line">                    less++;<span class="comment">//现在不符合了，不足k个字符种类数加1</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//判断字符对应哈希数组的数组是否等于0，等于0说明刚才存在这个字符</span></span><br><span class="line">                <span class="keyword">if</span>(charHash[s[l] - <span class="string">&#x27;a&#x27;</span>] ==  <span class="number">0</span>)&#123;</span><br><span class="line">                    typeTotal--;<span class="comment">//窗口内的字符种类数减1</span></span><br><span class="line">                    less--;<span class="comment">//现在这个字符不存在了，不足k个字符种类数减1</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                l++;<span class="comment">//右移左指针</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//less为零说明窗口内的字符串符合题目要求</span></span><br><span class="line">            <span class="keyword">if</span>(less == <span class="number">0</span>)&#123;</span><br><span class="line">                res = max(res,r-l+<span class="number">1</span>);<span class="comment">//与以往的结果比较，取最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            r++;<span class="comment">//右移右指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 503.下一个更大元素Ⅱ 2021.03.06</title>
    <url>/2021/03/06/leetcode503-20210306/</url>
    <content><![CDATA[<h1 id="503-下一个更大元素Ⅱ"><a href="#503-下一个更大元素Ⅱ" class="headerlink" title="503.下一个更大元素Ⅱ"></a>503.下一个更大元素Ⅱ</h1><blockquote>
<ul>
<li>难度：中等</li>
</ul>
<br>

<p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
</blockquote>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>示例1：</p>
<blockquote>
<p>  输入: [1,2,1]<br>  输出: [2,-1,2]<br>  解释: 第一个 1 的下一个更大的数是 2；<br>  数字 2 找不到下一个更大的数；<br>  第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</p>
</blockquote>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote>
<ul>
<li>注意： 输入数组的长度不会超过 10000。</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>无赖暴破<ol>
<li>我们遍历数组两轮</li>
<li>若后面有数值大于当前数值，我们就把后面的数值赋值到返回数组中</li>
<li>这是需要注意的是<code>i</code>和<code>j</code>超出原数组的长度，所以我们需要<code>%nums.size()</code>处理</li>
</ol>
</li>
<li>栈+循环数组<ol>
<li>同样的，我们需要遍历两轮</li>
<li>我们每到一个数值都与栈顶元素比较，若当前数值比栈顶元素所指的数值大，我们便赋值到返回数组中，并把栈顶元素<code>pop()</code>掉</li>
<li>并继续比较栈顶数值，直至当前值小于栈顶元素所指的数值</li>
<li>比较完后，我们把当前数值在数组的坐标<code>push()</code>栈中</li>
<li>最后右移，继续下一轮循环</li>
</ol>
</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无赖暴破</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(),<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.size()*<span class="number">2</span><span class="number">-2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;nums.size()*<span class="number">2</span><span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i%nums.size()] &lt; nums[j%nums.size()] )&#123;</span><br><span class="line">                res[i%nums.size()] = nums[j%nums.size()];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈+循环数组</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(),<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.size()*<span class="number">2</span><span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() &amp;&amp; nums[s.top()] &lt; nums[i%nums.size()])&#123;</span><br><span class="line">            res[s.top()] = nums[i%nums.size()];</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(i%nums.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 832.翻转图像 2021.02.24</title>
    <url>/2021/02/24/leetcode832-20210224/</url>
    <content><![CDATA[<h1 id="832-翻转图像"><a href="#832-翻转图像" class="headerlink" title="832.翻转图像"></a>832.翻转图像</h1><blockquote>
<ul>
<li>难度：简单</li>
</ul>
<br>

<p>给定一个二进制矩阵 <code>A</code>，我们想先水平翻转图像，然后反转图像并返回结果。</p>
<p>水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 <code>[1, 1, 0]</code> 的结果是 <code>[0, 1, 1]</code>。</p>
<p>反转图片的意思是图片中的 <code>0</code> 全部被 <code>1</code> 替换， <code>1</code> 全部被 <code>0</code> 替换。例如，反转 <code>[0, 1, 1]</code> 的结果是 <code>[1, 0, 0]</code>。</p>
</blockquote>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>示例1：</p>
<blockquote>
<p>输入：[[1,1,0],[1,0,1],[0,0,0]]<br>输出：[[1,0,0],[0,1,0],[1,1,1]]<br>解释：首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；<br>     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：[[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]<br>输出：[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]<br>解释：首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；<br>     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</p>
</blockquote>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote>
<ul>
<li>1 &lt;= A.length = A[0].length &lt;= 20</li>
<li>0 &lt;= A[i][j] &lt;= 1</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li><p>双指针</p>
<ol>
<li>遍历数组A</li>
<li>左指针指向数组a头，右指针指向数组b的尾</li>
<li>左指针赋值到临时变量temp中</li>
<li>取反的右指针赋值到左指针</li>
<li>取反的临时变量temp赋值到右指针</li>
<li>左指针右移</li>
<li>右指针左移</li>
<li>直至左指针大于右指针</li>
</ol>
</li>
</ul>
<ul>
<li><p>无敌外挂大法</p>
<ol>
<li>逐位求反</li>
<li>调用STL中的alalgorithm库中的<code>reverse()</code>函数反转数组</li>
</ol>
</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针大法好</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; flipAndInvertImage(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A) &#123;</span><br><span class="line">    <span class="comment">//遍历数组A</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;a : A)&#123;</span><br><span class="line">        <span class="comment">//左指针指向数组a头，右指针指向数组b的尾</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = a.size()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//直至左指针大于右指针</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="comment">//左指针赋值到临时变量temp中</span></span><br><span class="line">            <span class="keyword">int</span> temp = a[left];</span><br><span class="line">            <span class="comment">//取反的右指针赋值到左指针</span></span><br><span class="line">            a[left] = !a[right];</span><br><span class="line">            <span class="comment">//取反的临时变量temp赋值到右指针</span></span><br><span class="line">            a[right] = !temp;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//左指针右移</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">//右指针左移</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无敌外挂</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; flipAndInvertImage(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A) &#123;</span><br><span class="line">	<span class="comment">//逐位求反</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;a :A)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;aa:a)&#123;</span><br><span class="line">			aa = !aa;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用STL中的alalgorithm库中的`reverse()`函数反转数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;a : A)&#123;</span><br><span class="line">        reverse(a.begin(),a.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 867.转置矩阵 2021.02.25</title>
    <url>/2021/02/25/leetcode867-20210225/</url>
    <content><![CDATA[<h1 id="867-转置矩阵"><a href="#867-转置矩阵" class="headerlink" title="867.转置矩阵"></a>867.转置矩阵</h1><blockquote>
<ul>
<li>难度：简单</li>
</ul>
<br>

<p>给你一个二维整数数组 <code>matrix</code>， 返回 <code>matrix</code> 的 转置矩阵 。</p>
<p>矩阵的 <strong>转置</strong> 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p>
<p><img src="https://jiajuu.top/2021/02/25/leetcode867-20210225/hint_transpose.png" alt="转置矩阵"></p>
</blockquote>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>示例1：</p>
<blockquote>
<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[1,4,7],[2,5,8],[3,6,9]]</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：matrix = [[1,2,3],[4,5,6]]<br>输出：[[1,4],[2,5],[3,6]]</p>
</blockquote>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote>
<ul>
<li>m == matrix.length</li>
<li>n == matrix[i].length</li>
<li>1 &lt;= m, n &lt;= 1000</li>
<li>1 &lt;= m * n &lt;= 105</li>
<li>-10^9 &lt;= matrix[i][j] &lt;= 10^9</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>无脑照搬<ol>
<li>实例化<code>数组res</code>，列为<code>数组matrix</code>的行，行为<code>数组matrix</code>的列</li>
<li>给<code>数组res</code>的列赋值<code>数组matrix</code>的行，<code>数组res</code>的行赋值<code>数组matrix</code>的列</li>
</ol>
</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; transpose(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="comment">//实例化res，列为matrix的行，行为数组matrix的列</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(matrix[<span class="number">0</span>].size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(matrix.size()));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;res.size();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;res[i].size();j++)&#123;</span><br><span class="line">            <span class="comment">//给res的列赋值matrix的行，res的行赋值matrix的列</span></span><br><span class="line">            res[i][j] = matrix[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 896.单调数列 2021.02.28</title>
    <url>/2021/02/28/leetcode896-20210228/</url>
    <content><![CDATA[<h1 id="896-单调数列"><a href="#896-单调数列" class="headerlink" title="896.单调数列"></a>896.单调数列</h1><blockquote>
<ul>
<li>难度：简单</li>
</ul>
<br>

<p>如果数组是单调递增或单调递减的，那么它是单调的。</p>
<p>如果对于所有 <code>i &lt;= j</code>，<code>A[i] &lt;= A[j]</code>，那么数组 <code>A</code> 是单调递增的。 如果对于所有 <code>i &lt;= j</code>，<code>A[i]&gt; = A[j]</code>，那么数组 <code>A</code> 是单调递减的。</p>
<p>当给定的数组 <code>A</code> 是单调数组时返回 <code>true</code>，否则返回 <code>false</code>。</p>
</blockquote>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>示例1：</p>
<blockquote>
<p>输入：[1,2,2,3]<br>输出：true</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：[6,5,4,4]<br>输出：true</p>
</blockquote>
<p>示例3：</p>
<blockquote>
<p>输入：[1,3,2]<br>输出：false</p>
</blockquote>
<p>示例4：</p>
<blockquote>
<p>输入：[1,2,4,5]<br>输出：true</p>
</blockquote>
<p>示例5：</p>
<blockquote>
<p>输入：[1,1,1]<br>输出：true</p>
</blockquote>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote>
<ul>
<li><code>1 &lt;= A.length &lt;= 50000</code></li>
<li><code>-100000 &lt;= A[i] &lt;= 100000</code></li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>标志位大法<ol>
<li>递增标志位为true，递减标志位为true</li>
<li>遍历数组<ul>
<li>若前数大于后数，把递减标记位置为false</li>
<li>若前数小于后数，把递增标记位置为false</li>
<li>若前数小于后数，所有标志位都保持</li>
</ul>
</li>
<li>递增标志位 || 递减标志位 得到 是否 单调数列</li>
</ol>
</li>
</ul>
<ul>
<li>STL外挂<ol>
<li>调用两次STL算法库中的is_sorted()函数<ul>
<li>第一次检测其是否单调递增</li>
<li>第二次检测其是否单调递减</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标志位打法好呀ε=ε=ε=┏(゜ロ゜;)┛</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMonotonic</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> zeng = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> jian = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.size()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt; A[i+<span class="number">1</span>])</span><br><span class="line">            jian = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt; A[i+<span class="number">1</span>])</span><br><span class="line">            zeng = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> zeng || jian;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迫不得已，我们不首先使用外挂</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMonotonic</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> is_sorted(A.begin(),A.end()) || is_sorted(A.rbegin(),A.rend());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-传输层</title>
    <url>/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h1 id="传输层功能"><a href="#传输层功能" class="headerlink" title="传输层功能"></a>传输层功能</h1><ul>
<li>为相互通信的进程提供了逻辑通讯</li>
<li>对报文进行差错检测</li>
<li>提供面向连接和无连接服务</li>
</ul>
<h1 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h1><ul>
<li>TCP协议（用户数据报协议）<ul>
<li>传输的数据需要分段</li>
<li>建立会话</li>
<li>可靠传输</li>
<li>流量控制</li>
</ul>
</li>
<li>UDP协议（用户数据报协议）<ul>
<li>一个数据包就可以完成通信</li>
<li>不建立会话</li>
<li>不需要流量控制</li>
<li>不可靠传输</li>
</ul>
</li>
</ul>
<h1 id="IP与端口号"><a href="#IP与端口号" class="headerlink" title="IP与端口号"></a>IP与端口号</h1><ul>
<li>IP地址用于定位服务器</li>
<li>端口号用于定位进程服务<ul>
<li>一共由0-65535端口号</li>
<li>0-1023为熟知端口</li>
<li>1024-49151为登记端口</li>
<li>49152-65535为客户端端口</li>
</ul>
</li>
</ul>
<h1 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>无连接，发送数据前不需要建立连接</li>
<li>使用最大努力交付，不保证可靠传输，不使用拥塞控制</li>
<li>面向报文</li>
<li>支持一对一、一对多、多对一、多对多的交互通信</li>
<li>首部开销8个字节</li>
</ul>
<h2 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h2><p><img src="https://jiajuu.top/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/UDP%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.jpg" alt="UDP首部格式"></p>
<blockquote>
<p>首部中校验和的计算需要网络层首部中12个字节参与，因为这部分不属于传输层中，所以也叫伪首部。</p>
</blockquote>
<h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul>
<li>面向连接（三次握手）</li>
<li>TCP连接仅支持点对点通信</li>
<li>TCP提供可靠交付服务</li>
<li>TCP提供全双工通信</li>
<li>面向字节流</li>
</ul>
<h2 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h2><p><img src="https://jiajuu.top/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png" alt="TCP首部格式"></p>
<blockquote>
<ul>
<li>序号：数据的第一个字节位于整个文件的多少字节位置</li>
<li>确认号：告诉对方下一次发送整个文件的多少字节位置的数据</li>
<li>数据偏移：TCP首部的长度不固定，所以这个参数用来说明数据需要偏移多少位</li>
<li>URG：是否优先传输，不需要排队</li>
<li>ACK：确认号是否有效</li>
<li>PSH：接受时优先接受</li>
<li>RST：TCP会话出现错误，需释放再重连</li>
<li>SYN：建立会话的标志</li>
<li>FIN：结束会话标志</li>
<li>窗口：控制窗口的大小，处理缓存的上限</li>
<li>紧急指针：URG为1时有效，表明紧急数据在数据中的字节位置</li>
<li>选项：<ul>
<li>可以规定最大数据报（MSS）的大小</li>
<li>可以规定是否支持选择性确认</li>
<li>最长40个字节</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="TCP的点对点连接"><a href="#TCP的点对点连接" class="headerlink" title="TCP的点对点连接"></a>TCP的点对点连接</h2><p>TCP连接的两个端点不是主机，不是IP地址，不是应用程序，也不是协议端口号。</p>
<p>而是套接字socket</p>
<blockquote>
<p>socket = ip + port</p>
</blockquote>
<h2 id="TCP如何确保可靠交付"><a href="#TCP如何确保可靠交付" class="headerlink" title="TCP如何确保可靠交付"></a>TCP如何确保可靠交付</h2><ul>
<li>停止等待协议（缺点：信道利用率低下）</li>
<li>自动重传请求ARQ协议（优化信道利用率）</li>
</ul>
<h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><ol>
<li><p>无差错情况</p>
<p><img src="https://jiajuu.top/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/%E6%97%A0%E5%B7%AE%E9%94%99%E6%83%85%E5%86%B5.jpg" alt="无差错情况"></p>
</li>
<li><p>超时重传情况</p>
<p><img src="https://jiajuu.top/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%83%85%E5%86%B5.jpg" alt="超时重传情况"></p>
</li>
<li><p>确认丢失情况</p>
<p><img src="https://jiajuu.top/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E6%83%85%E5%86%B5.jpg" alt="确认丢失情况"></p>
</li>
<li><p>确认迟到情况</p>
<p><img src="https://jiajuu.top/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0%E6%83%85%E5%86%B5.jpg" alt="确认迟到情况"></p>
</li>
</ol>
<h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><p><img src="https://jiajuu.top/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE.jpg" alt="连续ARQ协议"></p>
<blockquote>
<p>当收到ACK确认后，窗口便往后移动</p>
</blockquote>
<h3 id="积累确认"><a href="#积累确认" class="headerlink" title="积累确认"></a>积累确认</h3><ul>
<li>不需要每一个都确认，当我们收到确认③时，说明①②也收到了</li>
<li>但是这个导致重复发送</li>
</ul>
<blockquote>
<p>举个栗子：</p>
<ul>
<li>发送①②③④，③在途中丢失了</li>
<li>收到返回的②的确认后，却收不到③的确认</li>
<li>重发③④过去，其中④重复发送</li>
</ul>
</blockquote>
<h3 id="窗口控制"><a href="#窗口控制" class="headerlink" title="窗口控制"></a>窗口控制</h3><blockquote>
<p>以字节为单位的滑动窗口技术</p>
</blockquote>
<ul>
<li><p>当接受到确认报后，发送端才会移动发送窗口，并从缓存中删除确认过的数据</p>
</li>
<li><p>若中途有数据包丢失，根据确认号以及选择性确认，重发丢失的数据包</p>
</li>
</ul>
<h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><p>新RTTs = （1 - α） * （旧RTTs） + α * （新的RTT样本）</p>
<blockquote>
<p>RTTs：加权平均往返时间</p>
<p>α：平滑因子，推荐为1/8</p>
<ul>
<li>α增大，修正幅度增大，适用于变化较大的网络中</li>
<li>α减大，修正幅度减小，适用于变化较小的网络中</li>
</ul>
<p>RTT样本：当前往返时间</p>
</blockquote>
<h2 id="TCP如何实现流量控制"><a href="#TCP如何实现流量控制" class="headerlink" title="TCP如何实现流量控制"></a>TCP如何实现流量控制</h2><ul>
<li><p>每次确认包都可以调整当前窗口的大小</p>
</li>
<li><p>当窗口调整到零时，通信就会停止</p>
<blockquote>
<p>注意：停止的时候发送方也会定期发送窗口测定数据包，确保对方仍在线</p>
</blockquote>
</li>
<li><p>接收方需要发送一个确认包调整窗口大小，通信才能继续开始</p>
</li>
</ul>
<h2 id="TCP如何实现拥塞控制"><a href="#TCP如何实现拥塞控制" class="headerlink" title="TCP如何实现拥塞控制"></a>TCP如何实现拥塞控制</h2><blockquote>
<ul>
<li><p>出现拥塞的条件：对资源需求的总和 &gt; 可用的资源</p>
</li>
<li><p>原理：发送方会维护着一个拥塞窗口</p>
</li>
</ul>
</blockquote>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><ul>
<li><code>cwnd = [1,2,4,6,8,16]</code></li>
<li>收到确认包后，<code>cwnd</code>会指数增长</li>
<li>当<code>cwnd</code>达到16后，每次只会增长1</li>
<li>直至收不到确认包（发生阻塞）</li>
<li>当发生阻塞时，<code>cwnd</code>增长的上限变为发生阻塞时<code>cwnd</code>的1/2</li>
<li>并且cwnd又从1开始增长</li>
</ul>
<blockquote>
<p>注意：慢启动并不是意味着不可能发生网络拥塞，只是按线性增长，使得网络比较不容易拥塞</p>
</blockquote>
<h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><ul>
<li>当发送方收到接收方3个确认包中确认号时相同的，直接重发确认号的数据包</li>
</ul>
<h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><ul>
<li><p><code>cwnd</code>变为发生阻塞时<code>cwnd</code>的1/2</p>
</li>
<li><p>并以加1的速度增长</p>
</li>
</ul>
<blockquote>
<p>发送方的发送窗口应该为Min[接收方接受窗口，发送方发送窗口，拥塞窗口]</p>
</blockquote>
<p><img src="https://jiajuu.top/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png" alt="拥塞控制"></p>
<h2 id="拥塞控制-amp-流量控制的区别"><a href="#拥塞控制-amp-流量控制的区别" class="headerlink" title="拥塞控制&amp;流量控制的区别"></a>拥塞控制&amp;流量控制的区别</h2><ul>
<li>拥塞控制：是一个全局过程，涉及到全网络中的所有主机，所有路由以及与降低网络传输性能有关的所有因素。</li>
<li>流量控制：往往只存在于给定的发送端和接收端之间的点对点通信量控制，所做的事情便是抑制发送端发送数据的速率，以便接收方来得及接受。</li>
</ul>
<h3 id="TCP传输连接管理"><a href="#TCP传输连接管理" class="headerlink" title="TCP传输连接管理"></a>TCP传输连接管理</h3><ul>
<li>三大阶段：连接建立、数据传输、连接释放</li>
<li>连接方式：客户端/服务器方式</li>
</ul>
<h3 id="连接的建立"><a href="#连接的建立" class="headerlink" title="连接的建立"></a>连接的建立</h3><p><img src="https://jiajuu.top/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B.png" alt="连续ARQ协议"></p>
<blockquote>
<p>第三次握手的必要性：</p>
<ul>
<li>原因①：确保服务器发送能力正常</li>
<li>原因②：<ul>
<li>防止第一个挥手超时，发送第二次</li>
<li>确认第二次握手包后，又收到第一次握手包，</li>
<li>再确认一次，但客户端已经接受到第一次确认包，所以不搭理</li>
<li>但服务端却开辟着资源等待发送端的数据传输，造成了开销浪费</li>
</ul>
</li>
</ul>
</blockquote>
<p>连接的释放</p>
<p><img src="https://jiajuu.top/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE.png" alt="连续ARQ协议"></p>
<blockquote>
<p>默认1MSL = 2分钟</p>
<p>2MSL存在的意义是防止最后一个包丢失</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-入门概述</title>
    <url>/2021/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>网络：多台主机相连</p>
<p>互联网：多个网络相连</p>
<p>因特网：全球最大的互联网（基于TCP/IP体系）</p>
<h1 id="因特网两大组成部分"><a href="#因特网两大组成部分" class="headerlink" title="因特网两大组成部分"></a>因特网两大组成部分</h1><blockquote>
<p>边缘部分：连接在因特网上的众多主机，利用核心部分提供的服务实现通信。</p>
<p>核心部分：由许多路由器实现互连，对网络边缘的主机提供连通性，使边缘部分的众多主机之间能够互相通信。</p>
</blockquote>
<h2 id="边缘部分的连接方式"><a href="#边缘部分的连接方式" class="headerlink" title="边缘部分的连接方式"></a>边缘部分的连接方式</h2><ul>
<li>客户端/服务器方式(C/S)</li>
<li>对等连接方式(P2P)</li>
</ul>
<h2 id="核心部分的连接方式"><a href="#核心部分的连接方式" class="headerlink" title="核心部分的连接方式"></a>核心部分的连接方式</h2><ul>
<li>电路交换，常见于核心路由之间</li>
<li>报文交换</li>
<li>分组交换</li>
</ul>
<h1 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h1><ul>
<li>速率</li>
<li>带宽</li>
<li>吞吐量</li>
<li>时延<ul>
<li>发送时延</li>
<li>传送时延</li>
<li>处理时延</li>
<li>排队时延</li>
</ul>
</li>
<li>时延带宽积<code>时延带宽积 = 传播时延 * 带宽</code></li>
<li>利用率<ul>
<li>信道利用率<code>信道利用率 = 信道有数据时间 / 信道使用的总时间</code></li>
<li>网络利用率<code>网络利用率 = 信道利用率的加权平均</code></li>
</ul>
</li>
</ul>
<h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><h2 id="七层结构模型"><a href="#七层结构模型" class="headerlink" title="七层结构模型"></a>七层结构模型</h2><table>
<thead>
<tr>
<th>层级名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>应用程序</td>
</tr>
<tr>
<td>表示层</td>
<td>加密、压缩</td>
</tr>
<tr>
<td>会话层</td>
<td>服务器和客户端建立的会话</td>
</tr>
<tr>
<td>传输层</td>
<td>可靠传输(建立会话)，不可靠传输(不建立会话)、流量控制</td>
</tr>
<tr>
<td>网络层</td>
<td>选择最优路径，添加IP地址编址</td>
</tr>
<tr>
<td>数据链路层</td>
<td>添加物理层地址MAC</td>
</tr>
<tr>
<td>物理层</td>
<td>规定电压、接口等标准</td>
</tr>
</tbody></table>
<h2 id="五层结构模型"><a href="#五层结构模型" class="headerlink" title="五层结构模型"></a>五层结构模型</h2><table>
<thead>
<tr>
<th>层级名称</th>
<th>传输单位</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>传输数据单元PDU</td>
</tr>
<tr>
<td>传输层</td>
<td>报文数据段</td>
</tr>
<tr>
<td>网络层</td>
<td>IP数据报(IP分组)，若数据包大于1500字节会分片</td>
</tr>
<tr>
<td>数据链路层</td>
<td>数据帧</td>
</tr>
<tr>
<td>物理层</td>
<td>比特</td>
</tr>
</tbody></table>
<h2 id="四层结构模型"><a href="#四层结构模型" class="headerlink" title="四层结构模型"></a>四层结构模型</h2><table>
<thead>
<tr>
<th>层级名称</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
</tr>
<tr>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
</tr>
<tr>
<td>链路层</td>
</tr>
</tbody></table>
<h2 id="网络设备与结构模型的关系"><a href="#网络设备与结构模型的关系" class="headerlink" title="网络设备与结构模型的关系"></a>网络设备与结构模型的关系</h2><ul>
<li>路由器：负责到最高到网络层</li>
<li>交换机：负责到数据链路层，会解析出MAC地址存储转发</li>
<li>集线器：负责物理层，直接转发</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-应用层</title>
    <url>/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h1 id="常用的应用层协议"><a href="#常用的应用层协议" class="headerlink" title="常用的应用层协议"></a>常用的应用层协议</h1><ul>
<li>DNS：域名系统</li>
<li>DHCP：动态主机配置协议</li>
<li>FTP：文件传达协议</li>
<li>TELNET：远程终端协议</li>
<li>RDP：远程桌面</li>
<li>HTTP：超文本传输协议</li>
<li>SMTP、POP3、IMAP：电子邮件</li>
</ul>
<h1 id="不同应用层协议与传输层的关系"><a href="#不同应用层协议与传输层的关系" class="headerlink" title="不同应用层协议与传输层的关系"></a>不同应用层协议与传输层的关系</h1><ul>
<li>基于TCP协议<ul>
<li>RDP（用于远程连接），端口号为3389</li>
<li>FTP，端口号为21</li>
<li>TELNET，端口号为23</li>
<li>SMTP（用于发邮件），端口号为25</li>
<li>HTTP，端口号为80</li>
<li>HTTPS，端口号为443</li>
<li>SQL，端口号为1433</li>
<li>DNS，端口号为53</li>
</ul>
</li>
<li>基于UDP协议<ul>
<li>TFTP，端口号为69</li>
<li>SNMP，端口号为161</li>
<li>RIP，端口号为520</li>
<li>DNS，端口号为53</li>
</ul>
</li>
</ul>
<blockquote>
<p>其中混入一个奇怪的家伙——DNS，它能够左右横跳，但是我们日常多数基于UDP协议</p>
</blockquote>
<h1 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h1><blockquote>
<p>负责解析域名，将域名解析成IP地址</p>
</blockquote>
<h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><ul>
<li>根域名</li>
<li>顶级域名（com、edu、net、cn、org、gov）</li>
<li>二级域名（baidu、google、4399）</li>
<li>三级域名（home.baidu、help.baidu）</li>
</ul>
<h2 id="域名解析测试"><a href="#域名解析测试" class="headerlink" title="域名解析测试"></a>域名解析测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br><span class="line"></span><br><span class="line">nslookup www.baidu.com</span><br></pre></td></tr></table></figure>


<h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><p><img src="https://jiajuu.top/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png" alt="域名的解析过程"></p>
<blockquote>
<p>本地DNS服务器的存在意义</p>
<ul>
<li>快速解析内网域名</li>
<li>自身缓存表，节省Internet域名解析的次数</li>
</ul>
</blockquote>
<h1 id="DHCP动态主机配置"><a href="#DHCP动态主机配置" class="headerlink" title="DHCP动态主机配置"></a>DHCP动态主机配置</h1><ul>
<li><p>为主机动态分配IP地址</p>
<ul>
<li><p>静态IP地址：</p>
<p>静态IP一般都是网络运营商提供的，或者是局域网中的静态不变的IP。</p>
</li>
<li><p>动态IP地址：</p>
<p>通过广播请求DHCP获取动态IP地址</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：DHCP服务器的IP地址必须为静态IP地址</p>
</blockquote>
<h1 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h1><h2 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h2><ul>
<li>控制连接：标准端口号为21，用于发送FTP命令信息</li>
<li>数据连接：标准端口号为20，用于上传、下载数据</li>
</ul>
<h2 id="连接类型"><a href="#连接类型" class="headerlink" title="连接类型"></a>连接类型</h2><ul>
<li>主动连接模式：<ol>
<li>客户端告知服务端FTP数据连接端口</li>
<li>等待服务端连接（服务端使用20端口连接）</li>
</ol>
</li>
<li>被动连接模式：<ol>
<li>服务端告知客户端FTP数据连接端口</li>
<li>等待客户端连接（服务端使用随机端口）</li>
</ol>
</li>
</ul>
<blockquote>
<p>若服务器有防火墙，那么服务器需要开放20、21端口，并且使用主动模式连接</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-数据链路层</title>
    <url>/2021/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li>链路：物理上的线路段</li>
<li>数据链路：硬件(数据线路段)+软件(通信协议)</li>
</ul>
<h1 id="信道类型"><a href="#信道类型" class="headerlink" title="信道类型"></a>信道类型</h1><ul>
<li>点对点信道</li>
<li>广播信道</li>
</ul>
<h1 id="传输的基本单位"><a href="#传输的基本单位" class="headerlink" title="传输的基本单位"></a>传输的基本单位</h1><ul>
<li><p>帧</p>
<blockquote>
<p>帧是面向字节，其数据长度为整数个字节</p>
</blockquote>
<p><img src="https://jiajuu.top/2021/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B8%A7%E6%A0%BC%E5%BC%8F.jpg" alt="传输的基本单位——帧"></p>
</li>
</ul>
<h1 id="解决的基本问题"><a href="#解决的基本问题" class="headerlink" title="解决的基本问题"></a>解决的基本问题</h1><ul>
<li>封装成帧</li>
<li>透明传输</li>
<li>差错控制</li>
</ul>
<h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p><img src="https://jiajuu.top/2021/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7.jpg" alt="封装成帧"></p>
<h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><ul>
<li>当出现SOH(即0000 0001)时说明这是帧的开头</li>
<li>当出现EOT(即0000 0100)时说明这是帧的结尾</li>
</ul>
<p><img src="https://jiajuu.top/2021/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93.jpg" alt="透明传输"></p>
<blockquote>
<p>问：但是如果我数据部分里面恰好出现了0000 0001呢？</p>
<p>答：这时候就用到了我们的转义字符(ESC)了，我们在出现SOH前添加ESC，声明一下我们后面的内容是数据，你别乱给我转义</p>
<p><img src="https://jiajuu.top/2021/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6.jpg" alt="转移字符"></p>
</blockquote>
<h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><ol>
<li>通过循环冗余检验(CRC)计算</li>
<li>得到帧校验序列(FCS)</li>
</ol>
<h1 id="点到点信道的数据链路层"><a href="#点到点信道的数据链路层" class="headerlink" title="点到点信道的数据链路层"></a>点到点信道的数据链路层</h1><ul>
<li><p>代表协议：PPP协议</p>
<p>组成：</p>
<ul>
<li>NCP协议(网络控制协议)</li>
<li>LCP协议(链路控制协议)</li>
<li>HDLC(高级数据链路控制协议)</li>
</ul>
<p>注意：PPP协议没有序号机制和确认机制</p>
<ul>
<li><p>原因①：数据链路层出错概率不大</p>
</li>
<li><p>原因②：数据链路层并不保证上层数据的传输可靠性</p>
</li>
<li><p>原因③：帧检验序列FCS字段保证了无差错检测</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://jiajuu.top/2021/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/PPP%E5%8D%8F%E8%AE%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F.jpg" alt="PPP协议帧格式"></p>
<blockquote>
<p>协议字段的常用协议：</p>
<p>0x0021：IP数据包</p>
<p>0xC021：LCP数据</p>
<p>0x8021：NCP数据</p>
<p>0xC023：安全性认证PAP</p>
<p>0xC025：LQR</p>
<p>0xC223：安全性认证CHAP</p>
</blockquote>
<h1 id="广播信道的数据链路层"><a href="#广播信道的数据链路层" class="headerlink" title="广播信道的数据链路层"></a>广播信道的数据链路层</h1><h2 id="实现的方法"><a href="#实现的方法" class="headerlink" title="实现的方法"></a>实现的方法</h2><ul>
<li><p>静态划分信道</p>
<ul>
<li>频分复用</li>
<li>时分复用</li>
<li>波分复用</li>
<li>码分复用</li>
</ul>
<blockquote>
<p>实现麻烦，不使用该方法</p>
</blockquote>
</li>
<li><p>动态媒体接入控制(多点接入)</p>
<ul>
<li>随机接入(以太网主要采用)</li>
<li>受控接入(如多点线路探询polling或轮询，已不采用)</li>
</ul>
</li>
</ul>
<h2 id="常用协议"><a href="#常用协议" class="headerlink" title="常用协议"></a>常用协议</h2><ul>
<li><p>CSMA/CD(载波侦听多路访问/冲突检测)协议</p>
<blockquote>
<p>载波侦听多路访问：多台主机以多点的方式连接在一条总线上</p>
<p>冲突检测：发数据前会检测总线上是否有数据传输，有则不发送</p>
<br>

<p>检测依据：信道上的电压</p>
<p>通讯方式：半双工通信协议</p>
</blockquote>
<ul>
<li><p>争用期：2τ（通常取51.2μs）</p>
<blockquote>
<p>51.2μs在10Mb/s的以太网中，可发送512bit，即64字节</p>
<p>所以导致：</p>
<ul>
<li>以太网线长度大多不大于100米</li>
<li>发送的数据至少64个字节<ul>
<li>以太网帧的最短有效帧长度为64字节</li>
<li>少于64字节的帧都已由于冲突而中止的异常帧</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>退避算法：</p>
<ul>
<li>基本退避时间：一般为2τ</li>
<li>重传时延为r倍的基本退避时间</li>
<li>r是从集合[0,1,2,…,(2^k-1)]中的随机取出的一个数</li>
<li>k=Min[重传次数，10]</li>
<li>当重传达到16次仍没有成功会丢弃该帧，并向上层报告</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><ul>
<li><p>满足CSMA/CD协议的网络</p>
</li>
<li><p>为了使数据链路层更好的适应多种局域网标准，数据链路层还拆分成两个子层</p>
<ul>
<li>逻辑链路控制LLC子层</li>
<li>媒体接入控制MAC子层</li>
</ul>
<blockquote>
<p>市面上的网络适配器大多仅装有MAC协议，而没有LLC协议</p>
</blockquote>
</li>
<li><p>提供的服务是不可靠的交付，尽最大努力交付</p>
</li>
<li><p>MAC地址：MAC层的硬件地址</p>
</li>
</ul>
<blockquote>
<p>网络适配器会从网络中收到的MAC帧解析出MAC地址</p>
<ul>
<li>如果是发给自己的则收下，会接受<ul>
<li>单播帧</li>
<li>多播帧</li>
<li>广播帧</li>
</ul>
</li>
<li>否则丢弃</li>
</ul>
</blockquote>
<h2 id="MAC帧格式"><a href="#MAC帧格式" class="headerlink" title="MAC帧格式"></a>MAC帧格式</h2><p><img src="https://jiajuu.top/2021/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/mac%E5%B8%A7%E6%A0%BC%E5%BC%8F.jpg" alt="mac帧格式"></p>
<ul>
<li>有效帧的要求：<ul>
<li>必须为整数个字节</li>
<li>FCS无差错</li>
<li>数据长度必须在46-1500个字节范围内（其中1500为最大MTU）</li>
<li>帧长度必须在64-1518个字节范围内</li>
</ul>
</li>
<li>每个帧之间间隔不能少于9.6μs，给时间清理接受的缓存</li>
</ul>
<h2 id="拓展以太网"><a href="#拓展以太网" class="headerlink" title="拓展以太网"></a>拓展以太网</h2><h3 id="拓展范围"><a href="#拓展范围" class="headerlink" title="拓展范围"></a>拓展范围</h3><ul>
<li>双绞线（100米）</li>
<li>光纤（上千公里）</li>
</ul>
<h3 id="拓展数量"><a href="#拓展数量" class="headerlink" title="拓展数量"></a>拓展数量</h3><ul>
<li><p>网桥</p>
<blockquote>
<ul>
<li>先检测mac地址，再确认发往那个端口</li>
<li>端口连接的是集线器</li>
</ul>
</blockquote>
</li>
<li><p>交换器</p>
<blockquote>
<p>端口连接的是主机</p>
</blockquote>
</li>
</ul>
<h2 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h2><ul>
<li>100Mb/s</li>
<li>全双工通信</li>
<li>不使用CSMA/CD协议</li>
<li>保持最短帧长度不变，但网段的最大电缆长度减小至100米</li>
<li>帧间隔时间9.6μs改成现在的0.96μs</li>
</ul>
<h2 id="吉比特以太网"><a href="#吉比特以太网" class="headerlink" title="吉比特以太网"></a>吉比特以太网</h2><ul>
<li>1Gb/s</li>
<li>半双工/全双工通信</li>
<li>半双工使用CSMA/CD协议，全双工不使用CSMA/CD协议</li>
</ul>
<h2 id="十吉比特以太网"><a href="#十吉比特以太网" class="headerlink" title="十吉比特以太网"></a>十吉比特以太网</h2><ul>
<li>10Gb/s</li>
<li>不再使用铜线，只使用光纤作为传输媒介</li>
<li>全双工通信</li>
<li>不使用CSMA/CD协议</li>
<li>从而能够实现端对端通信，从局域网扩大到城域网和广域网</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-物理层</title>
    <url>/2021/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><blockquote>
<p>如何在传输媒介上传输比特流</p>
</blockquote>
<ul>
<li><p>机械特性</p>
<p>例如：规定接口形状、大小、引脚数</p>
</li>
<li><p>电气特性</p>
<p>例如：规定电压范围</p>
</li>
<li><p>功能特性</p>
<p>例如：规定-5V表示0，+5V表示1</p>
</li>
<li><p>过程特性(规程特性)</p>
<p>例如：规定连接时各个相关部件的工作步骤</p>
</li>
</ul>
<h1 id="数据通信的基本模型"><a href="#数据通信的基本模型" class="headerlink" title="数据通信的基本模型"></a>数据通信的基本模型</h1><blockquote>
<p>通讯的最终目的就是传达消息</p>
<br>

<p>数据：</p>
<ul>
<li>传送信息的实体</li>
</ul>
<p>信号：</p>
<ul>
<li>模拟信号(取值连续)</li>
<li>数字信号(取值离散)</li>
</ul>
<p>码元：</p>
<ul>
<li>时间间隔内表示的数据<ul>
<li>当时间间隔携带一个二进制数那便是二进制码元。</li>
<li>码元可以携带多个bit，例如：数据以电压为媒介，1V代表1，2V代表10，…，7V代表111。携带了3bit。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://jiajuu.top/2021/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82/CommunicationModel.png" alt="数据通信的基本模型"></p>
<h1 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h1><h2 id="通讯方式"><a href="#通讯方式" class="headerlink" title="通讯方式"></a>通讯方式</h2><ul>
<li>单工通信（单向通信）</li>
<li>半双工通信（双向交替通信）</li>
<li>全双工通信（双向同时通信）</li>
</ul>
<h2 id="通讯信号"><a href="#通讯信号" class="headerlink" title="通讯信号"></a>通讯信号</h2><ul>
<li><p>基带信号（发出的直接表达了要传输信息的信号）</p>
<blockquote>
<ul>
<li><p>基本频带信息——来自信源的信号</p>
</li>
<li><p>计算机内部采用基带信号，因为短范围内的衰减不大</p>
</li>
</ul>
</blockquote>
</li>
<li><p>带通信号（把信号频率范围搬到较高频段以便在信道传输）</p>
</li>
</ul>
<h1 id="调制方法"><a href="#调制方法" class="headerlink" title="调制方法"></a>调制方法</h1><ul>
<li>调幅（AM）</li>
<li>调频（FM）</li>
<li>调相（PM）</li>
</ul>
<h1 id="编码形式"><a href="#编码形式" class="headerlink" title="编码形式"></a>编码形式</h1><ul>
<li>单极性不归零码</li>
<li>双极性不归零码</li>
<li>单极性归零码</li>
<li>双极性归零码</li>
<li>曼切斯特编码</li>
<li>差分曼切斯特编码</li>
</ul>
<h1 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h1><blockquote>
<p>给定了假定理想条件下，为了避免码间串扰，码元传输速率的上限值</p>
</blockquote>
<h1 id="香浓公式"><a href="#香浓公式" class="headerlink" title="香浓公式"></a>香浓公式</h1><blockquote>
<p>C=W log2(1+S/N)</p>
<p><br>其中：</p>
<ul>
<li><p>C为极限信息传输速率</p>
</li>
<li><p>W为带宽</p>
</li>
<li><p>S为信号的平均功率</p>
</li>
<li><p>N为高斯噪声功率</p>
</li>
<li><p>S/N为信噪比</p>
</li>
</ul>
<br>

<p>可得：</p>
<ul>
<li><p>可以通过提高宽带的方式提高传输速率</p>
</li>
<li><p>可以通过提高信噪比的方式来提高传输速率</p>
</li>
<li><p>可以通过降低速率的方式实现无差错传输</p>
</li>
</ul>
</blockquote>
<h1 id="传输媒介"><a href="#传输媒介" class="headerlink" title="传输媒介"></a>传输媒介</h1><h2 id="导向传输媒介"><a href="#导向传输媒介" class="headerlink" title="导向传输媒介"></a>导向传输媒介</h2><ul>
<li>双绞线<ul>
<li>无屏蔽双绞线（UTP）</li>
<li>屏蔽双绞线（STP）</li>
</ul>
</li>
<li>同轴电缆<ul>
<li>50Ω同轴电缆（常用于数字传输）</li>
<li>70Ω同轴电缆（常用于模拟传输）</li>
</ul>
</li>
<li>光缆<ul>
<li>多模光纤（多用于基带传输）</li>
<li>单模光纤</li>
</ul>
</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>直通线（常用于不同设备的相连）</p>
<blockquote>
<p>例如：</p>
<ul>
<li><p>主机连接交换机、集线器</p>
</li>
<li><p>路由器连接交换机、集线器</p>
</li>
</ul>
</blockquote>
<p>交叉线（常用于同类设备相连）</p>
<h2 id="非导向传输媒介"><a href="#非导向传输媒介" class="headerlink" title="非导向传输媒介"></a>非导向传输媒介</h2><blockquote>
<p>说人话：无线传输</p>
</blockquote>
<ul>
<li>短波通信</li>
<li>微波通信（主要用于直线传输）<ul>
<li>用于地面微波接力通信</li>
<li>用于卫星通讯</li>
</ul>
</li>
</ul>
<h1 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h1><ul>
<li>扩大网络的传输范围</li>
<li>不具备信号定向传送功能</li>
<li>是一个大的冲突域（同一时间只能由一个设备发送数据）</li>
</ul>
<h1 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h1><ul>
<li>频分复用（FDM）</li>
<li>时分复用（TDM）</li>
<li>波分复用（WDM）</li>
</ul>
<h1 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h1><ul>
<li><p>xDSL（用数字技术对现有的模拟电话用户线改造改造）</p>
<p>采用DMT调制技术（频分复用技术）</p>
<ul>
<li>40kHz ~1.1MHz 划分多个子信道（每个信道占4kHz）<ul>
<li>25个上行信道</li>
<li>249个下行信道</li>
</ul>
</li>
</ul>
</li>
<li><p>HFC（光纤同轴混合网，也就是有线电视网络）</p>
</li>
<li><p>FTTx（光纤到x）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-网络安全</title>
    <url>/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="常见威胁"><a href="#常见威胁" class="headerlink" title="常见威胁"></a>常见威胁</h1><ul>
<li>被动：<ul>
<li>截获</li>
</ul>
</li>
<li>主动<ul>
<li>中断</li>
<li>篡改</li>
<li>伪造</li>
</ul>
</li>
</ul>
<h1 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术"></a>加密技术</h1><ul>
<li>对称加密：<ul>
<li>优点：效率高</li>
<li>缺点：密钥维护麻烦，不适用于网上传输</li>
</ul>
</li>
<li>非对称加密：<ul>
<li>公钥、密钥</li>
<li>公钥负责加密，密钥负责解密</li>
<li>缺点：效率低</li>
</ul>
</li>
</ul>
<blockquote>
<p>区别：密钥是否为同一份</p>
</blockquote>
<ul>
<li>对称加密与非对称加密：<ul>
<li>用非对称密钥加密堆成加密的密钥</li>
<li>文件使用对称加密</li>
</ul>
</li>
</ul>
<h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><blockquote>
<p>能够检查签名后是否被篡改</p>
</blockquote>
<p>签名加解密流程：</p>
<p><img src="https://jiajuu.top/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E6%B5%81%E7%A8%8B.png" alt="数字签名流程"></p>
<h1 id="证书颁发机构CA"><a href="#证书颁发机构CA" class="headerlink" title="证书颁发机构CA"></a>证书颁发机构CA</h1><blockquote>
<p>颁发证书，其中包含公钥、密钥</p>
</blockquote>
<p>颁发流程：</p>
<p><img src="https://jiajuu.top/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%B5%81%E7%A8%8B.png" alt="证书颁发流程"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-网络层</title>
    <url>/2021/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<blockquote>
<p>两台主机间的通信的传输过程最高尽到网络层</p>
<br>

<p>网络层负责在不同网络中基于数据包中的ip地址转发尽力转发数据包，不负责丢失重传</p>
</blockquote>
<h1 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h1><ul>
<li>ARP协议（给IP协议服务）</li>
<li>IP协议（给ICMP协议服务）</li>
<li>ICMP协议（给IGMP协议服务）</li>
<li>IGMP协议</li>
</ul>
<h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><blockquote>
<p>广播获取目的IP的MAC地址</p>
<p>P.S广播只能存在于一个网络，跨不了路由器。</p>
</blockquote>
<ul>
<li><p>ARP欺骗</p>
<p>对方广播询问IP地址时，告知对方这个IP是我，并发送自己的MAC地址，收到数据后再转发给真正的MAC地址</p>
</li>
</ul>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><blockquote>
<p>路由器自动学习路由表，给数据包选择路径的协议</p>
<p>例如：RIP协议、OSPF协议都属于IP协议</p>
</blockquote>
<ul>
<li>静态路由：管理员手动配置的路由</li>
<li>动态路由：由路由器使用IP协议自行学习的路由</li>
</ul>
<h3 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h3><blockquote>
<p>动态路由协议</p>
</blockquote>
<ul>
<li>根据路由器跳数选择路由</li>
<li>路由器会定期（30秒）发送广播路由表</li>
<li>跳数少为最优路径</li>
<li>最大跳数为15跳，大于15跳则视为不可到达</li>
</ul>
<h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><blockquote>
<p>网际控制报文协议</p>
</blockquote>
<ul>
<li><p>检测网络层是否由故障（Ping命令底层便是使用ICMP协议）</p>
<p>Ping命令的小知识：</p>
<ul>
<li>当我们ping不过去的时候，会显示无法到达</li>
<li>当我们ping过去后，返回不回来时，会显示超时</li>
</ul>
<blockquote>
<p>因为过不去的时候，路由会根据源IP地址返回信息，</p>
<p>返回不回来的时候，因为路由不清楚目的IP地址怎么走，直至超时。</p>
</blockquote>
</li>
</ul>
<h2 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a>IGMP协议</h2><ul>
<li>配置给路由器定期扫描网段中的多播地址</li>
<li>多播也叫组播</li>
<li>把IP地址统一改成一个多播IP地址，向路由器声明自己是组播组成员（大概就是拉我进群的意思）</li>
</ul>
<h1 id="IP数据包"><a href="#IP数据包" class="headerlink" title="IP数据包"></a>IP数据包</h1><p><img src="http://jiajuu.top/2021/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E6%A0%BC%E5%BC%8F.jpg" alt="IP数据包格式"></p>
<blockquote>
<ul>
<li>版本：IPv4/IPv6</li>
<li>区分服务：可以调整数据包的优先级（QoS）</li>
<li>标识：分片的标识，用于区分是否是同一组数据包</li>
<li>标志：区分是否分片</li>
<li>生存时间：TTL</li>
<li>协议：<ul>
<li>ICMP：1</li>
<li>IGMP：2</li>
<li>TCP：6</li>
<li>UDP：17</li>
<li>IPv6：41</li>
</ul>
</li>
</ul>
<p>首部至少20个字节</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
